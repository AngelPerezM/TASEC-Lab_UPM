/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "tasec_lab_b2space.h"

const asn1SccSint n_of_TC74s = 5;
const asn1SccSint n_of_pt1000 = 6;


flag T_Int16_Equal(const T_Int16* pVal1, const T_Int16* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Int16_Initialize(T_Int16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int16_IsConstraintValid(const T_Int16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-32768LL <= (*(pVal))) && ((*(pVal)) <= 32767LL));
    *pErrCode = ret ? 0 :  ERR_T_INT16; 

	return ret;
}

flag T_Int16_Encode(const T_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int16_Decode(T_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT16;

	return ret  && T_Int16_IsConstraintValid(pVal, pErrCode);
}

flag T_Int16_ACN_Encode(const T_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int16_ACN_Decode(T_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT16;

    return ret && T_Int16_IsConstraintValid(pVal, pErrCode);
}



flag MGT_Raw_Data_Equal(const MGT_Raw_Data* pVal1, const MGT_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void MGT_Raw_Data_Initialize(MGT_Raw_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Int16_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Int16_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Int16_Initialize((&(pVal->z_axis)));
}

flag MGT_Raw_Data_IsConstraintValid(const MGT_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Int16_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Int16_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Int16_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag MGT_Raw_Data_Encode(const MGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? MGT_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MGT_Raw_Data_Decode(MGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && MGT_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag MGT_Raw_Data_ACN_Encode(const MGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? MGT_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MGT_Raw_Data_ACN_Decode(MGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && MGT_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag ACC_Raw_Data_Equal(const ACC_Raw_Data* pVal1, const ACC_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void ACC_Raw_Data_Initialize(ACC_Raw_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Int16_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Int16_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Int16_Initialize((&(pVal->z_axis)));
}

flag ACC_Raw_Data_IsConstraintValid(const ACC_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Int16_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Int16_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Int16_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag ACC_Raw_Data_Encode(const ACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? ACC_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ACC_Raw_Data_Decode(ACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && ACC_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag ACC_Raw_Data_ACN_Encode(const ACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? ACC_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ACC_Raw_Data_ACN_Decode(ACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && ACC_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag GYRO_Raw_Data_Equal(const GYRO_Raw_Data* pVal1, const GYRO_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void GYRO_Raw_Data_Initialize(GYRO_Raw_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Int16_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Int16_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Int16_Initialize((&(pVal->z_axis)));
}

flag GYRO_Raw_Data_IsConstraintValid(const GYRO_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Int16_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Int16_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Int16_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag GYRO_Raw_Data_Encode(const GYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? GYRO_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GYRO_Raw_Data_Decode(GYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && GYRO_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag GYRO_Raw_Data_ACN_Encode(const GYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? GYRO_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GYRO_Raw_Data_ACN_Decode(GYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && GYRO_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt16_Equal(const T_UInt16* pVal1, const T_UInt16* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt16_Initialize(T_UInt16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt16_IsConstraintValid(const T_UInt16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT16; 

	return ret;
}

flag T_UInt16_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt16_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT16;

	return ret  && T_UInt16_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt16_ACN_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt16_ACN_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT16;

    return ret && T_UInt16_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt64_Equal(const T_UInt64* pVal1, const T_UInt64* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt64_Initialize(T_UInt64* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt64_IsConstraintValid(const T_UInt64* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag T_UInt64_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt64_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT64;

	return ret  && T_UInt64_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt64_ACN_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt64_ACN_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT64;

    return ret && T_UInt64_IsConstraintValid(pVal, pErrCode);
}



flag T_Float_Equal(const T_Float* pVal1, const T_Float* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Float_Initialize(T_Float* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.00000000000000000000E+000;
}

flag T_Float_IsConstraintValid(const T_Float* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-3.40000000000000000000E+038 <= (*(pVal))) && ((*(pVal)) <= 3.40000000000000000000E+038));
    *pErrCode = ret ? 0 :  ERR_T_FLOAT; 

	return ret;
}

flag T_Float_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Float_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FLOAT;

	return ret  && T_Float_IsConstraintValid(pVal, pErrCode);
}

flag T_Float_ACN_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Float_ACN_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_FLOAT;

    return ret && T_Float_IsConstraintValid(pVal, pErrCode);
}



flag MGT_MilliGauss_Data_Equal(const MGT_MilliGauss_Data* pVal1, const MGT_MilliGauss_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void MGT_MilliGauss_Data_Initialize(MGT_MilliGauss_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Float_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Float_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Float_Initialize((&(pVal->z_axis)));
}

flag MGT_MilliGauss_Data_IsConstraintValid(const MGT_MilliGauss_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Float_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Float_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Float_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag MGT_MilliGauss_Data_Encode(const MGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? MGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MGT_MilliGauss_Data_Decode(MGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && MGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode);
}

flag MGT_MilliGauss_Data_ACN_Encode(const MGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? MGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MGT_MilliGauss_Data_ACN_Decode(MGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && MGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode);
}



flag ACC_MilliG_Data_Equal(const ACC_MilliG_Data* pVal1, const ACC_MilliG_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void ACC_MilliG_Data_Initialize(ACC_MilliG_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Float_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Float_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Float_Initialize((&(pVal->z_axis)));
}

flag ACC_MilliG_Data_IsConstraintValid(const ACC_MilliG_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Float_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Float_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Float_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag ACC_MilliG_Data_Encode(const ACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? ACC_MilliG_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ACC_MilliG_Data_Decode(ACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && ACC_MilliG_Data_IsConstraintValid(pVal, pErrCode);
}

flag ACC_MilliG_Data_ACN_Encode(const ACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? ACC_MilliG_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ACC_MilliG_Data_ACN_Decode(ACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && ACC_MilliG_Data_IsConstraintValid(pVal, pErrCode);
}



flag GYRO_MilliDPS_Data_Equal(const GYRO_MilliDPS_Data* pVal1, const GYRO_MilliDPS_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void GYRO_MilliDPS_Data_Initialize(GYRO_MilliDPS_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Float_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Float_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Float_Initialize((&(pVal->z_axis)));
}

flag GYRO_MilliDPS_Data_IsConstraintValid(const GYRO_MilliDPS_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Float_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Float_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Float_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag GYRO_MilliDPS_Data_Encode(const GYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? GYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GYRO_MilliDPS_Data_Decode(GYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && GYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode);
}

flag GYRO_MilliDPS_Data_ACN_Encode(const GYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? GYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GYRO_MilliDPS_Data_ACN_Decode(GYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && GYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode);
}



flag PT1000s_Raw_Data_elem_Equal(const PT1000s_Raw_Data_elem* pVal1, const PT1000s_Raw_Data_elem* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->vcc_volts == pVal2->vcc_volts);

    if (ret) {
        ret = (pVal1->pt1000 == pVal2->pt1000);

    }

	return ret;

}

flag PT1000s_Raw_Data_Equal(const PT1000s_Raw_Data* pVal1, const PT1000s_Raw_Data* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 6; i1++) 
    {
    	ret = PT1000s_Raw_Data_elem_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

void PT1000s_Raw_Data_elem_Initialize(PT1000s_Raw_Data_elem* pVal)
{
	(void)pVal;



	/*set vcc_volts */
	T_Float_Initialize((&(pVal->vcc_volts)));
	/*set pt1000 */
	T_Float_Initialize((&(pVal->pt1000)));
}
void PT1000s_Raw_Data_Initialize(PT1000s_Raw_Data* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 6) {
	    PT1000s_Raw_Data_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag PT1000s_Raw_Data_IsConstraintValid(const PT1000s_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 6; i1++) 
    {
    	ret = T_Float_IsConstraintValid((&(pVal->arr[i1].vcc_volts)), pErrCode);
    	if (ret) {
    	    ret = T_Float_IsConstraintValid((&(pVal->arr[i1].pt1000)), pErrCode);
    	}
    }

	return ret;
}

flag PT1000s_Raw_Data_Encode(const PT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? PT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)6) && ret; i1++) 
	    {
	    	/*Encode vcc_volts */
	    	ret = T_Float_Encode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode pt1000 */
	    	    ret = T_Float_Encode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Raw_Data_Decode(PT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)6) && ret; i1++) 
	{
		/*Decode vcc_volts */
		ret = T_Float_Decode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode);
		if (ret) {
		    /*Decode pt1000 */
		    ret = T_Float_Decode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode);
		}
	}

	return ret  && PT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag PT1000s_Raw_Data_ACN_Encode(const PT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? PT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)6) && ret; i1++) 
	    {
	    	/*Encode vcc_volts */
	    	ret = T_Float_ACN_Encode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode pt1000 */
	    	    ret = T_Float_ACN_Encode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode, FALSE);
	    	}

	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Raw_Data_ACN_Decode(PT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)6) && ret; i1++) 
	{
		/*Decode vcc_volts */
		ret = T_Float_ACN_Decode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode);
		if (ret) {
		    /*Decode pt1000 */
		    ret = T_Float_ACN_Decode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode);
		}

	}

    return ret && PT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag PT1000s_Celsius_Data_Equal(const PT1000s_Celsius_Data* pVal1, const PT1000s_Celsius_Data* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 6; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void PT1000s_Celsius_Data_Initialize(PT1000s_Celsius_Data* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 6) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag PT1000s_Celsius_Data_IsConstraintValid(const PT1000s_Celsius_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 6; i1++) 
    {
    	ret = T_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag PT1000s_Celsius_Data_Encode(const PT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? PT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)6) && ret; i1++) 
	    {
	    	ret = T_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Celsius_Data_Decode(PT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)6) && ret; i1++) 
	{
		ret = T_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && PT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode);
}

flag PT1000s_Celsius_Data_ACN_Encode(const PT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? PT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)6) && ret; i1++) 
	    {
	    	ret = T_Float_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Celsius_Data_ACN_Decode(PT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)6) && ret; i1++) 
	{
		ret = T_Float_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && PT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode);
}



flag PS_Calibration_Data_Equal(const PS_Calibration_Data* pVal1, const PS_Calibration_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->c1 == pVal2->c1);

    if (ret) {
        ret = (pVal1->c2 == pVal2->c2);

        if (ret) {
            ret = (pVal1->c3 == pVal2->c3);

            if (ret) {
                ret = (pVal1->c4 == pVal2->c4);

                if (ret) {
                    ret = (pVal1->c5 == pVal2->c5);

                    if (ret) {
                        ret = (pVal1->c6 == pVal2->c6);

                        if (ret) {
                            ret = (pVal1->sens_t1 == pVal2->sens_t1);

                            if (ret) {
                                ret = (pVal1->off_t1 == pVal2->off_t1);

                                if (ret) {
                                    ret = (pVal1->tcs == pVal2->tcs);

                                    if (ret) {
                                        ret = (pVal1->tco == pVal2->tco);

                                        if (ret) {
                                            ret = (pVal1->tref == pVal2->tref);

                                            if (ret) {
                                                ret = (pVal1->temp_sens == pVal2->temp_sens);

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void PS_Calibration_Data_Initialize(PS_Calibration_Data* pVal)
{
	(void)pVal;



	/*set c1 */
	T_UInt16_Initialize((&(pVal->c1)));
	/*set c2 */
	T_UInt16_Initialize((&(pVal->c2)));
	/*set c3 */
	T_UInt16_Initialize((&(pVal->c3)));
	/*set c4 */
	T_UInt16_Initialize((&(pVal->c4)));
	/*set c5 */
	T_UInt16_Initialize((&(pVal->c5)));
	/*set c6 */
	T_UInt16_Initialize((&(pVal->c6)));
	/*set sens_t1 */
	T_Float_Initialize((&(pVal->sens_t1)));
	/*set off_t1 */
	T_Float_Initialize((&(pVal->off_t1)));
	/*set tcs */
	T_Float_Initialize((&(pVal->tcs)));
	/*set tco */
	T_Float_Initialize((&(pVal->tco)));
	/*set tref */
	T_Float_Initialize((&(pVal->tref)));
	/*set temp_sens */
	T_Float_Initialize((&(pVal->temp_sens)));
}

flag PS_Calibration_Data_IsConstraintValid(const PS_Calibration_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt16_IsConstraintValid((&(pVal->c1)), pErrCode);
    if (ret) {
        ret = T_UInt16_IsConstraintValid((&(pVal->c2)), pErrCode);
        if (ret) {
            ret = T_UInt16_IsConstraintValid((&(pVal->c3)), pErrCode);
            if (ret) {
                ret = T_UInt16_IsConstraintValid((&(pVal->c4)), pErrCode);
                if (ret) {
                    ret = T_UInt16_IsConstraintValid((&(pVal->c5)), pErrCode);
                    if (ret) {
                        ret = T_UInt16_IsConstraintValid((&(pVal->c6)), pErrCode);
                        if (ret) {
                            ret = T_Float_IsConstraintValid((&(pVal->sens_t1)), pErrCode);
                            if (ret) {
                                ret = T_Float_IsConstraintValid((&(pVal->off_t1)), pErrCode);
                                if (ret) {
                                    ret = T_Float_IsConstraintValid((&(pVal->tcs)), pErrCode);
                                    if (ret) {
                                        ret = T_Float_IsConstraintValid((&(pVal->tco)), pErrCode);
                                        if (ret) {
                                            ret = T_Float_IsConstraintValid((&(pVal->tref)), pErrCode);
                                            if (ret) {
                                                ret = T_Float_IsConstraintValid((&(pVal->temp_sens)), pErrCode);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag PS_Calibration_Data_Encode(const PS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? PS_Calibration_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode c1 */
	    ret = T_UInt16_Encode((&(pVal->c1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode c2 */
	        ret = T_UInt16_Encode((&(pVal->c2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode c3 */
	            ret = T_UInt16_Encode((&(pVal->c3)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode c4 */
	                ret = T_UInt16_Encode((&(pVal->c4)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode c5 */
	                    ret = T_UInt16_Encode((&(pVal->c5)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode c6 */
	                        ret = T_UInt16_Encode((&(pVal->c6)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode sens_t1 */
	                            ret = T_Float_Encode((&(pVal->sens_t1)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode off_t1 */
	                                ret = T_Float_Encode((&(pVal->off_t1)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode tcs */
	                                    ret = T_Float_Encode((&(pVal->tcs)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode tco */
	                                        ret = T_Float_Encode((&(pVal->tco)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode tref */
	                                            ret = T_Float_Encode((&(pVal->tref)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode temp_sens */
	                                                ret = T_Float_Encode((&(pVal->temp_sens)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Calibration_Data_Decode(PS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode c1 */
	ret = T_UInt16_Decode((&(pVal->c1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode c2 */
	    ret = T_UInt16_Decode((&(pVal->c2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode c3 */
	        ret = T_UInt16_Decode((&(pVal->c3)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode c4 */
	            ret = T_UInt16_Decode((&(pVal->c4)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode c5 */
	                ret = T_UInt16_Decode((&(pVal->c5)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode c6 */
	                    ret = T_UInt16_Decode((&(pVal->c6)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode sens_t1 */
	                        ret = T_Float_Decode((&(pVal->sens_t1)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode off_t1 */
	                            ret = T_Float_Decode((&(pVal->off_t1)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode tcs */
	                                ret = T_Float_Decode((&(pVal->tcs)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode tco */
	                                    ret = T_Float_Decode((&(pVal->tco)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode tref */
	                                        ret = T_Float_Decode((&(pVal->tref)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode temp_sens */
	                                            ret = T_Float_Decode((&(pVal->temp_sens)), pBitStrm, pErrCode);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && PS_Calibration_Data_IsConstraintValid(pVal, pErrCode);
}

flag PS_Calibration_Data_ACN_Encode(const PS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? PS_Calibration_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode c1 */
	    ret = T_UInt16_ACN_Encode((&(pVal->c1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode c2 */
	        ret = T_UInt16_ACN_Encode((&(pVal->c2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode c3 */
	            ret = T_UInt16_ACN_Encode((&(pVal->c3)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode c4 */
	                ret = T_UInt16_ACN_Encode((&(pVal->c4)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode c5 */
	                    ret = T_UInt16_ACN_Encode((&(pVal->c5)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode c6 */
	                        ret = T_UInt16_ACN_Encode((&(pVal->c6)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode sens_t1 */
	                            ret = T_Float_ACN_Encode((&(pVal->sens_t1)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode off_t1 */
	                                ret = T_Float_ACN_Encode((&(pVal->off_t1)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode tcs */
	                                    ret = T_Float_ACN_Encode((&(pVal->tcs)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode tco */
	                                        ret = T_Float_ACN_Encode((&(pVal->tco)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode tref */
	                                            ret = T_Float_ACN_Encode((&(pVal->tref)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode temp_sens */
	                                                ret = T_Float_ACN_Encode((&(pVal->temp_sens)), pBitStrm, pErrCode, FALSE);
	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Calibration_Data_ACN_Decode(PS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode c1 */
	ret = T_UInt16_ACN_Decode((&(pVal->c1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode c2 */
	    ret = T_UInt16_ACN_Decode((&(pVal->c2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode c3 */
	        ret = T_UInt16_ACN_Decode((&(pVal->c3)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode c4 */
	            ret = T_UInt16_ACN_Decode((&(pVal->c4)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode c5 */
	                ret = T_UInt16_ACN_Decode((&(pVal->c5)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode c6 */
	                    ret = T_UInt16_ACN_Decode((&(pVal->c6)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode sens_t1 */
	                        ret = T_Float_ACN_Decode((&(pVal->sens_t1)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode off_t1 */
	                            ret = T_Float_ACN_Decode((&(pVal->off_t1)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode tcs */
	                                ret = T_Float_ACN_Decode((&(pVal->tcs)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode tco */
	                                    ret = T_Float_ACN_Decode((&(pVal->tco)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode tref */
	                                        ret = T_Float_ACN_Decode((&(pVal->tref)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode temp_sens */
	                                            ret = T_Float_ACN_Decode((&(pVal->temp_sens)), pBitStrm, pErrCode);
	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && PS_Calibration_Data_IsConstraintValid(pVal, pErrCode);
}



flag T_Double_Equal(const T_Double* pVal1, const T_Double* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Double_Initialize(T_Double* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.00000000000000000000E+000;
}

flag T_Double_IsConstraintValid(const T_Double* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1.69999999999999990000E+308 <= (*(pVal))) && ((*(pVal)) <= 1.69999999999999990000E+308));
    *pErrCode = ret ? 0 :  ERR_T_DOUBLE; 

	return ret;
}

flag T_Double_Encode(const T_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Double_Decode(T_Double* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_DOUBLE;

	return ret  && T_Double_IsConstraintValid(pVal, pErrCode);
}

flag T_Double_ACN_Encode(const T_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Double_ACN_Decode(T_Double* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_DOUBLE;

    return ret && T_Double_IsConstraintValid(pVal, pErrCode);
}



flag GPS_PVT_mode_Equal(const GPS_PVT_mode* pVal1, const GPS_PVT_mode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag GPS_PVT_Equal(const GPS_PVT* pVal1, const GPS_PVT* pVal2)
{
	flag ret=TRUE;

    ret = GPS_PVT_mode_Equal((&(pVal1->mode)), (&(pVal2->mode)));

    if (ret) {
        ret = (pVal1->date_and_time == pVal2->date_and_time);

        if (ret) {
            ret = (pVal1->ept == pVal2->ept);

            if (ret) {
                ret = (pVal1->latitude == pVal2->latitude);

                if (ret) {
                    ret = (pVal1->epy == pVal2->epy);

                    if (ret) {
                        ret = (pVal1->longitude == pVal2->longitude);

                        if (ret) {
                            ret = (pVal1->epx == pVal2->epx);

                            if (ret) {
                                ret = (pVal1->altitude == pVal2->altitude);

                                if (ret) {
                                    ret = (pVal1->epv == pVal2->epv);

                                    if (ret) {
                                        ret = (pVal1->course == pVal2->course);

                                        if (ret) {
                                            ret = (pVal1->epd == pVal2->epd);

                                            if (ret) {
                                                ret = (pVal1->speed == pVal2->speed);

                                                if (ret) {
                                                    ret = (pVal1->eps == pVal2->eps);

                                                    if (ret) {
                                                        ret = (pVal1->climb == pVal2->climb);

                                                        if (ret) {
                                                            ret = (pVal1->epc == pVal2->epc);

                                                        }

                                                    }

                                                }

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void GPS_PVT_mode_Initialize(GPS_PVT_mode* pVal)
{
	(void)pVal;


	(*(pVal)) = not_seen;
}
void GPS_PVT_Initialize(GPS_PVT* pVal)
{
	(void)pVal;



	/*set mode */
	GPS_PVT_mode_Initialize((&(pVal->mode)));
	/*set date_and_time */
	T_Double_Initialize((&(pVal->date_and_time)));
	/*set ept */
	T_Double_Initialize((&(pVal->ept)));
	/*set latitude */
	T_Double_Initialize((&(pVal->latitude)));
	/*set epy */
	T_Double_Initialize((&(pVal->epy)));
	/*set longitude */
	T_Double_Initialize((&(pVal->longitude)));
	/*set epx */
	T_Double_Initialize((&(pVal->epx)));
	/*set altitude */
	T_Double_Initialize((&(pVal->altitude)));
	/*set epv */
	T_Double_Initialize((&(pVal->epv)));
	/*set course */
	T_Double_Initialize((&(pVal->course)));
	/*set epd */
	T_Double_Initialize((&(pVal->epd)));
	/*set speed */
	T_Double_Initialize((&(pVal->speed)));
	/*set eps */
	T_Double_Initialize((&(pVal->eps)));
	/*set climb */
	T_Double_Initialize((&(pVal->climb)));
	/*set epc */
	T_Double_Initialize((&(pVal->epc)));
}

flag GPS_PVT_IsConstraintValid(const GPS_PVT* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (((((((pVal->mode == not_seen)) || ((pVal->mode == no_fix)))) || ((pVal->mode == two_dims)))) || ((pVal->mode == three_dims)));
    *pErrCode = ret ? 0 :  ERR_GPS_PVT_MODE; 
    if (ret) {
        ret = T_Double_IsConstraintValid((&(pVal->date_and_time)), pErrCode);
        if (ret) {
            ret = T_Double_IsConstraintValid((&(pVal->ept)), pErrCode);
            if (ret) {
                ret = T_Double_IsConstraintValid((&(pVal->latitude)), pErrCode);
                if (ret) {
                    ret = T_Double_IsConstraintValid((&(pVal->epy)), pErrCode);
                    if (ret) {
                        ret = T_Double_IsConstraintValid((&(pVal->longitude)), pErrCode);
                        if (ret) {
                            ret = T_Double_IsConstraintValid((&(pVal->epx)), pErrCode);
                            if (ret) {
                                ret = T_Double_IsConstraintValid((&(pVal->altitude)), pErrCode);
                                if (ret) {
                                    ret = T_Double_IsConstraintValid((&(pVal->epv)), pErrCode);
                                    if (ret) {
                                        ret = T_Double_IsConstraintValid((&(pVal->course)), pErrCode);
                                        if (ret) {
                                            ret = T_Double_IsConstraintValid((&(pVal->epd)), pErrCode);
                                            if (ret) {
                                                ret = T_Double_IsConstraintValid((&(pVal->speed)), pErrCode);
                                                if (ret) {
                                                    ret = T_Double_IsConstraintValid((&(pVal->eps)), pErrCode);
                                                    if (ret) {
                                                        ret = T_Double_IsConstraintValid((&(pVal->climb)), pErrCode);
                                                        if (ret) {
                                                            ret = T_Double_IsConstraintValid((&(pVal->epc)), pErrCode);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag GPS_PVT_Encode(const GPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? GPS_PVT_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mode */
	    switch(pVal->mode) 
	    {
	        case not_seen:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case no_fix:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case two_dims:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case three_dims:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_GPS_PVT_MODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	        /*Encode date_and_time */
	        ret = T_Double_Encode((&(pVal->date_and_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode ept */
	            ret = T_Double_Encode((&(pVal->ept)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode latitude */
	                ret = T_Double_Encode((&(pVal->latitude)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode epy */
	                    ret = T_Double_Encode((&(pVal->epy)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode longitude */
	                        ret = T_Double_Encode((&(pVal->longitude)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode epx */
	                            ret = T_Double_Encode((&(pVal->epx)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode altitude */
	                                ret = T_Double_Encode((&(pVal->altitude)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode epv */
	                                    ret = T_Double_Encode((&(pVal->epv)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode course */
	                                        ret = T_Double_Encode((&(pVal->course)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode epd */
	                                            ret = T_Double_Encode((&(pVal->epd)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode speed */
	                                                ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode eps */
	                                                    ret = T_Double_Encode((&(pVal->eps)), pBitStrm, pErrCode, FALSE);
	                                                    if (ret) {
	                                                        /*Encode climb */
	                                                        ret = T_Double_Encode((&(pVal->climb)), pBitStrm, pErrCode, FALSE);
	                                                        if (ret) {
	                                                            /*Encode epc */
	                                                            ret = T_Double_Encode((&(pVal->epc)), pBitStrm, pErrCode, FALSE);
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GPS_PVT_Decode(GPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mode */
	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_GPS_PVT_MODE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                pVal->mode = not_seen;
	                break;
	            case 1: 
	                pVal->mode = no_fix;
	                break;
	            case 2: 
	                pVal->mode = two_dims;
	                break;
	            case 3: 
	                pVal->mode = three_dims;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_GPS_PVT_MODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        pVal->mode = not_seen;             /*COVERAGE_IGNORE*/
	    }
	}
	if (ret) {
	    /*Decode date_and_time */
	    ret = T_Double_Decode((&(pVal->date_and_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode ept */
	        ret = T_Double_Decode((&(pVal->ept)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode latitude */
	            ret = T_Double_Decode((&(pVal->latitude)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode epy */
	                ret = T_Double_Decode((&(pVal->epy)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode longitude */
	                    ret = T_Double_Decode((&(pVal->longitude)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode epx */
	                        ret = T_Double_Decode((&(pVal->epx)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode altitude */
	                            ret = T_Double_Decode((&(pVal->altitude)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode epv */
	                                ret = T_Double_Decode((&(pVal->epv)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode course */
	                                    ret = T_Double_Decode((&(pVal->course)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode epd */
	                                        ret = T_Double_Decode((&(pVal->epd)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode speed */
	                                            ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode eps */
	                                                ret = T_Double_Decode((&(pVal->eps)), pBitStrm, pErrCode);
	                                                if (ret) {
	                                                    /*Decode climb */
	                                                    ret = T_Double_Decode((&(pVal->climb)), pBitStrm, pErrCode);
	                                                    if (ret) {
	                                                        /*Decode epc */
	                                                        ret = T_Double_Decode((&(pVal->epc)), pBitStrm, pErrCode);
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && GPS_PVT_IsConstraintValid(pVal, pErrCode);
}

flag GPS_PVT_ACN_Encode(const GPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? GPS_PVT_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mode */
	    switch(pVal->mode) { 
	        case not_seen:
	            uIntVal = 0;
	            break;
	        case no_fix:
	            uIntVal = 1;
	            break;
	        case two_dims:
	            uIntVal = 2;
	            break;
	        case three_dims:
	            uIntVal = 3;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_GPS_PVT_MODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 3);
	    }
	    if (ret) {
	        /*Encode date_and_time */
	        ret = T_Double_ACN_Encode((&(pVal->date_and_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode ept */
	            ret = T_Double_ACN_Encode((&(pVal->ept)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode latitude */
	                ret = T_Double_ACN_Encode((&(pVal->latitude)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode epy */
	                    ret = T_Double_ACN_Encode((&(pVal->epy)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode longitude */
	                        ret = T_Double_ACN_Encode((&(pVal->longitude)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode epx */
	                            ret = T_Double_ACN_Encode((&(pVal->epx)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode altitude */
	                                ret = T_Double_ACN_Encode((&(pVal->altitude)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode epv */
	                                    ret = T_Double_ACN_Encode((&(pVal->epv)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode course */
	                                        ret = T_Double_ACN_Encode((&(pVal->course)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode epd */
	                                            ret = T_Double_ACN_Encode((&(pVal->epd)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode speed */
	                                                ret = T_Double_ACN_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode eps */
	                                                    ret = T_Double_ACN_Encode((&(pVal->eps)), pBitStrm, pErrCode, FALSE);
	                                                    if (ret) {
	                                                        /*Encode climb */
	                                                        ret = T_Double_ACN_Encode((&(pVal->climb)), pBitStrm, pErrCode, FALSE);
	                                                        if (ret) {
	                                                            /*Encode epc */
	                                                            ret = T_Double_ACN_Encode((&(pVal->epc)), pBitStrm, pErrCode, FALSE);
	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GPS_PVT_ACN_Decode(GPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	/*Decode mode */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_GPS_PVT_MODE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            pVal->mode = not_seen;
	            break;
	        case 1:
	            pVal->mode = no_fix;
	            break;
	        case 2:
	            pVal->mode = two_dims;
	            break;
	        case 3:
	            pVal->mode = three_dims;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_GPS_PVT_MODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/
	if (ret) {
	    /*Decode date_and_time */
	    ret = T_Double_ACN_Decode((&(pVal->date_and_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode ept */
	        ret = T_Double_ACN_Decode((&(pVal->ept)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode latitude */
	            ret = T_Double_ACN_Decode((&(pVal->latitude)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode epy */
	                ret = T_Double_ACN_Decode((&(pVal->epy)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode longitude */
	                    ret = T_Double_ACN_Decode((&(pVal->longitude)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode epx */
	                        ret = T_Double_ACN_Decode((&(pVal->epx)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode altitude */
	                            ret = T_Double_ACN_Decode((&(pVal->altitude)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode epv */
	                                ret = T_Double_ACN_Decode((&(pVal->epv)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode course */
	                                    ret = T_Double_ACN_Decode((&(pVal->course)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode epd */
	                                        ret = T_Double_ACN_Decode((&(pVal->epd)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode speed */
	                                            ret = T_Double_ACN_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode eps */
	                                                ret = T_Double_ACN_Decode((&(pVal->eps)), pBitStrm, pErrCode);
	                                                if (ret) {
	                                                    /*Decode climb */
	                                                    ret = T_Double_ACN_Decode((&(pVal->climb)), pBitStrm, pErrCode);
	                                                    if (ret) {
	                                                        /*Decode epc */
	                                                        ret = T_Double_ACN_Decode((&(pVal->epc)), pBitStrm, pErrCode);
	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && GPS_PVT_IsConstraintValid(pVal, pErrCode);
}



flag Content_Validity_Equal(const Content_Validity* pVal1, const Content_Validity* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void Content_Validity_Initialize(Content_Validity* pVal)
{
	(void)pVal;


	(*(pVal)) = valid;
}

flag Content_Validity_IsConstraintValid(const Content_Validity* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == valid)) || (((*(pVal)) == invalid)));
    *pErrCode = ret ? 0 :  ERR_CONTENT_VALIDITY; 

	return ret;
}

flag Content_Validity_Encode(const Content_Validity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? Content_Validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case valid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case invalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CONTENT_VALIDITY; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Content_Validity_Decode(Content_Validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CONTENT_VALIDITY;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = valid;
	                break;
	            case 1: 
	                (*(pVal)) = invalid;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CONTENT_VALIDITY;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = valid;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Content_Validity_IsConstraintValid(pVal, pErrCode);
}

flag Content_Validity_ACN_Encode(const Content_Validity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? Content_Validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case valid:
	            uIntVal = 0;
	            break;
	        case invalid:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CONTENT_VALIDITY;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Content_Validity_ACN_Decode(Content_Validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CONTENT_VALIDITY;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = valid;
	            break;
	        case 1:
	            (*(pVal)) = invalid;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CONTENT_VALIDITY;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && Content_Validity_IsConstraintValid(pVal, pErrCode);
}



flag IMU_All_Data_Equal(const IMU_All_Data* pVal1, const IMU_All_Data* pVal2)
{
	flag ret=TRUE;

    ret = MGT_Raw_Data_Equal((&(pVal1->mgt_raw)), (&(pVal2->mgt_raw)));

    if (ret) {
        ret = MGT_MilliGauss_Data_Equal((&(pVal1->mgt_mgauss)), (&(pVal2->mgt_mgauss)));

        if (ret) {
            ret = ACC_Raw_Data_Equal((&(pVal1->accel_raw)), (&(pVal2->accel_raw)));

            if (ret) {
                ret = ACC_MilliG_Data_Equal((&(pVal1->accel_mg)), (&(pVal2->accel_mg)));

                if (ret) {
                    ret = GYRO_Raw_Data_Equal((&(pVal1->gyro_raw)), (&(pVal2->gyro_raw)));

                    if (ret) {
                        ret = GYRO_MilliDPS_Data_Equal((&(pVal1->gyro_mdps)), (&(pVal2->gyro_mdps)));

                        if (ret) {
                            ret = (pVal1->mgt_valid == pVal2->mgt_valid);

                            if (ret) {
                                ret = (pVal1->acc_valid == pVal2->acc_valid);

                                if (ret) {
                                    ret = (pVal1->gyro_valid == pVal2->gyro_valid);

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void IMU_All_Data_Initialize(IMU_All_Data* pVal)
{
	(void)pVal;



	/*set mgt_raw */
	MGT_Raw_Data_Initialize((&(pVal->mgt_raw)));
	/*set mgt_mgauss */
	MGT_MilliGauss_Data_Initialize((&(pVal->mgt_mgauss)));
	/*set accel_raw */
	ACC_Raw_Data_Initialize((&(pVal->accel_raw)));
	/*set accel_mg */
	ACC_MilliG_Data_Initialize((&(pVal->accel_mg)));
	/*set gyro_raw */
	GYRO_Raw_Data_Initialize((&(pVal->gyro_raw)));
	/*set gyro_mdps */
	GYRO_MilliDPS_Data_Initialize((&(pVal->gyro_mdps)));
	/*set mgt_valid */
	Content_Validity_Initialize((&(pVal->mgt_valid)));
	/*set acc_valid */
	Content_Validity_Initialize((&(pVal->acc_valid)));
	/*set gyro_valid */
	Content_Validity_Initialize((&(pVal->gyro_valid)));
}

flag IMU_All_Data_IsConstraintValid(const IMU_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = MGT_Raw_Data_IsConstraintValid((&(pVal->mgt_raw)), pErrCode);
    if (ret) {
        ret = MGT_MilliGauss_Data_IsConstraintValid((&(pVal->mgt_mgauss)), pErrCode);
        if (ret) {
            ret = ACC_Raw_Data_IsConstraintValid((&(pVal->accel_raw)), pErrCode);
            if (ret) {
                ret = ACC_MilliG_Data_IsConstraintValid((&(pVal->accel_mg)), pErrCode);
                if (ret) {
                    ret = GYRO_Raw_Data_IsConstraintValid((&(pVal->gyro_raw)), pErrCode);
                    if (ret) {
                        ret = GYRO_MilliDPS_Data_IsConstraintValid((&(pVal->gyro_mdps)), pErrCode);
                        if (ret) {
                            ret = Content_Validity_IsConstraintValid((&(pVal->mgt_valid)), pErrCode);
                            if (ret) {
                                ret = Content_Validity_IsConstraintValid((&(pVal->acc_valid)), pErrCode);
                                if (ret) {
                                    ret = Content_Validity_IsConstraintValid((&(pVal->gyro_valid)), pErrCode);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag IMU_All_Data_Encode(const IMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? IMU_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mgt_raw */
	    ret = MGT_Raw_Data_Encode((&(pVal->mgt_raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode mgt_mgauss */
	        ret = MGT_MilliGauss_Data_Encode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode accel_raw */
	            ret = ACC_Raw_Data_Encode((&(pVal->accel_raw)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode accel_mg */
	                ret = ACC_MilliG_Data_Encode((&(pVal->accel_mg)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gyro_raw */
	                    ret = GYRO_Raw_Data_Encode((&(pVal->gyro_raw)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode gyro_mdps */
	                        ret = GYRO_MilliDPS_Data_Encode((&(pVal->gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode mgt_valid */
	                            ret = Content_Validity_Encode((&(pVal->mgt_valid)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode acc_valid */
	                                ret = Content_Validity_Encode((&(pVal->acc_valid)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode gyro_valid */
	                                    ret = Content_Validity_Encode((&(pVal->gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag IMU_All_Data_Decode(IMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mgt_raw */
	ret = MGT_Raw_Data_Decode((&(pVal->mgt_raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode mgt_mgauss */
	    ret = MGT_MilliGauss_Data_Decode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode accel_raw */
	        ret = ACC_Raw_Data_Decode((&(pVal->accel_raw)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode accel_mg */
	            ret = ACC_MilliG_Data_Decode((&(pVal->accel_mg)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gyro_raw */
	                ret = GYRO_Raw_Data_Decode((&(pVal->gyro_raw)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode gyro_mdps */
	                    ret = GYRO_MilliDPS_Data_Decode((&(pVal->gyro_mdps)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode mgt_valid */
	                        ret = Content_Validity_Decode((&(pVal->mgt_valid)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode acc_valid */
	                            ret = Content_Validity_Decode((&(pVal->acc_valid)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode gyro_valid */
	                                ret = Content_Validity_Decode((&(pVal->gyro_valid)), pBitStrm, pErrCode);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && IMU_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag IMU_All_Data_ACN_Encode(const IMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? IMU_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mgt_raw */
	    ret = MGT_Raw_Data_ACN_Encode((&(pVal->mgt_raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode mgt_mgauss */
	        ret = MGT_MilliGauss_Data_ACN_Encode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode accel_raw */
	            ret = ACC_Raw_Data_ACN_Encode((&(pVal->accel_raw)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode accel_mg */
	                ret = ACC_MilliG_Data_ACN_Encode((&(pVal->accel_mg)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gyro_raw */
	                    ret = GYRO_Raw_Data_ACN_Encode((&(pVal->gyro_raw)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode gyro_mdps */
	                        ret = GYRO_MilliDPS_Data_ACN_Encode((&(pVal->gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode mgt_valid */
	                            ret = Content_Validity_ACN_Encode((&(pVal->mgt_valid)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode acc_valid */
	                                ret = Content_Validity_ACN_Encode((&(pVal->acc_valid)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode gyro_valid */
	                                    ret = Content_Validity_ACN_Encode((&(pVal->gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag IMU_All_Data_ACN_Decode(IMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mgt_raw */
	ret = MGT_Raw_Data_ACN_Decode((&(pVal->mgt_raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode mgt_mgauss */
	    ret = MGT_MilliGauss_Data_ACN_Decode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode accel_raw */
	        ret = ACC_Raw_Data_ACN_Decode((&(pVal->accel_raw)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode accel_mg */
	            ret = ACC_MilliG_Data_ACN_Decode((&(pVal->accel_mg)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gyro_raw */
	                ret = GYRO_Raw_Data_ACN_Decode((&(pVal->gyro_raw)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode gyro_mdps */
	                    ret = GYRO_MilliDPS_Data_ACN_Decode((&(pVal->gyro_mdps)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode mgt_valid */
	                        ret = Content_Validity_ACN_Decode((&(pVal->mgt_valid)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode acc_valid */
	                            ret = Content_Validity_ACN_Decode((&(pVal->acc_valid)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode gyro_valid */
	                                ret = Content_Validity_ACN_Decode((&(pVal->gyro_valid)), pBitStrm, pErrCode);
	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && IMU_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag TC74s_All_Data_elem_Equal(const TC74s_All_Data_elem* pVal1, const TC74s_All_Data_elem* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->temperature == pVal2->temperature);

    if (ret) {
        ret = (pVal1->exist.validity == pVal2->exist.validity);
        if (ret && pVal1->exist.validity) {
        	ret = (pVal1->validity == pVal2->validity);
        }

    }

	return ret;

}

flag TC74s_All_Data_Equal(const TC74s_All_Data* pVal1, const TC74s_All_Data* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = TC74s_All_Data_elem_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

void TC74s_All_Data_elem_Initialize(TC74s_All_Data_elem* pVal)
{
	(void)pVal;



	/*set temperature */
	T_Float_Initialize((&(pVal->temperature)));
	/*set validity */
	pVal->exist.validity = 1;
	pVal->validity = invalid;
}
void TC74s_All_Data_Initialize(TC74s_All_Data* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 5) {
	    TC74s_All_Data_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag TC74s_All_Data_IsConstraintValid(const TC74s_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = T_Float_IsConstraintValid((&(pVal->arr[i1].temperature)), pErrCode);
    	if (ret) {
    	    if (pVal->arr[i1].exist.validity) {
    	    	ret = Content_Validity_IsConstraintValid((&(pVal->arr[i1].validity)), pErrCode);
    	    }
    	}
    }

	return ret;
}

flag TC74s_All_Data_Encode(const TC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? TC74s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	BitStream_AppendBit(pBitStrm,pVal->arr[i1].exist.validity);
	    	if (ret) {
	    	    /*Encode temperature */
	    	    ret = T_Float_Encode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode validity */
	    	        if (pVal->arr[i1].exist.validity) {
	    	        	ret = Content_Validity_Encode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode, FALSE);
	    	        }
	    	    }
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC74s_All_Data_Decode(TC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	flag presenceBit;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		ret = BitStream_ReadBit(pBitStrm, &presenceBit);
		pVal->arr[i1].exist.validity = presenceBit == 0 ? 0 : 1;
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_TC74S_ALL_DATA_ELM;
		if (ret) {
		    /*Decode temperature */
		    ret = T_Float_Decode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode);
		    if (ret) {
		        /*Decode validity */
		        if (pVal->arr[i1].exist.validity) {
		        	ret = Content_Validity_Decode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode);
		        } else {
		            pVal->arr[i1].validity = invalid;
		        }
		    }
		}
	}

	return ret  && TC74s_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag TC74s_All_Data_ACN_Encode(const TC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? TC74s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	BitStream_AppendBit(pBitStrm,pVal->arr[i1].exist.validity);
	    	if (ret) {
	    	    /*Encode temperature */
	    	    ret = T_Float_ACN_Encode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode validity */
	    	        if (pVal->arr[i1].exist.validity) {
	    	        	ret = Content_Validity_ACN_Encode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode, FALSE);
	    	        }
	    	    }

	    	}

	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC74s_All_Data_ACN_Decode(TC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	flag presenceBit;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		ret = BitStream_ReadBit(pBitStrm, &presenceBit);
		pVal->arr[i1].exist.validity = presenceBit == 0 ? 0 : 1;
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_TC74S_ALL_DATA_ELM;
		if (ret) {
		    /*Decode temperature */
		    ret = T_Float_ACN_Decode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode);
		    if (ret) {
		        /*Decode validity */
		        if (pVal->arr[i1].exist.validity) {
		        	ret = Content_Validity_ACN_Decode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode);
		        } else {
		            pVal->arr[i1].validity = invalid;
		        }
		    }

		}

	}

    return ret && TC74s_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag PT1000s_All_Data_validity_Equal(const PT1000s_All_Data_validity* pVal1, const PT1000s_All_Data_validity* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 6; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag PT1000s_All_Data_Equal(const PT1000s_All_Data* pVal1, const PT1000s_All_Data* pVal2)
{
	flag ret=TRUE;

    ret = PT1000s_Raw_Data_Equal((&(pVal1->raw)), (&(pVal2->raw)));

    if (ret) {
        ret = PT1000s_Celsius_Data_Equal((&(pVal1->celsius)), (&(pVal2->celsius)));

        if (ret) {
            ret = PT1000s_All_Data_validity_Equal((&(pVal1->validity)), (&(pVal2->validity)));

        }

    }

	return ret;

}

void PT1000s_All_Data_validity_Initialize(PT1000s_All_Data_validity* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 6) {
	    Content_Validity_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void PT1000s_All_Data_Initialize(PT1000s_All_Data* pVal)
{
	(void)pVal;



	/*set raw */
	PT1000s_Raw_Data_Initialize((&(pVal->raw)));
	/*set celsius */
	PT1000s_Celsius_Data_Initialize((&(pVal->celsius)));
	/*set validity */
	PT1000s_All_Data_validity_Initialize((&(pVal->validity)));
}

flag PT1000s_All_Data_IsConstraintValid(const PT1000s_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = PT1000s_Raw_Data_IsConstraintValid((&(pVal->raw)), pErrCode);
    if (ret) {
        ret = PT1000s_Celsius_Data_IsConstraintValid((&(pVal->celsius)), pErrCode);
        if (ret) {
            for(i1 = 0; ret && i1 < 6; i1++) 
            {
            	ret = Content_Validity_IsConstraintValid((&(pVal->validity.arr[i1])), pErrCode);
            }
        }
    }

	return ret;
}

flag PT1000s_All_Data_Encode(const PT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? PT1000s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode raw */
	    ret = PT1000s_Raw_Data_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode celsius */
	        ret = PT1000s_Celsius_Data_Encode((&(pVal->celsius)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            	
	            for(i1=0; (i1 < (int)6) && ret; i1++) 
	            {
	            	ret = Content_Validity_Encode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_All_Data_Decode(PT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode raw */
	ret = PT1000s_Raw_Data_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode celsius */
	    ret = PT1000s_Celsius_Data_Decode((&(pVal->celsius)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        	
	        for(i1=0; (i1 < (int)6) && ret; i1++) 
	        {
	        	ret = Content_Validity_Decode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && PT1000s_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag PT1000s_All_Data_ACN_Encode(const PT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? PT1000s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode raw */
	    ret = PT1000s_Raw_Data_ACN_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode celsius */
	        ret = PT1000s_Celsius_Data_ACN_Encode((&(pVal->celsius)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            	
	            for(i1=0; (i1 < (int)6) && ret; i1++) 
	            {
	            	ret = Content_Validity_ACN_Encode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_All_Data_ACN_Decode(PT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode raw */
	ret = PT1000s_Raw_Data_ACN_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode celsius */
	    ret = PT1000s_Celsius_Data_ACN_Decode((&(pVal->celsius)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        	
	        for(i1=0; (i1 < (int)6) && ret; i1++) 
	        {
	        	ret = Content_Validity_ACN_Decode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode);
	        }
	    }

	}


    return ret && PT1000s_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag Heater_Data_Equal(const Heater_Data* pVal1, const Heater_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->power_watts == pVal2->power_watts);

    if (ret) {
        ret = (pVal1->exist.validity == pVal2->exist.validity);
        if (ret && pVal1->exist.validity) {
        	ret = (pVal1->validity == pVal2->validity);
        }

    }

	return ret;

}

void Heater_Data_Initialize(Heater_Data* pVal)
{
	(void)pVal;



	/*set power_watts */
	T_Float_Initialize((&(pVal->power_watts)));
	/*set validity */
	pVal->exist.validity = 1;
	pVal->validity = invalid;
}

flag Heater_Data_IsConstraintValid(const Heater_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Float_IsConstraintValid((&(pVal->power_watts)), pErrCode);
    if (ret) {
        if (pVal->exist.validity) {
        	ret = Content_Validity_IsConstraintValid((&(pVal->validity)), pErrCode);
        }
    }

	return ret;
}

flag Heater_Data_Encode(const Heater_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? Heater_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.validity);
	    if (ret) {
	        /*Encode power_watts */
	        ret = T_Float_Encode((&(pVal->power_watts)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            if (pVal->exist.validity) {
	            	ret = Content_Validity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Heater_Data_Decode(Heater_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.validity = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_HEATER_DATA;
	if (ret) {
	    /*Decode power_watts */
	    ret = T_Float_Decode((&(pVal->power_watts)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        if (pVal->exist.validity) {
	        	ret = Content_Validity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	        } else {
	            pVal->validity = invalid;
	        }
	    }
	}

	return ret  && Heater_Data_IsConstraintValid(pVal, pErrCode);
}

flag Heater_Data_ACN_Encode(const Heater_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? Heater_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.validity);
	    if (ret) {
	        /*Encode power_watts */
	        ret = T_Float_ACN_Encode((&(pVal->power_watts)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            if (pVal->exist.validity) {
	            	ret = Content_Validity_ACN_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	            }
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Heater_Data_ACN_Decode(Heater_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.validity = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_HEATER_DATA;
	if (ret) {
	    /*Decode power_watts */
	    ret = T_Float_ACN_Decode((&(pVal->power_watts)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        if (pVal->exist.validity) {
	        	ret = Content_Validity_ACN_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	        } else {
	            pVal->validity = invalid;
	        }
	    }

	}


    return ret && Heater_Data_IsConstraintValid(pVal, pErrCode);
}



flag T_Int32_Equal(const T_Int32* pVal1, const T_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Int32_Initialize(T_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && T_Int32_IsConstraintValid(pVal, pErrCode);
}

flag T_Int32_ACN_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_ACN_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && T_Int32_IsConstraintValid(pVal, pErrCode);
}



flag TC74s_I2CBuses_Equal(const TC74s_I2CBuses* pVal1, const TC74s_I2CBuses* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void TC74s_I2CBuses_Initialize(TC74s_I2CBuses* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 5) {
	    T_Int32_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag TC74s_I2CBuses_IsConstraintValid(const TC74s_I2CBuses* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = T_Int32_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag TC74s_I2CBuses_Encode(const TC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? TC74s_I2CBuses_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	ret = T_Int32_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC74s_I2CBuses_Decode(TC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		ret = T_Int32_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && TC74s_I2CBuses_IsConstraintValid(pVal, pErrCode);
}

flag TC74s_I2CBuses_ACN_Encode(const TC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? TC74s_I2CBuses_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	ret = T_Int32_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC74s_I2CBuses_ACN_Decode(TC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		ret = T_Int32_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && TC74s_I2CBuses_IsConstraintValid(pVal, pErrCode);
}



flag PT1000s_Channels_Equal(const PT1000s_Channels* pVal1, const PT1000s_Channels* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 6; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void PT1000s_Channels_Initialize(PT1000s_Channels* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 6) {
	    T_Int32_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag PT1000s_Channels_IsConstraintValid(const PT1000s_Channels* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 6; i1++) 
    {
    	ret = T_Int32_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag PT1000s_Channels_Encode(const PT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? PT1000s_Channels_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)6) && ret; i1++) 
	    {
	    	ret = T_Int32_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Channels_Decode(PT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)6) && ret; i1++) 
	{
		ret = T_Int32_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && PT1000s_Channels_IsConstraintValid(pVal, pErrCode);
}

flag PT1000s_Channels_ACN_Encode(const PT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? PT1000s_Channels_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)6) && ret; i1++) 
	    {
	    	ret = T_Int32_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Channels_ACN_Decode(PT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)6) && ret; i1++) 
	{
		ret = T_Int32_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && PT1000s_Channels_IsConstraintValid(pVal, pErrCode);
}



flag PS_Processed_Data_Equal(const PS_Processed_Data* pVal1, const PS_Processed_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->pressure == pVal2->pressure);

    if (ret) {
        ret = (pVal1->temp == pVal2->temp);

    }

	return ret;

}

void PS_Processed_Data_Initialize(PS_Processed_Data* pVal)
{
	(void)pVal;



	/*set pressure */
	T_Int32_Initialize((&(pVal->pressure)));
	/*set temp */
	T_Int32_Initialize((&(pVal->temp)));
}

flag PS_Processed_Data_IsConstraintValid(const PS_Processed_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Int32_IsConstraintValid((&(pVal->pressure)), pErrCode);
    if (ret) {
        ret = T_Int32_IsConstraintValid((&(pVal->temp)), pErrCode);
    }

	return ret;
}

flag PS_Processed_Data_Encode(const PS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? PS_Processed_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure */
	    ret = T_Int32_Encode((&(pVal->pressure)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode temp */
	        ret = T_Int32_Encode((&(pVal->temp)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Processed_Data_Decode(PS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure */
	ret = T_Int32_Decode((&(pVal->pressure)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode temp */
	    ret = T_Int32_Decode((&(pVal->temp)), pBitStrm, pErrCode);
	}

	return ret  && PS_Processed_Data_IsConstraintValid(pVal, pErrCode);
}

flag PS_Processed_Data_ACN_Encode(const PS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? PS_Processed_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure */
	    ret = T_Int32_ACN_Encode((&(pVal->pressure)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode temp */
	        ret = T_Int32_ACN_Encode((&(pVal->temp)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Processed_Data_ACN_Decode(PS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure */
	ret = T_Int32_ACN_Decode((&(pVal->pressure)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode temp */
	    ret = T_Int32_ACN_Decode((&(pVal->temp)), pBitStrm, pErrCode);
	}


    return ret && PS_Processed_Data_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt32_Equal(const T_UInt32* pVal1, const T_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt32_Initialize(T_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && T_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt32_ACN_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_ACN_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && T_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag PS_Raw_Data_Equal(const PS_Raw_Data* pVal1, const PS_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->d1 == pVal2->d1);

    if (ret) {
        ret = (pVal1->d2 == pVal2->d2);

    }

	return ret;

}

void PS_Raw_Data_Initialize(PS_Raw_Data* pVal)
{
	(void)pVal;



	/*set d1 */
	T_UInt32_Initialize((&(pVal->d1)));
	/*set d2 */
	T_UInt32_Initialize((&(pVal->d2)));
}

flag PS_Raw_Data_IsConstraintValid(const PS_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt32_IsConstraintValid((&(pVal->d1)), pErrCode);
    if (ret) {
        ret = T_UInt32_IsConstraintValid((&(pVal->d2)), pErrCode);
    }

	return ret;
}

flag PS_Raw_Data_Encode(const PS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? PS_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode d1 */
	    ret = T_UInt32_Encode((&(pVal->d1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode d2 */
	        ret = T_UInt32_Encode((&(pVal->d2)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Raw_Data_Decode(PS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode d1 */
	ret = T_UInt32_Decode((&(pVal->d1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode d2 */
	    ret = T_UInt32_Decode((&(pVal->d2)), pBitStrm, pErrCode);
	}

	return ret  && PS_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag PS_Raw_Data_ACN_Encode(const PS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? PS_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode d1 */
	    ret = T_UInt32_ACN_Encode((&(pVal->d1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode d2 */
	        ret = T_UInt32_ACN_Encode((&(pVal->d2)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Raw_Data_ACN_Decode(PS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode d1 */
	ret = T_UInt32_ACN_Decode((&(pVal->d1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode d2 */
	    ret = T_UInt32_ACN_Decode((&(pVal->d2)), pBitStrm, pErrCode);
	}


    return ret && PS_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag PS_All_Data_Equal(const PS_All_Data* pVal1, const PS_All_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->exist.calib == pVal2->exist.calib);
    if (ret && pVal1->exist.calib) {
    	ret = PS_Calibration_Data_Equal((&(pVal1->calib)), (&(pVal2->calib)));
    }

    if (ret) {
        ret = PS_Raw_Data_Equal((&(pVal1->raw)), (&(pVal2->raw)));

        if (ret) {
            ret = PS_Processed_Data_Equal((&(pVal1->processed)), (&(pVal2->processed)));

            if (ret) {
                ret = (pVal1->exist.validity == pVal2->exist.validity);
                if (ret && pVal1->exist.validity) {
                	ret = (pVal1->validity == pVal2->validity);
                }

            }

        }

    }

	return ret;

}

void PS_All_Data_Initialize(PS_All_Data* pVal)
{
	(void)pVal;



	/*set calib */
	pVal->exist.calib = 1;
	PS_Calibration_Data_Initialize((&(pVal->calib)));
	/*set raw */
	PS_Raw_Data_Initialize((&(pVal->raw)));
	/*set processed */
	PS_Processed_Data_Initialize((&(pVal->processed)));
	/*set validity */
	pVal->exist.validity = 1;
	pVal->validity = invalid;
}

flag PS_All_Data_IsConstraintValid(const PS_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.calib) {
    	ret = PS_Calibration_Data_IsConstraintValid((&(pVal->calib)), pErrCode);
    }
    if (ret) {
        ret = PS_Raw_Data_IsConstraintValid((&(pVal->raw)), pErrCode);
        if (ret) {
            ret = PS_Processed_Data_IsConstraintValid((&(pVal->processed)), pErrCode);
            if (ret) {
                if (pVal->exist.validity) {
                	ret = Content_Validity_IsConstraintValid((&(pVal->validity)), pErrCode);
                }
            }
        }
    }

	return ret;
}

flag PS_All_Data_Encode(const PS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? PS_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.calib);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.validity);
	        if (ret) {
	            /*Encode calib */
	            if (pVal->exist.calib) {
	            	ret = PS_Calibration_Data_Encode((&(pVal->calib)), pBitStrm, pErrCode, FALSE);
	            }
	            if (ret) {
	                /*Encode raw */
	                ret = PS_Raw_Data_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode processed */
	                    ret = PS_Processed_Data_Encode((&(pVal->processed)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode validity */
	                        if (pVal->exist.validity) {
	                        	ret = Content_Validity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_All_Data_Decode(PS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.calib = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PS_ALL_DATA;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.validity = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PS_ALL_DATA;
	    if (ret) {
	        /*Decode calib */
	        if (pVal->exist.calib) {
	        	ret = PS_Calibration_Data_Decode((&(pVal->calib)), pBitStrm, pErrCode);
	        }
	        if (ret) {
	            /*Decode raw */
	            ret = PS_Raw_Data_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode processed */
	                ret = PS_Processed_Data_Decode((&(pVal->processed)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode validity */
	                    if (pVal->exist.validity) {
	                    	ret = Content_Validity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	                    } else {
	                        pVal->validity = invalid;
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && PS_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag PS_All_Data_ACN_Encode(const PS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? PS_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.calib);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.validity);
	        if (ret) {
	            /*Encode calib */
	            if (pVal->exist.calib) {
	            	ret = PS_Calibration_Data_ACN_Encode((&(pVal->calib)), pBitStrm, pErrCode, FALSE);
	            }
	            if (ret) {
	                /*Encode raw */
	                ret = PS_Raw_Data_ACN_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode processed */
	                    ret = PS_Processed_Data_ACN_Encode((&(pVal->processed)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode validity */
	                        if (pVal->exist.validity) {
	                        	ret = Content_Validity_ACN_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	                        }
	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_All_Data_ACN_Decode(PS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.calib = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PS_ALL_DATA;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.validity = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_PS_ALL_DATA;
	    if (ret) {
	        /*Decode calib */
	        if (pVal->exist.calib) {
	        	ret = PS_Calibration_Data_ACN_Decode((&(pVal->calib)), pBitStrm, pErrCode);
	        }
	        if (ret) {
	            /*Decode raw */
	            ret = PS_Raw_Data_ACN_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode processed */
	                ret = PS_Processed_Data_ACN_Decode((&(pVal->processed)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode validity */
	                    if (pVal->exist.validity) {
	                    	ret = Content_Validity_ACN_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	                    } else {
	                        pVal->validity = invalid;
	                    }
	                }

	            }

	        }

	    }

	}


    return ret && PS_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag OBSW_DP_Data_gps_Equal(const OBSW_DP_Data_gps* pVal1, const OBSW_DP_Data_gps* pVal2)
{
	flag ret=TRUE;

    ret = GPS_PVT_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->exist.validity == pVal2->exist.validity);
        if (ret && pVal1->exist.validity) {
        	ret = (pVal1->validity == pVal2->validity);
        }

    }

	return ret;

}

flag OBSW_DP_Data_imu_Equal(const OBSW_DP_Data_imu* pVal1, const OBSW_DP_Data_imu* pVal2)
{
	flag ret=TRUE;

    ret = IMU_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->timestamp == pVal2->timestamp);

    }

	return ret;

}

flag OBSW_DP_Data_tc74s_Equal(const OBSW_DP_Data_tc74s* pVal1, const OBSW_DP_Data_tc74s* pVal2)
{
	flag ret=TRUE;

    ret = TC74s_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->timestamp == pVal2->timestamp);

    }

	return ret;

}

flag OBSW_DP_Data_pt1000s_Equal(const OBSW_DP_Data_pt1000s* pVal1, const OBSW_DP_Data_pt1000s* pVal2)
{
	flag ret=TRUE;

    ret = PT1000s_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->timestamp == pVal2->timestamp);

    }

	return ret;

}

flag OBSW_DP_Data_ps1_Equal(const OBSW_DP_Data_ps1* pVal1, const OBSW_DP_Data_ps1* pVal2)
{
	flag ret=TRUE;

    ret = PS_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->timestamp == pVal2->timestamp);

    }

	return ret;

}

flag OBSW_DP_Data_ps2_Equal(const OBSW_DP_Data_ps2* pVal1, const OBSW_DP_Data_ps2* pVal2)
{
	flag ret=TRUE;

    ret = PS_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->timestamp == pVal2->timestamp);

    }

	return ret;

}

flag OBSW_DP_Data_heater1_Equal(const OBSW_DP_Data_heater1* pVal1, const OBSW_DP_Data_heater1* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->data == pVal2->data);

    if (ret) {
        ret = (pVal1->timestamp == pVal2->timestamp);

    }

	return ret;

}

flag OBSW_DP_Data_heater2_Equal(const OBSW_DP_Data_heater2* pVal1, const OBSW_DP_Data_heater2* pVal2)
{
	flag ret=TRUE;

    ret = Heater_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->timestamp == pVal2->timestamp);

    }

	return ret;

}

flag OBSW_DP_Data_anemometer_Equal(const OBSW_DP_Data_anemometer* pVal1, const OBSW_DP_Data_anemometer* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->data == pVal2->data);

    if (ret) {
        ret = (pVal1->timestamp == pVal2->timestamp);

    }

	return ret;

}

flag OBSW_DP_Data_Equal(const OBSW_DP_Data* pVal1, const OBSW_DP_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->exist.gps == pVal2->exist.gps);
    if (ret && pVal1->exist.gps) {
    	ret = OBSW_DP_Data_gps_Equal((&(pVal1->gps)), (&(pVal2->gps)));
    }

    if (ret) {
        ret = (pVal1->exist.imu == pVal2->exist.imu);
        if (ret && pVal1->exist.imu) {
        	ret = OBSW_DP_Data_imu_Equal((&(pVal1->imu)), (&(pVal2->imu)));
        }

        if (ret) {
            ret = (pVal1->exist.tc74s == pVal2->exist.tc74s);
            if (ret && pVal1->exist.tc74s) {
            	ret = OBSW_DP_Data_tc74s_Equal((&(pVal1->tc74s)), (&(pVal2->tc74s)));
            }

            if (ret) {
                ret = (pVal1->exist.pt1000s == pVal2->exist.pt1000s);
                if (ret && pVal1->exist.pt1000s) {
                	ret = OBSW_DP_Data_pt1000s_Equal((&(pVal1->pt1000s)), (&(pVal2->pt1000s)));
                }

                if (ret) {
                    ret = (pVal1->exist.ps1 == pVal2->exist.ps1);
                    if (ret && pVal1->exist.ps1) {
                    	ret = OBSW_DP_Data_ps1_Equal((&(pVal1->ps1)), (&(pVal2->ps1)));
                    }

                    if (ret) {
                        ret = (pVal1->exist.ps2 == pVal2->exist.ps2);
                        if (ret && pVal1->exist.ps2) {
                        	ret = OBSW_DP_Data_ps2_Equal((&(pVal1->ps2)), (&(pVal2->ps2)));
                        }

                        if (ret) {
                            ret = (pVal1->exist.heater1 == pVal2->exist.heater1);
                            if (ret && pVal1->exist.heater1) {
                            	ret = OBSW_DP_Data_heater1_Equal((&(pVal1->heater1)), (&(pVal2->heater1)));
                            }

                            if (ret) {
                                ret = (pVal1->exist.heater2 == pVal2->exist.heater2);
                                if (ret && pVal1->exist.heater2) {
                                	ret = OBSW_DP_Data_heater2_Equal((&(pVal1->heater2)), (&(pVal2->heater2)));
                                }

                                if (ret) {
                                    ret = (pVal1->exist.anemometer == pVal2->exist.anemometer);
                                    if (ret && pVal1->exist.anemometer) {
                                    	ret = OBSW_DP_Data_anemometer_Equal((&(pVal1->anemometer)), (&(pVal2->anemometer)));
                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void OBSW_DP_Data_gps_Initialize(OBSW_DP_Data_gps* pVal)
{
	(void)pVal;



	/*set data */
	GPS_PVT_Initialize((&(pVal->data)));
	/*set validity */
	pVal->exist.validity = 1;
	pVal->validity = invalid;
}
void OBSW_DP_Data_imu_Initialize(OBSW_DP_Data_imu* pVal)
{
	(void)pVal;



	/*set data */
	IMU_All_Data_Initialize((&(pVal->data)));
	/*set timestamp */
	T_Double_Initialize((&(pVal->timestamp)));
}
void OBSW_DP_Data_tc74s_Initialize(OBSW_DP_Data_tc74s* pVal)
{
	(void)pVal;



	/*set data */
	TC74s_All_Data_Initialize((&(pVal->data)));
	/*set timestamp */
	T_Double_Initialize((&(pVal->timestamp)));
}
void OBSW_DP_Data_pt1000s_Initialize(OBSW_DP_Data_pt1000s* pVal)
{
	(void)pVal;



	/*set data */
	PT1000s_All_Data_Initialize((&(pVal->data)));
	/*set timestamp */
	T_Double_Initialize((&(pVal->timestamp)));
}
void OBSW_DP_Data_ps1_Initialize(OBSW_DP_Data_ps1* pVal)
{
	(void)pVal;



	/*set data */
	PS_All_Data_Initialize((&(pVal->data)));
	/*set timestamp */
	T_Double_Initialize((&(pVal->timestamp)));
}
void OBSW_DP_Data_ps2_Initialize(OBSW_DP_Data_ps2* pVal)
{
	(void)pVal;



	/*set data */
	PS_All_Data_Initialize((&(pVal->data)));
	/*set timestamp */
	T_Double_Initialize((&(pVal->timestamp)));
}
void OBSW_DP_Data_heater1_Initialize(OBSW_DP_Data_heater1* pVal)
{
	(void)pVal;



	/*set data */
	T_Float_Initialize((&(pVal->data)));
	/*set timestamp */
	T_Double_Initialize((&(pVal->timestamp)));
}
void OBSW_DP_Data_heater2_Initialize(OBSW_DP_Data_heater2* pVal)
{
	(void)pVal;



	/*set data */
	Heater_Data_Initialize((&(pVal->data)));
	/*set timestamp */
	T_Double_Initialize((&(pVal->timestamp)));
}
void OBSW_DP_Data_anemometer_Initialize(OBSW_DP_Data_anemometer* pVal)
{
	(void)pVal;



	/*set data */
	T_UInt64_Initialize((&(pVal->data)));
	/*set timestamp */
	T_Double_Initialize((&(pVal->timestamp)));
}
void OBSW_DP_Data_Initialize(OBSW_DP_Data* pVal)
{
	(void)pVal;



	/*set gps */
	pVal->exist.gps = 1;
	OBSW_DP_Data_gps_Initialize((&(pVal->gps)));
	/*set imu */
	pVal->exist.imu = 1;
	OBSW_DP_Data_imu_Initialize((&(pVal->imu)));
	/*set tc74s */
	pVal->exist.tc74s = 1;
	OBSW_DP_Data_tc74s_Initialize((&(pVal->tc74s)));
	/*set pt1000s */
	pVal->exist.pt1000s = 1;
	OBSW_DP_Data_pt1000s_Initialize((&(pVal->pt1000s)));
	/*set ps1 */
	pVal->exist.ps1 = 1;
	OBSW_DP_Data_ps1_Initialize((&(pVal->ps1)));
	/*set ps2 */
	pVal->exist.ps2 = 1;
	OBSW_DP_Data_ps2_Initialize((&(pVal->ps2)));
	/*set heater1 */
	pVal->exist.heater1 = 1;
	OBSW_DP_Data_heater1_Initialize((&(pVal->heater1)));
	/*set heater2 */
	pVal->exist.heater2 = 1;
	OBSW_DP_Data_heater2_Initialize((&(pVal->heater2)));
	/*set anemometer */
	pVal->exist.anemometer = 1;
	OBSW_DP_Data_anemometer_Initialize((&(pVal->anemometer)));
}

flag OBSW_DP_Data_IsConstraintValid(const OBSW_DP_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.gps) {
    	ret = GPS_PVT_IsConstraintValid((&(pVal->gps.data)), pErrCode);
    	if (ret) {
    	    if (pVal->gps.exist.validity) {
    	    	ret = Content_Validity_IsConstraintValid((&(pVal->gps.validity)), pErrCode);
    	    }
    	}
    }
    if (ret) {
        if (pVal->exist.imu) {
        	ret = IMU_All_Data_IsConstraintValid((&(pVal->imu.data)), pErrCode);
        	if (ret) {
        	    ret = T_Double_IsConstraintValid((&(pVal->imu.timestamp)), pErrCode);
        	}
        }
        if (ret) {
            if (pVal->exist.tc74s) {
            	ret = TC74s_All_Data_IsConstraintValid((&(pVal->tc74s.data)), pErrCode);
            	if (ret) {
            	    ret = T_Double_IsConstraintValid((&(pVal->tc74s.timestamp)), pErrCode);
            	}
            }
            if (ret) {
                if (pVal->exist.pt1000s) {
                	ret = PT1000s_All_Data_IsConstraintValid((&(pVal->pt1000s.data)), pErrCode);
                	if (ret) {
                	    ret = T_Double_IsConstraintValid((&(pVal->pt1000s.timestamp)), pErrCode);
                	}
                }
                if (ret) {
                    if (pVal->exist.ps1) {
                    	ret = PS_All_Data_IsConstraintValid((&(pVal->ps1.data)), pErrCode);
                    	if (ret) {
                    	    ret = T_Double_IsConstraintValid((&(pVal->ps1.timestamp)), pErrCode);
                    	}
                    }
                    if (ret) {
                        if (pVal->exist.ps2) {
                        	ret = PS_All_Data_IsConstraintValid((&(pVal->ps2.data)), pErrCode);
                        	if (ret) {
                        	    ret = T_Double_IsConstraintValid((&(pVal->ps2.timestamp)), pErrCode);
                        	}
                        }
                        if (ret) {
                            if (pVal->exist.heater1) {
                            	ret = T_Float_IsConstraintValid((&(pVal->heater1.data)), pErrCode);
                            	if (ret) {
                            	    ret = T_Double_IsConstraintValid((&(pVal->heater1.timestamp)), pErrCode);
                            	}
                            }
                            if (ret) {
                                if (pVal->exist.heater2) {
                                	ret = Heater_Data_IsConstraintValid((&(pVal->heater2.data)), pErrCode);
                                	if (ret) {
                                	    ret = T_Double_IsConstraintValid((&(pVal->heater2.timestamp)), pErrCode);
                                	}
                                }
                                if (ret) {
                                    if (pVal->exist.anemometer) {
                                    	ret = T_UInt64_IsConstraintValid((&(pVal->anemometer.data)), pErrCode);
                                    	if (ret) {
                                    	    ret = T_Double_IsConstraintValid((&(pVal->anemometer.timestamp)), pErrCode);
                                    	}
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag OBSW_DP_Data_Encode(const OBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? OBSW_DP_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.gps);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.imu);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.tc74s);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.pt1000s);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.ps1);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.ps2);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.heater1);
	                            if (ret) {
	                                BitStream_AppendBit(pBitStrm,pVal->exist.heater2);
	                                if (ret) {
	                                    BitStream_AppendBit(pBitStrm,pVal->exist.anemometer);
	                                    if (ret) {
	                                        /*Encode gps */
	                                        if (pVal->exist.gps) {
	                                        	BitStream_AppendBit(pBitStrm,pVal->gps.exist.validity);
	                                        	if (ret) {
	                                        	    /*Encode data */
	                                        	    ret = GPS_PVT_Encode((&(pVal->gps.data)), pBitStrm, pErrCode, FALSE);
	                                        	    if (ret) {
	                                        	        /*Encode validity */
	                                        	        if (pVal->gps.exist.validity) {
	                                        	        	ret = Content_Validity_Encode((&(pVal->gps.validity)), pBitStrm, pErrCode, FALSE);
	                                        	        }
	                                        	    }
	                                        	}
	                                        }
	                                        if (ret) {
	                                            /*Encode imu */
	                                            if (pVal->exist.imu) {
	                                            	/*Encode data */
	                                            	ret = IMU_All_Data_Encode((&(pVal->imu.data)), pBitStrm, pErrCode, FALSE);
	                                            	if (ret) {
	                                            	    /*Encode timestamp */
	                                            	    ret = T_Double_Encode((&(pVal->imu.timestamp)), pBitStrm, pErrCode, FALSE);
	                                            	}
	                                            }
	                                            if (ret) {
	                                                /*Encode tc74s */
	                                                if (pVal->exist.tc74s) {
	                                                	/*Encode data */
	                                                	ret = TC74s_All_Data_Encode((&(pVal->tc74s.data)), pBitStrm, pErrCode, FALSE);
	                                                	if (ret) {
	                                                	    /*Encode timestamp */
	                                                	    ret = T_Double_Encode((&(pVal->tc74s.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                	}
	                                                }
	                                                if (ret) {
	                                                    /*Encode pt1000s */
	                                                    if (pVal->exist.pt1000s) {
	                                                    	/*Encode data */
	                                                    	ret = PT1000s_All_Data_Encode((&(pVal->pt1000s.data)), pBitStrm, pErrCode, FALSE);
	                                                    	if (ret) {
	                                                    	    /*Encode timestamp */
	                                                    	    ret = T_Double_Encode((&(pVal->pt1000s.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                    	}
	                                                    }
	                                                    if (ret) {
	                                                        /*Encode ps1 */
	                                                        if (pVal->exist.ps1) {
	                                                        	/*Encode data */
	                                                        	ret = PS_All_Data_Encode((&(pVal->ps1.data)), pBitStrm, pErrCode, FALSE);
	                                                        	if (ret) {
	                                                        	    /*Encode timestamp */
	                                                        	    ret = T_Double_Encode((&(pVal->ps1.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                        	}
	                                                        }
	                                                        if (ret) {
	                                                            /*Encode ps2 */
	                                                            if (pVal->exist.ps2) {
	                                                            	/*Encode data */
	                                                            	ret = PS_All_Data_Encode((&(pVal->ps2.data)), pBitStrm, pErrCode, FALSE);
	                                                            	if (ret) {
	                                                            	    /*Encode timestamp */
	                                                            	    ret = T_Double_Encode((&(pVal->ps2.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                            	}
	                                                            }
	                                                            if (ret) {
	                                                                /*Encode heater1 */
	                                                                if (pVal->exist.heater1) {
	                                                                	/*Encode data */
	                                                                	ret = T_Float_Encode((&(pVal->heater1.data)), pBitStrm, pErrCode, FALSE);
	                                                                	if (ret) {
	                                                                	    /*Encode timestamp */
	                                                                	    ret = T_Double_Encode((&(pVal->heater1.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                                	}
	                                                                }
	                                                                if (ret) {
	                                                                    /*Encode heater2 */
	                                                                    if (pVal->exist.heater2) {
	                                                                    	/*Encode data */
	                                                                    	ret = Heater_Data_Encode((&(pVal->heater2.data)), pBitStrm, pErrCode, FALSE);
	                                                                    	if (ret) {
	                                                                    	    /*Encode timestamp */
	                                                                    	    ret = T_Double_Encode((&(pVal->heater2.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                                    	}
	                                                                    }
	                                                                    if (ret) {
	                                                                        /*Encode anemometer */
	                                                                        if (pVal->exist.anemometer) {
	                                                                        	/*Encode data */
	                                                                        	ret = T_UInt64_Encode((&(pVal->anemometer.data)), pBitStrm, pErrCode, FALSE);
	                                                                        	if (ret) {
	                                                                        	    /*Encode timestamp */
	                                                                        	    ret = T_Double_Encode((&(pVal->anemometer.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                                        	}
	                                                                        }
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag OBSW_DP_Data_Decode(OBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.gps = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.imu = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.tc74s = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.pt1000s = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.ps1 = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.ps2 = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.heater1 = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                        if (ret) {
	                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                            pVal->exist.heater2 = presenceBit == 0 ? 0 : 1;
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                            if (ret) {
	                                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                pVal->exist.anemometer = presenceBit == 0 ? 0 : 1;
	                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                                if (ret) {
	                                    /*Decode gps */
	                                    if (pVal->exist.gps) {
	                                    	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                    	pVal->gps.exist.validity = presenceBit == 0 ? 0 : 1;
	                                    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA_GPS;
	                                    	if (ret) {
	                                    	    /*Decode data */
	                                    	    ret = GPS_PVT_Decode((&(pVal->gps.data)), pBitStrm, pErrCode);
	                                    	    if (ret) {
	                                    	        /*Decode validity */
	                                    	        if (pVal->gps.exist.validity) {
	                                    	        	ret = Content_Validity_Decode((&(pVal->gps.validity)), pBitStrm, pErrCode);
	                                    	        } else {
	                                    	            pVal->gps.validity = invalid;
	                                    	        }
	                                    	    }
	                                    	}
	                                    }
	                                    if (ret) {
	                                        /*Decode imu */
	                                        if (pVal->exist.imu) {
	                                        	/*Decode data */
	                                        	ret = IMU_All_Data_Decode((&(pVal->imu.data)), pBitStrm, pErrCode);
	                                        	if (ret) {
	                                        	    /*Decode timestamp */
	                                        	    ret = T_Double_Decode((&(pVal->imu.timestamp)), pBitStrm, pErrCode);
	                                        	}
	                                        }
	                                        if (ret) {
	                                            /*Decode tc74s */
	                                            if (pVal->exist.tc74s) {
	                                            	/*Decode data */
	                                            	ret = TC74s_All_Data_Decode((&(pVal->tc74s.data)), pBitStrm, pErrCode);
	                                            	if (ret) {
	                                            	    /*Decode timestamp */
	                                            	    ret = T_Double_Decode((&(pVal->tc74s.timestamp)), pBitStrm, pErrCode);
	                                            	}
	                                            }
	                                            if (ret) {
	                                                /*Decode pt1000s */
	                                                if (pVal->exist.pt1000s) {
	                                                	/*Decode data */
	                                                	ret = PT1000s_All_Data_Decode((&(pVal->pt1000s.data)), pBitStrm, pErrCode);
	                                                	if (ret) {
	                                                	    /*Decode timestamp */
	                                                	    ret = T_Double_Decode((&(pVal->pt1000s.timestamp)), pBitStrm, pErrCode);
	                                                	}
	                                                }
	                                                if (ret) {
	                                                    /*Decode ps1 */
	                                                    if (pVal->exist.ps1) {
	                                                    	/*Decode data */
	                                                    	ret = PS_All_Data_Decode((&(pVal->ps1.data)), pBitStrm, pErrCode);
	                                                    	if (ret) {
	                                                    	    /*Decode timestamp */
	                                                    	    ret = T_Double_Decode((&(pVal->ps1.timestamp)), pBitStrm, pErrCode);
	                                                    	}
	                                                    }
	                                                    if (ret) {
	                                                        /*Decode ps2 */
	                                                        if (pVal->exist.ps2) {
	                                                        	/*Decode data */
	                                                        	ret = PS_All_Data_Decode((&(pVal->ps2.data)), pBitStrm, pErrCode);
	                                                        	if (ret) {
	                                                        	    /*Decode timestamp */
	                                                        	    ret = T_Double_Decode((&(pVal->ps2.timestamp)), pBitStrm, pErrCode);
	                                                        	}
	                                                        }
	                                                        if (ret) {
	                                                            /*Decode heater1 */
	                                                            if (pVal->exist.heater1) {
	                                                            	/*Decode data */
	                                                            	ret = T_Float_Decode((&(pVal->heater1.data)), pBitStrm, pErrCode);
	                                                            	if (ret) {
	                                                            	    /*Decode timestamp */
	                                                            	    ret = T_Double_Decode((&(pVal->heater1.timestamp)), pBitStrm, pErrCode);
	                                                            	}
	                                                            }
	                                                            if (ret) {
	                                                                /*Decode heater2 */
	                                                                if (pVal->exist.heater2) {
	                                                                	/*Decode data */
	                                                                	ret = Heater_Data_Decode((&(pVal->heater2.data)), pBitStrm, pErrCode);
	                                                                	if (ret) {
	                                                                	    /*Decode timestamp */
	                                                                	    ret = T_Double_Decode((&(pVal->heater2.timestamp)), pBitStrm, pErrCode);
	                                                                	}
	                                                                }
	                                                                if (ret) {
	                                                                    /*Decode anemometer */
	                                                                    if (pVal->exist.anemometer) {
	                                                                    	/*Decode data */
	                                                                    	ret = T_UInt64_Decode((&(pVal->anemometer.data)), pBitStrm, pErrCode);
	                                                                    	if (ret) {
	                                                                    	    /*Decode timestamp */
	                                                                    	    ret = T_Double_Decode((&(pVal->anemometer.timestamp)), pBitStrm, pErrCode);
	                                                                    	}
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && OBSW_DP_Data_IsConstraintValid(pVal, pErrCode);
}

flag OBSW_DP_Data_ACN_Encode(const OBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? OBSW_DP_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.gps);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.imu);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.tc74s);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.pt1000s);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.ps1);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.ps2);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.heater1);
	                            if (ret) {
	                                BitStream_AppendBit(pBitStrm,pVal->exist.heater2);
	                                if (ret) {
	                                    BitStream_AppendBit(pBitStrm,pVal->exist.anemometer);
	                                    if (ret) {
	                                        /*Encode gps */
	                                        if (pVal->exist.gps) {
	                                        	BitStream_AppendBit(pBitStrm,pVal->gps.exist.validity);
	                                        	if (ret) {
	                                        	    /*Encode data */
	                                        	    ret = GPS_PVT_ACN_Encode((&(pVal->gps.data)), pBitStrm, pErrCode, FALSE);
	                                        	    if (ret) {
	                                        	        /*Encode validity */
	                                        	        if (pVal->gps.exist.validity) {
	                                        	        	ret = Content_Validity_ACN_Encode((&(pVal->gps.validity)), pBitStrm, pErrCode, FALSE);
	                                        	        }
	                                        	    }

	                                        	}

	                                        }
	                                        if (ret) {
	                                            /*Encode imu */
	                                            if (pVal->exist.imu) {
	                                            	/*Encode data */
	                                            	ret = IMU_All_Data_ACN_Encode((&(pVal->imu.data)), pBitStrm, pErrCode, FALSE);
	                                            	if (ret) {
	                                            	    /*Encode timestamp */
	                                            	    ret = T_Double_ACN_Encode((&(pVal->imu.timestamp)), pBitStrm, pErrCode, FALSE);
	                                            	}

	                                            }
	                                            if (ret) {
	                                                /*Encode tc74s */
	                                                if (pVal->exist.tc74s) {
	                                                	/*Encode data */
	                                                	ret = TC74s_All_Data_ACN_Encode((&(pVal->tc74s.data)), pBitStrm, pErrCode, FALSE);
	                                                	if (ret) {
	                                                	    /*Encode timestamp */
	                                                	    ret = T_Double_ACN_Encode((&(pVal->tc74s.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                	}

	                                                }
	                                                if (ret) {
	                                                    /*Encode pt1000s */
	                                                    if (pVal->exist.pt1000s) {
	                                                    	/*Encode data */
	                                                    	ret = PT1000s_All_Data_ACN_Encode((&(pVal->pt1000s.data)), pBitStrm, pErrCode, FALSE);
	                                                    	if (ret) {
	                                                    	    /*Encode timestamp */
	                                                    	    ret = T_Double_ACN_Encode((&(pVal->pt1000s.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                    	}

	                                                    }
	                                                    if (ret) {
	                                                        /*Encode ps1 */
	                                                        if (pVal->exist.ps1) {
	                                                        	/*Encode data */
	                                                        	ret = PS_All_Data_ACN_Encode((&(pVal->ps1.data)), pBitStrm, pErrCode, FALSE);
	                                                        	if (ret) {
	                                                        	    /*Encode timestamp */
	                                                        	    ret = T_Double_ACN_Encode((&(pVal->ps1.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                        	}

	                                                        }
	                                                        if (ret) {
	                                                            /*Encode ps2 */
	                                                            if (pVal->exist.ps2) {
	                                                            	/*Encode data */
	                                                            	ret = PS_All_Data_ACN_Encode((&(pVal->ps2.data)), pBitStrm, pErrCode, FALSE);
	                                                            	if (ret) {
	                                                            	    /*Encode timestamp */
	                                                            	    ret = T_Double_ACN_Encode((&(pVal->ps2.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                            	}

	                                                            }
	                                                            if (ret) {
	                                                                /*Encode heater1 */
	                                                                if (pVal->exist.heater1) {
	                                                                	/*Encode data */
	                                                                	ret = T_Float_ACN_Encode((&(pVal->heater1.data)), pBitStrm, pErrCode, FALSE);
	                                                                	if (ret) {
	                                                                	    /*Encode timestamp */
	                                                                	    ret = T_Double_ACN_Encode((&(pVal->heater1.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                                	}

	                                                                }
	                                                                if (ret) {
	                                                                    /*Encode heater2 */
	                                                                    if (pVal->exist.heater2) {
	                                                                    	/*Encode data */
	                                                                    	ret = Heater_Data_ACN_Encode((&(pVal->heater2.data)), pBitStrm, pErrCode, FALSE);
	                                                                    	if (ret) {
	                                                                    	    /*Encode timestamp */
	                                                                    	    ret = T_Double_ACN_Encode((&(pVal->heater2.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                                    	}

	                                                                    }
	                                                                    if (ret) {
	                                                                        /*Encode anemometer */
	                                                                        if (pVal->exist.anemometer) {
	                                                                        	/*Encode data */
	                                                                        	ret = T_UInt64_ACN_Encode((&(pVal->anemometer.data)), pBitStrm, pErrCode, FALSE);
	                                                                        	if (ret) {
	                                                                        	    /*Encode timestamp */
	                                                                        	    ret = T_Double_ACN_Encode((&(pVal->anemometer.timestamp)), pBitStrm, pErrCode, FALSE);
	                                                                        	}

	                                                                        }
	                                                                    }

	                                                                }

	                                                            }

	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag OBSW_DP_Data_ACN_Decode(OBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.gps = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.imu = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.tc74s = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.pt1000s = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.ps1 = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.ps2 = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.heater1 = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                        if (ret) {
	                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                            pVal->exist.heater2 = presenceBit == 0 ? 0 : 1;
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                            if (ret) {
	                                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                pVal->exist.anemometer = presenceBit == 0 ? 0 : 1;
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                                if (ret) {
	                                    /*Decode gps */
	                                    if (pVal->exist.gps) {
	                                    	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                    	pVal->gps.exist.validity = presenceBit == 0 ? 0 : 1;
	                                    	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA_GPS;
	                                    	if (ret) {
	                                    	    /*Decode data */
	                                    	    ret = GPS_PVT_ACN_Decode((&(pVal->gps.data)), pBitStrm, pErrCode);
	                                    	    if (ret) {
	                                    	        /*Decode validity */
	                                    	        if (pVal->gps.exist.validity) {
	                                    	        	ret = Content_Validity_ACN_Decode((&(pVal->gps.validity)), pBitStrm, pErrCode);
	                                    	        } else {
	                                    	            pVal->gps.validity = invalid;
	                                    	        }
	                                    	    }

	                                    	}

	                                    }
	                                    if (ret) {
	                                        /*Decode imu */
	                                        if (pVal->exist.imu) {
	                                        	/*Decode data */
	                                        	ret = IMU_All_Data_ACN_Decode((&(pVal->imu.data)), pBitStrm, pErrCode);
	                                        	if (ret) {
	                                        	    /*Decode timestamp */
	                                        	    ret = T_Double_ACN_Decode((&(pVal->imu.timestamp)), pBitStrm, pErrCode);
	                                        	}

	                                        }
	                                        if (ret) {
	                                            /*Decode tc74s */
	                                            if (pVal->exist.tc74s) {
	                                            	/*Decode data */
	                                            	ret = TC74s_All_Data_ACN_Decode((&(pVal->tc74s.data)), pBitStrm, pErrCode);
	                                            	if (ret) {
	                                            	    /*Decode timestamp */
	                                            	    ret = T_Double_ACN_Decode((&(pVal->tc74s.timestamp)), pBitStrm, pErrCode);
	                                            	}

	                                            }
	                                            if (ret) {
	                                                /*Decode pt1000s */
	                                                if (pVal->exist.pt1000s) {
	                                                	/*Decode data */
	                                                	ret = PT1000s_All_Data_ACN_Decode((&(pVal->pt1000s.data)), pBitStrm, pErrCode);
	                                                	if (ret) {
	                                                	    /*Decode timestamp */
	                                                	    ret = T_Double_ACN_Decode((&(pVal->pt1000s.timestamp)), pBitStrm, pErrCode);
	                                                	}

	                                                }
	                                                if (ret) {
	                                                    /*Decode ps1 */
	                                                    if (pVal->exist.ps1) {
	                                                    	/*Decode data */
	                                                    	ret = PS_All_Data_ACN_Decode((&(pVal->ps1.data)), pBitStrm, pErrCode);
	                                                    	if (ret) {
	                                                    	    /*Decode timestamp */
	                                                    	    ret = T_Double_ACN_Decode((&(pVal->ps1.timestamp)), pBitStrm, pErrCode);
	                                                    	}

	                                                    }
	                                                    if (ret) {
	                                                        /*Decode ps2 */
	                                                        if (pVal->exist.ps2) {
	                                                        	/*Decode data */
	                                                        	ret = PS_All_Data_ACN_Decode((&(pVal->ps2.data)), pBitStrm, pErrCode);
	                                                        	if (ret) {
	                                                        	    /*Decode timestamp */
	                                                        	    ret = T_Double_ACN_Decode((&(pVal->ps2.timestamp)), pBitStrm, pErrCode);
	                                                        	}

	                                                        }
	                                                        if (ret) {
	                                                            /*Decode heater1 */
	                                                            if (pVal->exist.heater1) {
	                                                            	/*Decode data */
	                                                            	ret = T_Float_ACN_Decode((&(pVal->heater1.data)), pBitStrm, pErrCode);
	                                                            	if (ret) {
	                                                            	    /*Decode timestamp */
	                                                            	    ret = T_Double_ACN_Decode((&(pVal->heater1.timestamp)), pBitStrm, pErrCode);
	                                                            	}

	                                                            }
	                                                            if (ret) {
	                                                                /*Decode heater2 */
	                                                                if (pVal->exist.heater2) {
	                                                                	/*Decode data */
	                                                                	ret = Heater_Data_ACN_Decode((&(pVal->heater2.data)), pBitStrm, pErrCode);
	                                                                	if (ret) {
	                                                                	    /*Decode timestamp */
	                                                                	    ret = T_Double_ACN_Decode((&(pVal->heater2.timestamp)), pBitStrm, pErrCode);
	                                                                	}

	                                                                }
	                                                                if (ret) {
	                                                                    /*Decode anemometer */
	                                                                    if (pVal->exist.anemometer) {
	                                                                    	/*Decode data */
	                                                                    	ret = T_UInt64_ACN_Decode((&(pVal->anemometer.data)), pBitStrm, pErrCode);
	                                                                    	if (ret) {
	                                                                    	    /*Decode timestamp */
	                                                                    	    ret = T_Double_ACN_Decode((&(pVal->anemometer.timestamp)), pBitStrm, pErrCode);
	                                                                    	}

	                                                                    }
	                                                                }

	                                                            }

	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && OBSW_DP_Data_IsConstraintValid(pVal, pErrCode);
}



flag T_Int8_Equal(const T_Int8* pVal1, const T_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Int8_Initialize(T_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && T_Int8_IsConstraintValid(pVal, pErrCode);
}

flag T_Int8_ACN_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_ACN_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && T_Int8_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt8_Equal(const T_UInt8* pVal1, const T_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt8_Initialize(T_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && T_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt8_ACN_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_ACN_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && T_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag SPI_ID_Equal(const SPI_ID* pVal1, const SPI_ID* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->bus == pVal2->bus);

    if (ret) {
        ret = (pVal1->cs == pVal2->cs);

    }

	return ret;

}

void SPI_ID_Initialize(SPI_ID* pVal)
{
	(void)pVal;



	/*set bus */
	T_UInt8_Initialize((&(pVal->bus)));
	/*set cs */
	T_UInt8_Initialize((&(pVal->cs)));
}

flag SPI_ID_IsConstraintValid(const SPI_ID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt8_IsConstraintValid((&(pVal->bus)), pErrCode);
    if (ret) {
        ret = T_UInt8_IsConstraintValid((&(pVal->cs)), pErrCode);
    }

	return ret;
}

flag SPI_ID_Encode(const SPI_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? SPI_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = T_UInt8_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode cs */
	        ret = T_UInt8_Encode((&(pVal->cs)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SPI_ID_Decode(SPI_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = T_UInt8_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode cs */
	    ret = T_UInt8_Decode((&(pVal->cs)), pBitStrm, pErrCode);
	}

	return ret  && SPI_ID_IsConstraintValid(pVal, pErrCode);
}

flag SPI_ID_ACN_Encode(const SPI_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? SPI_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = T_UInt8_ACN_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode cs */
	        ret = T_UInt8_ACN_Encode((&(pVal->cs)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SPI_ID_ACN_Decode(SPI_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = T_UInt8_ACN_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode cs */
	    ret = T_UInt8_ACN_Decode((&(pVal->cs)), pBitStrm, pErrCode);
	}


    return ret && SPI_ID_IsConstraintValid(pVal, pErrCode);
}



flag I2C_ID_Equal(const I2C_ID* pVal1, const I2C_ID* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->bus == pVal2->bus);

    if (ret) {
        ret = (pVal1->address == pVal2->address);

    }

	return ret;

}

void I2C_ID_Initialize(I2C_ID* pVal)
{
	(void)pVal;



	/*set bus */
	T_UInt8_Initialize((&(pVal->bus)));
	/*set address */
	T_UInt8_Initialize((&(pVal->address)));
}

flag I2C_ID_IsConstraintValid(const I2C_ID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt8_IsConstraintValid((&(pVal->bus)), pErrCode);
    if (ret) {
        ret = T_UInt8_IsConstraintValid((&(pVal->address)), pErrCode);
    }

	return ret;
}

flag I2C_ID_Encode(const I2C_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? I2C_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = T_UInt8_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode address */
	        ret = T_UInt8_Encode((&(pVal->address)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag I2C_ID_Decode(I2C_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = T_UInt8_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode address */
	    ret = T_UInt8_Decode((&(pVal->address)), pBitStrm, pErrCode);
	}

	return ret  && I2C_ID_IsConstraintValid(pVal, pErrCode);
}

flag I2C_ID_ACN_Encode(const I2C_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? I2C_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = T_UInt8_ACN_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode address */
	        ret = T_UInt8_ACN_Encode((&(pVal->address)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag I2C_ID_ACN_Decode(I2C_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = T_UInt8_ACN_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode address */
	    ret = T_UInt8_ACN_Decode((&(pVal->address)), pBitStrm, pErrCode);
	}


    return ret && I2C_ID_IsConstraintValid(pVal, pErrCode);
}



flag T_Boolean_Equal(const T_Boolean* pVal1, const T_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Boolean_Initialize(T_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && T_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag T_Boolean_ACN_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_ACN_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && T_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag T_Null_Record_Equal(const T_Null_Record* pVal1, const T_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

void T_Null_Record_Initialize(T_Null_Record* pVal)
{
	(void)pVal;


}

flag T_Null_Record_IsConstraintValid(const T_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag T_Null_Record_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag T_Null_Record_ACN_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_ACN_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}

