// Body file for function PT1000Sensors
// Generated by TASTE on 2021-05-17 23:45:12
// You can edit this file, it will not be overwritten
// Provided interfaces : readTemps
// Required interfaces : 
// User-defined properties for this function:
//   |_ Taste::Active_Interfaces = any
//   |_ Taste::coordinates = 78036 170074 104722 180547
// Timers              : 

#include "pt1000sensors.h"
#include "pt1000sensors_state.h"
#include "Context-pt1000sensors.h"
#include <iostream>
#include <time.h>

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere
pt1000sensors_state ctxt_pt1000sensors;
static bool stopped_pt1000s = false;

void pt1000sensors_startup(void)
{
    std::cout << "[PT1000Sensors] Startup" << std::endl;
}

void pt1000sensors_PI_readTemps (asn1SccPT1000s_All_Data *OUT_pt1000s_data)
{
    if (stopped_pt1000s) {
        return;
    }
    
    struct timespec start, stop;
    clock_gettime(CLOCK_MONOTONIC, &start);
    
    for (int i = 0; i < n_of_pt1000; ++i) {
        float temp;
        int rc = ctxt_pt1000sensors.all_pt1000[i].getTempCelsius(temp);
        
        if (rc < 0) {
            OUT_pt1000s_data->validity.arr[i] = asn1Sccinvalid;
        } else {
            OUT_pt1000s_data->validity.arr[i] = asn1Sccvalid;
            OUT_pt1000s_data->celsius.arr[i] = temp;
            OUT_pt1000s_data->raw.arr[i].vcc_volts =
                                ctxt_pt1000sensors.all_pt1000[i].getLastVccReading();
            OUT_pt1000s_data->raw.arr[i].pt1000 =
                                ctxt_pt1000sensors.all_pt1000[i].getLastThermistorReading();
        }
    }
    
    clock_gettime(CLOCK_MONOTONIC, &stop);
    ctxt_pt1000sensors.et += ((stop.tv_sec - start.tv_sec)*1e3 + (stop.tv_nsec - start.tv_nsec)/1e6);
    ctxt_pt1000sensors.nIters++;
}

void pt1000sensors_PI_stop( ) {
    stopped_pt1000s = true;
    ctxt_pt1000sensors.~pt1000sensors_state();
}
