/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview-uniq.h"

const asn1SccSint n_of_TC74s = 5;
const asn1SccSint n_of_pt1000 = 7;


flag T_Int16_Equal(const T_Int16* pVal1, const T_Int16* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Int16_Initialize(T_Int16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int16_IsConstraintValid(const T_Int16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-32768LL <= (*(pVal))) && ((*(pVal)) <= 32767LL));
    *pErrCode = ret ? 0 :  ERR_T_INT16; 

	return ret;
}

flag T_Int16_Encode(const T_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int16_Decode(T_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT16;

	return ret  && T_Int16_IsConstraintValid(pVal, pErrCode);
}

flag T_Int16_ACN_Encode(const T_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int16_ACN_Decode(T_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT16;

    return ret && T_Int16_IsConstraintValid(pVal, pErrCode);
}



flag MGT_Raw_Data_Equal(const MGT_Raw_Data* pVal1, const MGT_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void MGT_Raw_Data_Initialize(MGT_Raw_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Int16_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Int16_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Int16_Initialize((&(pVal->z_axis)));
}

flag MGT_Raw_Data_IsConstraintValid(const MGT_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Int16_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Int16_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Int16_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag MGT_Raw_Data_Encode(const MGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? MGT_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MGT_Raw_Data_Decode(MGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && MGT_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag MGT_Raw_Data_ACN_Encode(const MGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? MGT_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MGT_Raw_Data_ACN_Decode(MGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && MGT_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag ACC_Raw_Data_Equal(const ACC_Raw_Data* pVal1, const ACC_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void ACC_Raw_Data_Initialize(ACC_Raw_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Int16_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Int16_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Int16_Initialize((&(pVal->z_axis)));
}

flag ACC_Raw_Data_IsConstraintValid(const ACC_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Int16_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Int16_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Int16_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag ACC_Raw_Data_Encode(const ACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? ACC_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ACC_Raw_Data_Decode(ACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && ACC_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag ACC_Raw_Data_ACN_Encode(const ACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? ACC_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ACC_Raw_Data_ACN_Decode(ACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && ACC_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag GYRO_Raw_Data_Equal(const GYRO_Raw_Data* pVal1, const GYRO_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void GYRO_Raw_Data_Initialize(GYRO_Raw_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Int16_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Int16_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Int16_Initialize((&(pVal->z_axis)));
}

flag GYRO_Raw_Data_IsConstraintValid(const GYRO_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Int16_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Int16_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Int16_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag GYRO_Raw_Data_Encode(const GYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? GYRO_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GYRO_Raw_Data_Decode(GYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && GYRO_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag GYRO_Raw_Data_ACN_Encode(const GYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? GYRO_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Int16_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Int16_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Int16_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GYRO_Raw_Data_ACN_Decode(GYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Int16_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Int16_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Int16_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && GYRO_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt16_Equal(const T_UInt16* pVal1, const T_UInt16* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt16_Initialize(T_UInt16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt16_IsConstraintValid(const T_UInt16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT16; 

	return ret;
}

flag T_UInt16_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt16_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT16;

	return ret  && T_UInt16_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt16_ACN_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt16_ACN_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT16;

    return ret && T_UInt16_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt64_Equal(const T_UInt64* pVal1, const T_UInt64* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt64_Initialize(T_UInt64* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt64_IsConstraintValid(const T_UInt64* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag T_UInt64_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt64_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT64;

	return ret  && T_UInt64_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt64_ACN_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt64_ACN_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT64;

    return ret && T_UInt64_IsConstraintValid(pVal, pErrCode);
}



flag T_Float_Equal(const T_Float* pVal1, const T_Float* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Float_Initialize(T_Float* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.00000000000000000000E+000;
}

flag T_Float_IsConstraintValid(const T_Float* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-3.40000000000000000000E+038 <= (*(pVal))) && ((*(pVal)) <= 3.40000000000000000000E+038));
    *pErrCode = ret ? 0 :  ERR_T_FLOAT; 

	return ret;
}

flag T_Float_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Float_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FLOAT;

	return ret  && T_Float_IsConstraintValid(pVal, pErrCode);
}

flag T_Float_ACN_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Float_ACN_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_FLOAT;

    return ret && T_Float_IsConstraintValid(pVal, pErrCode);
}



flag MGT_MilliGauss_Data_Equal(const MGT_MilliGauss_Data* pVal1, const MGT_MilliGauss_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void MGT_MilliGauss_Data_Initialize(MGT_MilliGauss_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Float_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Float_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Float_Initialize((&(pVal->z_axis)));
}

flag MGT_MilliGauss_Data_IsConstraintValid(const MGT_MilliGauss_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Float_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Float_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Float_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag MGT_MilliGauss_Data_Encode(const MGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? MGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MGT_MilliGauss_Data_Decode(MGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && MGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode);
}

flag MGT_MilliGauss_Data_ACN_Encode(const MGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? MGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MGT_MilliGauss_Data_ACN_Decode(MGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && MGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode);
}



flag ACC_MilliG_Data_Equal(const ACC_MilliG_Data* pVal1, const ACC_MilliG_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void ACC_MilliG_Data_Initialize(ACC_MilliG_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Float_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Float_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Float_Initialize((&(pVal->z_axis)));
}

flag ACC_MilliG_Data_IsConstraintValid(const ACC_MilliG_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Float_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Float_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Float_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag ACC_MilliG_Data_Encode(const ACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? ACC_MilliG_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ACC_MilliG_Data_Decode(ACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && ACC_MilliG_Data_IsConstraintValid(pVal, pErrCode);
}

flag ACC_MilliG_Data_ACN_Encode(const ACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? ACC_MilliG_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ACC_MilliG_Data_ACN_Decode(ACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && ACC_MilliG_Data_IsConstraintValid(pVal, pErrCode);
}



flag GYRO_MilliDPS_Data_Equal(const GYRO_MilliDPS_Data* pVal1, const GYRO_MilliDPS_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void GYRO_MilliDPS_Data_Initialize(GYRO_MilliDPS_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	T_Float_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	T_Float_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	T_Float_Initialize((&(pVal->z_axis)));
}

flag GYRO_MilliDPS_Data_IsConstraintValid(const GYRO_MilliDPS_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Float_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = T_Float_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = T_Float_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag GYRO_MilliDPS_Data_Encode(const GYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? GYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GYRO_MilliDPS_Data_Decode(GYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && GYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode);
}

flag GYRO_MilliDPS_Data_ACN_Encode(const GYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? GYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = T_Float_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = T_Float_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = T_Float_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GYRO_MilliDPS_Data_ACN_Decode(GYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = T_Float_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = T_Float_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = T_Float_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && GYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode);
}



flag PT1000s_Raw_Data_elem_Equal(const PT1000s_Raw_Data_elem* pVal1, const PT1000s_Raw_Data_elem* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->vcc_volts == pVal2->vcc_volts);

    if (ret) {
        ret = (pVal1->pt1000 == pVal2->pt1000);

    }

	return ret;

}

flag PT1000s_Raw_Data_Equal(const PT1000s_Raw_Data* pVal1, const PT1000s_Raw_Data* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = PT1000s_Raw_Data_elem_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

void PT1000s_Raw_Data_elem_Initialize(PT1000s_Raw_Data_elem* pVal)
{
	(void)pVal;



	/*set vcc_volts */
	T_Float_Initialize((&(pVal->vcc_volts)));
	/*set pt1000 */
	T_Float_Initialize((&(pVal->pt1000)));
}
void PT1000s_Raw_Data_Initialize(PT1000s_Raw_Data* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 7) {
	    PT1000s_Raw_Data_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag PT1000s_Raw_Data_IsConstraintValid(const PT1000s_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = T_Float_IsConstraintValid((&(pVal->arr[i1].vcc_volts)), pErrCode);
    	if (ret) {
    	    ret = T_Float_IsConstraintValid((&(pVal->arr[i1].pt1000)), pErrCode);
    	}
    }

	return ret;
}

flag PT1000s_Raw_Data_Encode(const PT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? PT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	/*Encode vcc_volts */
	    	ret = T_Float_Encode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode pt1000 */
	    	    ret = T_Float_Encode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Raw_Data_Decode(PT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		/*Decode vcc_volts */
		ret = T_Float_Decode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode);
		if (ret) {
		    /*Decode pt1000 */
		    ret = T_Float_Decode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode);
		}
	}

	return ret  && PT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag PT1000s_Raw_Data_ACN_Encode(const PT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? PT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	/*Encode vcc_volts */
	    	ret = T_Float_ACN_Encode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode pt1000 */
	    	    ret = T_Float_ACN_Encode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode, FALSE);
	    	}

	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Raw_Data_ACN_Decode(PT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		/*Decode vcc_volts */
		ret = T_Float_ACN_Decode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode);
		if (ret) {
		    /*Decode pt1000 */
		    ret = T_Float_ACN_Decode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode);
		}

	}

    return ret && PT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag PT1000s_Celsius_Data_Equal(const PT1000s_Celsius_Data* pVal1, const PT1000s_Celsius_Data* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void PT1000s_Celsius_Data_Initialize(PT1000s_Celsius_Data* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 7) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag PT1000s_Celsius_Data_IsConstraintValid(const PT1000s_Celsius_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = T_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag PT1000s_Celsius_Data_Encode(const PT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? PT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	ret = T_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Celsius_Data_Decode(PT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		ret = T_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && PT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode);
}

flag PT1000s_Celsius_Data_ACN_Encode(const PT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? PT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	ret = T_Float_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Celsius_Data_ACN_Decode(PT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		ret = T_Float_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && PT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode);
}



flag PS_Calibration_Data_Equal(const PS_Calibration_Data* pVal1, const PS_Calibration_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->c1 == pVal2->c1);

    if (ret) {
        ret = (pVal1->c2 == pVal2->c2);

        if (ret) {
            ret = (pVal1->c3 == pVal2->c3);

            if (ret) {
                ret = (pVal1->c4 == pVal2->c4);

                if (ret) {
                    ret = (pVal1->c5 == pVal2->c5);

                    if (ret) {
                        ret = (pVal1->c6 == pVal2->c6);

                        if (ret) {
                            ret = (pVal1->sens_t1 == pVal2->sens_t1);

                            if (ret) {
                                ret = (pVal1->off_t1 == pVal2->off_t1);

                                if (ret) {
                                    ret = (pVal1->tcs == pVal2->tcs);

                                    if (ret) {
                                        ret = (pVal1->tco == pVal2->tco);

                                        if (ret) {
                                            ret = (pVal1->tref == pVal2->tref);

                                            if (ret) {
                                                ret = (pVal1->temp_sens == pVal2->temp_sens);

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void PS_Calibration_Data_Initialize(PS_Calibration_Data* pVal)
{
	(void)pVal;



	/*set c1 */
	T_UInt16_Initialize((&(pVal->c1)));
	/*set c2 */
	T_UInt16_Initialize((&(pVal->c2)));
	/*set c3 */
	T_UInt16_Initialize((&(pVal->c3)));
	/*set c4 */
	T_UInt16_Initialize((&(pVal->c4)));
	/*set c5 */
	T_UInt16_Initialize((&(pVal->c5)));
	/*set c6 */
	T_UInt16_Initialize((&(pVal->c6)));
	/*set sens_t1 */
	T_Float_Initialize((&(pVal->sens_t1)));
	/*set off_t1 */
	T_Float_Initialize((&(pVal->off_t1)));
	/*set tcs */
	T_Float_Initialize((&(pVal->tcs)));
	/*set tco */
	T_Float_Initialize((&(pVal->tco)));
	/*set tref */
	T_Float_Initialize((&(pVal->tref)));
	/*set temp_sens */
	T_Float_Initialize((&(pVal->temp_sens)));
}

flag PS_Calibration_Data_IsConstraintValid(const PS_Calibration_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt16_IsConstraintValid((&(pVal->c1)), pErrCode);
    if (ret) {
        ret = T_UInt16_IsConstraintValid((&(pVal->c2)), pErrCode);
        if (ret) {
            ret = T_UInt16_IsConstraintValid((&(pVal->c3)), pErrCode);
            if (ret) {
                ret = T_UInt16_IsConstraintValid((&(pVal->c4)), pErrCode);
                if (ret) {
                    ret = T_UInt16_IsConstraintValid((&(pVal->c5)), pErrCode);
                    if (ret) {
                        ret = T_UInt16_IsConstraintValid((&(pVal->c6)), pErrCode);
                        if (ret) {
                            ret = T_Float_IsConstraintValid((&(pVal->sens_t1)), pErrCode);
                            if (ret) {
                                ret = T_Float_IsConstraintValid((&(pVal->off_t1)), pErrCode);
                                if (ret) {
                                    ret = T_Float_IsConstraintValid((&(pVal->tcs)), pErrCode);
                                    if (ret) {
                                        ret = T_Float_IsConstraintValid((&(pVal->tco)), pErrCode);
                                        if (ret) {
                                            ret = T_Float_IsConstraintValid((&(pVal->tref)), pErrCode);
                                            if (ret) {
                                                ret = T_Float_IsConstraintValid((&(pVal->temp_sens)), pErrCode);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag PS_Calibration_Data_Encode(const PS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? PS_Calibration_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode c1 */
	    ret = T_UInt16_Encode((&(pVal->c1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode c2 */
	        ret = T_UInt16_Encode((&(pVal->c2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode c3 */
	            ret = T_UInt16_Encode((&(pVal->c3)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode c4 */
	                ret = T_UInt16_Encode((&(pVal->c4)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode c5 */
	                    ret = T_UInt16_Encode((&(pVal->c5)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode c6 */
	                        ret = T_UInt16_Encode((&(pVal->c6)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode sens_t1 */
	                            ret = T_Float_Encode((&(pVal->sens_t1)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode off_t1 */
	                                ret = T_Float_Encode((&(pVal->off_t1)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode tcs */
	                                    ret = T_Float_Encode((&(pVal->tcs)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode tco */
	                                        ret = T_Float_Encode((&(pVal->tco)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode tref */
	                                            ret = T_Float_Encode((&(pVal->tref)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode temp_sens */
	                                                ret = T_Float_Encode((&(pVal->temp_sens)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Calibration_Data_Decode(PS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode c1 */
	ret = T_UInt16_Decode((&(pVal->c1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode c2 */
	    ret = T_UInt16_Decode((&(pVal->c2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode c3 */
	        ret = T_UInt16_Decode((&(pVal->c3)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode c4 */
	            ret = T_UInt16_Decode((&(pVal->c4)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode c5 */
	                ret = T_UInt16_Decode((&(pVal->c5)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode c6 */
	                    ret = T_UInt16_Decode((&(pVal->c6)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode sens_t1 */
	                        ret = T_Float_Decode((&(pVal->sens_t1)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode off_t1 */
	                            ret = T_Float_Decode((&(pVal->off_t1)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode tcs */
	                                ret = T_Float_Decode((&(pVal->tcs)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode tco */
	                                    ret = T_Float_Decode((&(pVal->tco)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode tref */
	                                        ret = T_Float_Decode((&(pVal->tref)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode temp_sens */
	                                            ret = T_Float_Decode((&(pVal->temp_sens)), pBitStrm, pErrCode);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && PS_Calibration_Data_IsConstraintValid(pVal, pErrCode);
}

flag PS_Calibration_Data_ACN_Encode(const PS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? PS_Calibration_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode c1 */
	    ret = T_UInt16_ACN_Encode((&(pVal->c1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode c2 */
	        ret = T_UInt16_ACN_Encode((&(pVal->c2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode c3 */
	            ret = T_UInt16_ACN_Encode((&(pVal->c3)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode c4 */
	                ret = T_UInt16_ACN_Encode((&(pVal->c4)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode c5 */
	                    ret = T_UInt16_ACN_Encode((&(pVal->c5)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode c6 */
	                        ret = T_UInt16_ACN_Encode((&(pVal->c6)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode sens_t1 */
	                            ret = T_Float_ACN_Encode((&(pVal->sens_t1)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode off_t1 */
	                                ret = T_Float_ACN_Encode((&(pVal->off_t1)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode tcs */
	                                    ret = T_Float_ACN_Encode((&(pVal->tcs)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode tco */
	                                        ret = T_Float_ACN_Encode((&(pVal->tco)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode tref */
	                                            ret = T_Float_ACN_Encode((&(pVal->tref)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode temp_sens */
	                                                ret = T_Float_ACN_Encode((&(pVal->temp_sens)), pBitStrm, pErrCode, FALSE);
	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Calibration_Data_ACN_Decode(PS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode c1 */
	ret = T_UInt16_ACN_Decode((&(pVal->c1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode c2 */
	    ret = T_UInt16_ACN_Decode((&(pVal->c2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode c3 */
	        ret = T_UInt16_ACN_Decode((&(pVal->c3)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode c4 */
	            ret = T_UInt16_ACN_Decode((&(pVal->c4)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode c5 */
	                ret = T_UInt16_ACN_Decode((&(pVal->c5)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode c6 */
	                    ret = T_UInt16_ACN_Decode((&(pVal->c6)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode sens_t1 */
	                        ret = T_Float_ACN_Decode((&(pVal->sens_t1)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode off_t1 */
	                            ret = T_Float_ACN_Decode((&(pVal->off_t1)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode tcs */
	                                ret = T_Float_ACN_Decode((&(pVal->tcs)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode tco */
	                                    ret = T_Float_ACN_Decode((&(pVal->tco)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode tref */
	                                        ret = T_Float_ACN_Decode((&(pVal->tref)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode temp_sens */
	                                            ret = T_Float_ACN_Decode((&(pVal->temp_sens)), pBitStrm, pErrCode);
	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && PS_Calibration_Data_IsConstraintValid(pVal, pErrCode);
}



flag TC_Heater_heater_Equal(const TC_Heater_heater* pVal1, const TC_Heater_heater* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag TC_Heater_command_max_min_Equal(const TC_Heater_command_max_min* pVal1, const TC_Heater_command_max_min* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag TC_Heater_command_Equal(const TC_Heater_command* pVal1, const TC_Heater_command* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->kind == pVal2->kind);
    if (ret) {
    	switch(pVal1->kind) 
    	{
    	case power_manual_PRESENT:
    		ret = (pVal1->u.power_manual == pVal2->u.power_manual);
    		break;
    	case max_min_PRESENT:
    		ret = TC_Heater_command_max_min_Equal((&(pVal1->u.max_min)), (&(pVal2->u.max_min)));
    		break;
    	default: /*COVERAGE_IGNORE*/
    		ret = FALSE;    /*COVERAGE_IGNORE*/
    	}
    } /*COVERAGE_IGNORE*/
	return ret;

}

flag TC_Heater_Equal(const TC_Heater* pVal1, const TC_Heater* pVal2)
{
	flag ret=TRUE;

    ret = TC_Heater_heater_Equal((&(pVal1->heater)), (&(pVal2->heater)));

    if (ret) {
        ret = TC_Heater_command_Equal((&(pVal1->command)), (&(pVal2->command)));

    }

	return ret;

}

void TC_Heater_heater_Initialize(TC_Heater_heater* pVal)
{
	(void)pVal;


	(*(pVal)) = heater_HTL;
}
void TC_Heater_command_max_min_Initialize(TC_Heater_command_max_min* pVal)
{
	(void)pVal;


	(*(pVal)) = max;
}
void TC_Heater_command_Initialize(TC_Heater_command* pVal)
{
	(void)pVal;


	/*set power_manual*/
	pVal->kind = power_manual_PRESENT;
	T_Float_Initialize((&(pVal->u.power_manual)));
}
void TC_Heater_Initialize(TC_Heater* pVal)
{
	(void)pVal;



	/*set heater */
	TC_Heater_heater_Initialize((&(pVal->heater)));
	/*set command */
	TC_Heater_command_Initialize((&(pVal->command)));
}

flag TC_Heater_IsConstraintValid(const TC_Heater* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (((pVal->heater == heater_HTL)) || ((pVal->heater == heater_anemo)));
    *pErrCode = ret ? 0 :  ERR_TC_HEATER_HEATER; 
    if (ret) {
        if (pVal->command.kind == power_manual_PRESENT) {
        	ret = T_Float_IsConstraintValid((&(pVal->command.u.power_manual)), pErrCode);
        }
        if (ret) {
            if (pVal->command.kind == max_min_PRESENT) {
            	ret = (((pVal->command.u.max_min == max)) || ((pVal->command.u.max_min == min)));
            	*pErrCode = ret ? 0 :  ERR_TC_HEATER_COMMAND_MAX_MIN; 
            }
        }
    }

	return ret;
}

flag TC_Heater_Encode(const TC_Heater* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? TC_Heater_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heater */
	    switch(pVal->heater) 
	    {
	        case heater_HTL:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case heater_anemo:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TC_HEATER_HEATER; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	        /*Encode command */
	        switch(pVal->command.kind) 
	        {
	        case power_manual_PRESENT:
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	ret = T_Float_Encode((&(pVal->command.u.power_manual)), pBitStrm, pErrCode, FALSE);
	        	break;
	        case max_min_PRESENT:
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	switch(pVal->command.u.max_min) 
	        	{
	        	    case max:   
	        	        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	    	break;
	        	    case min:   
	        	        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	    	break;
	        	    default:                    /*COVERAGE_IGNORE*/
	        		    *pErrCode = ERR_UPER_ENCODE_TC_HEATER_COMMAND_MAX_MIN; /*COVERAGE_IGNORE*/
	        		    ret = FALSE;            /*COVERAGE_IGNORE*/
	        	}
	        	break;
	        default:                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_UPER_ENCODE_TC_HEATER_COMMAND;         /*COVERAGE_IGNORE*/
	            ret = FALSE;                    /*COVERAGE_IGNORE*/
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC_Heater_Decode(TC_Heater* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint TC_Heater_command_index_tmp;

	/*Decode heater */
	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TC_HEATER_HEATER;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                pVal->heater = heater_HTL;
	                break;
	            case 1: 
	                pVal->heater = heater_anemo;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TC_HEATER_HEATER;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        pVal->heater = heater_HTL;             /*COVERAGE_IGNORE*/
	    }
	}
	if (ret) {
	    /*Decode command */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &TC_Heater_command_index_tmp, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TC_HEATER_COMMAND;
	    if (ret) {
	        switch(TC_Heater_command_index_tmp) 
	        {
	        case 0:
	        	pVal->command.kind = power_manual_PRESENT;
	        	ret = T_Float_Decode((&(pVal->command.u.power_manual)), pBitStrm, pErrCode);
	        	break;
	        case 1:
	        	pVal->command.kind = max_min_PRESENT;
	        	{
	        	    asn1SccSint enumIndex;
	        	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	        	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TC_HEATER_COMMAND_MAX_MIN;
	        	    if (ret) {
	        	        switch(enumIndex) 
	        	        {
	        	            case 0: 
	        	                pVal->command.u.max_min = max;
	        	                break;
	        	            case 1: 
	        	                pVal->command.u.max_min = min;
	        	                break;
	        	            default:                        /*COVERAGE_IGNORE*/
	        		            *pErrCode = ERR_UPER_DECODE_TC_HEATER_COMMAND_MAX_MIN;     /*COVERAGE_IGNORE*/
	        		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        	        }
	        	    } else {
	        	        pVal->command.u.max_min = max;             /*COVERAGE_IGNORE*/
	        	    }
	        	}
	        	break;
	        default:                        /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_UPER_DECODE_TC_HEATER_COMMAND;     /*COVERAGE_IGNORE*/
	            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    }  /*COVERAGE_IGNORE*/
	}

	return ret  && TC_Heater_IsConstraintValid(pVal, pErrCode);
}

flag TC_Heater_ACN_Encode(const TC_Heater* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? TC_Heater_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heater */
	    switch(pVal->heater) { 
	        case heater_HTL:
	            uIntVal = 0;
	            break;
	        case heater_anemo:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TC_HEATER_HEATER;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
	    if (ret) {
	        /*Encode command */
	        switch(pVal->command.kind) 
	        {
	        case power_manual_PRESENT:
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	ret = T_Float_ACN_Encode((&(pVal->command.u.power_manual)), pBitStrm, pErrCode, FALSE);
	        	break;
	        case max_min_PRESENT:
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	switch(pVal->command.u.max_min) { 
	        	    case max:
	        	        uIntVal = 0;
	        	        break;
	        	    case min:
	        	        uIntVal = 1;
	        	        break;
	        	    default:                                    /*COVERAGE_IGNORE*/
	        	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	        *pErrCode = ERR_ACN_ENCODE_TC_HEATER_COMMAND_MAX_MIN;                 /*COVERAGE_IGNORE*/
	        	}
	        	if (ret) {
	        		BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	        	}
	        	break;
	        default: /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TC_HEATER_COMMAND;         /*COVERAGE_IGNORE*/
	            ret = FALSE;                    /*COVERAGE_IGNORE*/
	        } /*COVERAGE_IGNORE*/
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC_Heater_ACN_Decode(TC_Heater* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;
	asn1SccSint TASEC_LAB_B2SPACE_DATAVIEW_TC_Heater_command_index_tmp;

	/*Decode heater */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TC_HEATER_HEATER;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            pVal->heater = heater_HTL;
	            break;
	        case 1:
	            pVal->heater = heater_anemo;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TC_HEATER_HEATER;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/
	if (ret) {
	    /*Decode command */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &TASEC_LAB_B2SPACE_DATAVIEW_TC_Heater_command_index_tmp, 0, 1);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_TC_HEATER_COMMAND;
	    if (ret) {
	        switch(TASEC_LAB_B2SPACE_DATAVIEW_TC_Heater_command_index_tmp) 
	        {
	        case 0:
	        	pVal->command.kind = power_manual_PRESENT;
	        	ret = T_Float_ACN_Decode((&(pVal->command.u.power_manual)), pBitStrm, pErrCode);
	        	break;
	        case 1:
	        	pVal->command.kind = max_min_PRESENT;
	        	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TC_HEATER_COMMAND_MAX_MIN;
	        	if (ret) {
	        	    switch (uIntVal) {
	        	        case 0:
	        	            pVal->command.u.max_min = max;
	        	            break;
	        	        case 1:
	        	            pVal->command.u.max_min = min;
	        	            break;
	        	    default:                                    /*COVERAGE_IGNORE*/
	        	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	        *pErrCode = ERR_ACN_DECODE_TC_HEATER_COMMAND_MAX_MIN;                 /*COVERAGE_IGNORE*/
	        	    }
	        	} /*COVERAGE_IGNORE*/
	        	break;
	        default: /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_DECODE_TC_HEATER_COMMAND;     /*COVERAGE_IGNORE*/
	            ret = FALSE;                /*COVERAGE_IGNORE*/
	        } 
	    } /*COVERAGE_IGNORE*/
	}


    return ret && TC_Heater_IsConstraintValid(pVal, pErrCode);
}



flag T_Double_Equal(const T_Double* pVal1, const T_Double* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Double_Initialize(T_Double* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.00000000000000000000E+000;
}

flag T_Double_IsConstraintValid(const T_Double* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1.69999999999999990000E+308 <= (*(pVal))) && ((*(pVal)) <= 1.69999999999999990000E+308));
    *pErrCode = ret ? 0 :  ERR_T_DOUBLE; 

	return ret;
}

flag T_Double_Encode(const T_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Double_Decode(T_Double* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_DOUBLE;

	return ret  && T_Double_IsConstraintValid(pVal, pErrCode);
}

flag T_Double_ACN_Encode(const T_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Double_ACN_Decode(T_Double* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_DOUBLE;

    return ret && T_Double_IsConstraintValid(pVal, pErrCode);
}



flag GPS_PVT_mode_Equal(const GPS_PVT_mode* pVal1, const GPS_PVT_mode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag GPS_PVT_Equal(const GPS_PVT* pVal1, const GPS_PVT* pVal2)
{
	flag ret=TRUE;

    ret = GPS_PVT_mode_Equal((&(pVal1->mode)), (&(pVal2->mode)));

    if (ret) {
        ret = (pVal1->date_and_time == pVal2->date_and_time);

        if (ret) {
            ret = (pVal1->ept == pVal2->ept);

            if (ret) {
                ret = (pVal1->latitude == pVal2->latitude);

                if (ret) {
                    ret = (pVal1->epy == pVal2->epy);

                    if (ret) {
                        ret = (pVal1->longitude == pVal2->longitude);

                        if (ret) {
                            ret = (pVal1->epx == pVal2->epx);

                            if (ret) {
                                ret = (pVal1->altitude == pVal2->altitude);

                                if (ret) {
                                    ret = (pVal1->epv == pVal2->epv);

                                    if (ret) {
                                        ret = (pVal1->course == pVal2->course);

                                        if (ret) {
                                            ret = (pVal1->epd == pVal2->epd);

                                            if (ret) {
                                                ret = (pVal1->speed == pVal2->speed);

                                                if (ret) {
                                                    ret = (pVal1->eps == pVal2->eps);

                                                    if (ret) {
                                                        ret = (pVal1->climb == pVal2->climb);

                                                        if (ret) {
                                                            ret = (pVal1->epc == pVal2->epc);

                                                        }

                                                    }

                                                }

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void GPS_PVT_mode_Initialize(GPS_PVT_mode* pVal)
{
	(void)pVal;


	(*(pVal)) = not_seen;
}
void GPS_PVT_Initialize(GPS_PVT* pVal)
{
	(void)pVal;



	/*set mode */
	GPS_PVT_mode_Initialize((&(pVal->mode)));
	/*set date_and_time */
	T_Double_Initialize((&(pVal->date_and_time)));
	/*set ept */
	T_Double_Initialize((&(pVal->ept)));
	/*set latitude */
	T_Double_Initialize((&(pVal->latitude)));
	/*set epy */
	T_Double_Initialize((&(pVal->epy)));
	/*set longitude */
	T_Double_Initialize((&(pVal->longitude)));
	/*set epx */
	T_Double_Initialize((&(pVal->epx)));
	/*set altitude */
	T_Double_Initialize((&(pVal->altitude)));
	/*set epv */
	T_Double_Initialize((&(pVal->epv)));
	/*set course */
	T_Double_Initialize((&(pVal->course)));
	/*set epd */
	T_Double_Initialize((&(pVal->epd)));
	/*set speed */
	T_Double_Initialize((&(pVal->speed)));
	/*set eps */
	T_Double_Initialize((&(pVal->eps)));
	/*set climb */
	T_Double_Initialize((&(pVal->climb)));
	/*set epc */
	T_Double_Initialize((&(pVal->epc)));
}

flag GPS_PVT_IsConstraintValid(const GPS_PVT* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (((((((pVal->mode == not_seen)) || ((pVal->mode == no_fix)))) || ((pVal->mode == two_dims)))) || ((pVal->mode == three_dims)));
    *pErrCode = ret ? 0 :  ERR_GPS_PVT_MODE; 
    if (ret) {
        ret = T_Double_IsConstraintValid((&(pVal->date_and_time)), pErrCode);
        if (ret) {
            ret = T_Double_IsConstraintValid((&(pVal->ept)), pErrCode);
            if (ret) {
                ret = T_Double_IsConstraintValid((&(pVal->latitude)), pErrCode);
                if (ret) {
                    ret = T_Double_IsConstraintValid((&(pVal->epy)), pErrCode);
                    if (ret) {
                        ret = T_Double_IsConstraintValid((&(pVal->longitude)), pErrCode);
                        if (ret) {
                            ret = T_Double_IsConstraintValid((&(pVal->epx)), pErrCode);
                            if (ret) {
                                ret = T_Double_IsConstraintValid((&(pVal->altitude)), pErrCode);
                                if (ret) {
                                    ret = T_Double_IsConstraintValid((&(pVal->epv)), pErrCode);
                                    if (ret) {
                                        ret = T_Double_IsConstraintValid((&(pVal->course)), pErrCode);
                                        if (ret) {
                                            ret = T_Double_IsConstraintValid((&(pVal->epd)), pErrCode);
                                            if (ret) {
                                                ret = T_Double_IsConstraintValid((&(pVal->speed)), pErrCode);
                                                if (ret) {
                                                    ret = T_Double_IsConstraintValid((&(pVal->eps)), pErrCode);
                                                    if (ret) {
                                                        ret = T_Double_IsConstraintValid((&(pVal->climb)), pErrCode);
                                                        if (ret) {
                                                            ret = T_Double_IsConstraintValid((&(pVal->epc)), pErrCode);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag GPS_PVT_Encode(const GPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? GPS_PVT_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mode */
	    switch(pVal->mode) 
	    {
	        case not_seen:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case no_fix:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case two_dims:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case three_dims:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_GPS_PVT_MODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	        /*Encode date_and_time */
	        ret = T_Double_Encode((&(pVal->date_and_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode ept */
	            ret = T_Double_Encode((&(pVal->ept)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode latitude */
	                ret = T_Double_Encode((&(pVal->latitude)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode epy */
	                    ret = T_Double_Encode((&(pVal->epy)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode longitude */
	                        ret = T_Double_Encode((&(pVal->longitude)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode epx */
	                            ret = T_Double_Encode((&(pVal->epx)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode altitude */
	                                ret = T_Double_Encode((&(pVal->altitude)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode epv */
	                                    ret = T_Double_Encode((&(pVal->epv)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode course */
	                                        ret = T_Double_Encode((&(pVal->course)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode epd */
	                                            ret = T_Double_Encode((&(pVal->epd)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode speed */
	                                                ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode eps */
	                                                    ret = T_Double_Encode((&(pVal->eps)), pBitStrm, pErrCode, FALSE);
	                                                    if (ret) {
	                                                        /*Encode climb */
	                                                        ret = T_Double_Encode((&(pVal->climb)), pBitStrm, pErrCode, FALSE);
	                                                        if (ret) {
	                                                            /*Encode epc */
	                                                            ret = T_Double_Encode((&(pVal->epc)), pBitStrm, pErrCode, FALSE);
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GPS_PVT_Decode(GPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mode */
	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_GPS_PVT_MODE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                pVal->mode = not_seen;
	                break;
	            case 1: 
	                pVal->mode = no_fix;
	                break;
	            case 2: 
	                pVal->mode = two_dims;
	                break;
	            case 3: 
	                pVal->mode = three_dims;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_GPS_PVT_MODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        pVal->mode = not_seen;             /*COVERAGE_IGNORE*/
	    }
	}
	if (ret) {
	    /*Decode date_and_time */
	    ret = T_Double_Decode((&(pVal->date_and_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode ept */
	        ret = T_Double_Decode((&(pVal->ept)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode latitude */
	            ret = T_Double_Decode((&(pVal->latitude)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode epy */
	                ret = T_Double_Decode((&(pVal->epy)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode longitude */
	                    ret = T_Double_Decode((&(pVal->longitude)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode epx */
	                        ret = T_Double_Decode((&(pVal->epx)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode altitude */
	                            ret = T_Double_Decode((&(pVal->altitude)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode epv */
	                                ret = T_Double_Decode((&(pVal->epv)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode course */
	                                    ret = T_Double_Decode((&(pVal->course)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode epd */
	                                        ret = T_Double_Decode((&(pVal->epd)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode speed */
	                                            ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode eps */
	                                                ret = T_Double_Decode((&(pVal->eps)), pBitStrm, pErrCode);
	                                                if (ret) {
	                                                    /*Decode climb */
	                                                    ret = T_Double_Decode((&(pVal->climb)), pBitStrm, pErrCode);
	                                                    if (ret) {
	                                                        /*Decode epc */
	                                                        ret = T_Double_Decode((&(pVal->epc)), pBitStrm, pErrCode);
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && GPS_PVT_IsConstraintValid(pVal, pErrCode);
}

flag GPS_PVT_ACN_Encode(const GPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? GPS_PVT_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mode */
	    switch(pVal->mode) { 
	        case not_seen:
	            uIntVal = 0;
	            break;
	        case no_fix:
	            uIntVal = 1;
	            break;
	        case two_dims:
	            uIntVal = 2;
	            break;
	        case three_dims:
	            uIntVal = 3;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_GPS_PVT_MODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 3);
	    }
	    if (ret) {
	        /*Encode date_and_time */
	        ret = T_Double_ACN_Encode((&(pVal->date_and_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode ept */
	            ret = T_Double_ACN_Encode((&(pVal->ept)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode latitude */
	                ret = T_Double_ACN_Encode((&(pVal->latitude)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode epy */
	                    ret = T_Double_ACN_Encode((&(pVal->epy)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode longitude */
	                        ret = T_Double_ACN_Encode((&(pVal->longitude)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode epx */
	                            ret = T_Double_ACN_Encode((&(pVal->epx)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode altitude */
	                                ret = T_Double_ACN_Encode((&(pVal->altitude)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode epv */
	                                    ret = T_Double_ACN_Encode((&(pVal->epv)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode course */
	                                        ret = T_Double_ACN_Encode((&(pVal->course)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode epd */
	                                            ret = T_Double_ACN_Encode((&(pVal->epd)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode speed */
	                                                ret = T_Double_ACN_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode eps */
	                                                    ret = T_Double_ACN_Encode((&(pVal->eps)), pBitStrm, pErrCode, FALSE);
	                                                    if (ret) {
	                                                        /*Encode climb */
	                                                        ret = T_Double_ACN_Encode((&(pVal->climb)), pBitStrm, pErrCode, FALSE);
	                                                        if (ret) {
	                                                            /*Encode epc */
	                                                            ret = T_Double_ACN_Encode((&(pVal->epc)), pBitStrm, pErrCode, FALSE);
	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GPS_PVT_ACN_Decode(GPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	/*Decode mode */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_GPS_PVT_MODE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            pVal->mode = not_seen;
	            break;
	        case 1:
	            pVal->mode = no_fix;
	            break;
	        case 2:
	            pVal->mode = two_dims;
	            break;
	        case 3:
	            pVal->mode = three_dims;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_GPS_PVT_MODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/
	if (ret) {
	    /*Decode date_and_time */
	    ret = T_Double_ACN_Decode((&(pVal->date_and_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode ept */
	        ret = T_Double_ACN_Decode((&(pVal->ept)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode latitude */
	            ret = T_Double_ACN_Decode((&(pVal->latitude)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode epy */
	                ret = T_Double_ACN_Decode((&(pVal->epy)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode longitude */
	                    ret = T_Double_ACN_Decode((&(pVal->longitude)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode epx */
	                        ret = T_Double_ACN_Decode((&(pVal->epx)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode altitude */
	                            ret = T_Double_ACN_Decode((&(pVal->altitude)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode epv */
	                                ret = T_Double_ACN_Decode((&(pVal->epv)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode course */
	                                    ret = T_Double_ACN_Decode((&(pVal->course)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode epd */
	                                        ret = T_Double_ACN_Decode((&(pVal->epd)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode speed */
	                                            ret = T_Double_ACN_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode eps */
	                                                ret = T_Double_ACN_Decode((&(pVal->eps)), pBitStrm, pErrCode);
	                                                if (ret) {
	                                                    /*Decode climb */
	                                                    ret = T_Double_ACN_Decode((&(pVal->climb)), pBitStrm, pErrCode);
	                                                    if (ret) {
	                                                        /*Decode epc */
	                                                        ret = T_Double_ACN_Decode((&(pVal->epc)), pBitStrm, pErrCode);
	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && GPS_PVT_IsConstraintValid(pVal, pErrCode);
}



flag File_Name_Equal(const File_Name* pVal1, const File_Name* pVal2)
{
	return memcmp(pVal1->arr, pVal2->arr, 81) ==0	;

}

void File_Name_Initialize(File_Name* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 81);


}

flag File_Name_IsConstraintValid(const File_Name* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag File_Name_Encode(const File_Name* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? File_Name_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)81) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag File_Name_Decode(File_Name* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)81) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILE_NAME;
	}

	return ret  && File_Name_IsConstraintValid(pVal, pErrCode);
}

flag File_Name_ACN_Encode(const File_Name* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? File_Name_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)81) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag File_Name_ACN_Decode(File_Name* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)81) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILE_NAME;
	}

    return ret && File_Name_IsConstraintValid(pVal, pErrCode);
}



flag Content_Validity_Equal(const Content_Validity* pVal1, const Content_Validity* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void Content_Validity_Initialize(Content_Validity* pVal)
{
	(void)pVal;


	(*(pVal)) = valid;
}

flag Content_Validity_IsConstraintValid(const Content_Validity* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == valid)) || (((*(pVal)) == invalid)));
    *pErrCode = ret ? 0 :  ERR_CONTENT_VALIDITY; 

	return ret;
}

flag Content_Validity_Encode(const Content_Validity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? Content_Validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case valid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case invalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CONTENT_VALIDITY; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Content_Validity_Decode(Content_Validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CONTENT_VALIDITY;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = valid;
	                break;
	            case 1: 
	                (*(pVal)) = invalid;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CONTENT_VALIDITY;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = valid;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Content_Validity_IsConstraintValid(pVal, pErrCode);
}

flag Content_Validity_ACN_Encode(const Content_Validity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? Content_Validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case valid:
	            uIntVal = 0;
	            break;
	        case invalid:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CONTENT_VALIDITY;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Content_Validity_ACN_Decode(Content_Validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CONTENT_VALIDITY;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = valid;
	            break;
	        case 1:
	            (*(pVal)) = invalid;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CONTENT_VALIDITY;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && Content_Validity_IsConstraintValid(pVal, pErrCode);
}



flag IMU_All_Data_Equal(const IMU_All_Data* pVal1, const IMU_All_Data* pVal2)
{
	flag ret=TRUE;

    ret = MGT_Raw_Data_Equal((&(pVal1->mgt_raw)), (&(pVal2->mgt_raw)));

    if (ret) {
        ret = MGT_MilliGauss_Data_Equal((&(pVal1->mgt_mgauss)), (&(pVal2->mgt_mgauss)));

        if (ret) {
            ret = ACC_Raw_Data_Equal((&(pVal1->accel_raw)), (&(pVal2->accel_raw)));

            if (ret) {
                ret = ACC_MilliG_Data_Equal((&(pVal1->accel_mg)), (&(pVal2->accel_mg)));

                if (ret) {
                    ret = GYRO_Raw_Data_Equal((&(pVal1->gyro_raw)), (&(pVal2->gyro_raw)));

                    if (ret) {
                        ret = GYRO_MilliDPS_Data_Equal((&(pVal1->gyro_mdps)), (&(pVal2->gyro_mdps)));

                        if (ret) {
                            ret = (pVal1->temp_raw == pVal2->temp_raw);

                            if (ret) {
                                ret = (pVal1->temp_celsius == pVal2->temp_celsius);

                                if (ret) {
                                    ret = (pVal1->mgt_valid == pVal2->mgt_valid);

                                    if (ret) {
                                        ret = (pVal1->acc_valid == pVal2->acc_valid);

                                        if (ret) {
                                            ret = (pVal1->gyro_valid == pVal2->gyro_valid);

                                            if (ret) {
                                                ret = (pVal1->temp_valid == pVal2->temp_valid);

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void IMU_All_Data_Initialize(IMU_All_Data* pVal)
{
	(void)pVal;



	/*set mgt_raw */
	MGT_Raw_Data_Initialize((&(pVal->mgt_raw)));
	/*set mgt_mgauss */
	MGT_MilliGauss_Data_Initialize((&(pVal->mgt_mgauss)));
	/*set accel_raw */
	ACC_Raw_Data_Initialize((&(pVal->accel_raw)));
	/*set accel_mg */
	ACC_MilliG_Data_Initialize((&(pVal->accel_mg)));
	/*set gyro_raw */
	GYRO_Raw_Data_Initialize((&(pVal->gyro_raw)));
	/*set gyro_mdps */
	GYRO_MilliDPS_Data_Initialize((&(pVal->gyro_mdps)));
	/*set temp_raw */
	T_Int16_Initialize((&(pVal->temp_raw)));
	/*set temp_celsius */
	T_Float_Initialize((&(pVal->temp_celsius)));
	/*set mgt_valid */
	Content_Validity_Initialize((&(pVal->mgt_valid)));
	/*set acc_valid */
	Content_Validity_Initialize((&(pVal->acc_valid)));
	/*set gyro_valid */
	Content_Validity_Initialize((&(pVal->gyro_valid)));
	/*set temp_valid */
	Content_Validity_Initialize((&(pVal->temp_valid)));
}

flag IMU_All_Data_IsConstraintValid(const IMU_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = MGT_Raw_Data_IsConstraintValid((&(pVal->mgt_raw)), pErrCode);
    if (ret) {
        ret = MGT_MilliGauss_Data_IsConstraintValid((&(pVal->mgt_mgauss)), pErrCode);
        if (ret) {
            ret = ACC_Raw_Data_IsConstraintValid((&(pVal->accel_raw)), pErrCode);
            if (ret) {
                ret = ACC_MilliG_Data_IsConstraintValid((&(pVal->accel_mg)), pErrCode);
                if (ret) {
                    ret = GYRO_Raw_Data_IsConstraintValid((&(pVal->gyro_raw)), pErrCode);
                    if (ret) {
                        ret = GYRO_MilliDPS_Data_IsConstraintValid((&(pVal->gyro_mdps)), pErrCode);
                        if (ret) {
                            ret = T_Int16_IsConstraintValid((&(pVal->temp_raw)), pErrCode);
                            if (ret) {
                                ret = T_Float_IsConstraintValid((&(pVal->temp_celsius)), pErrCode);
                                if (ret) {
                                    ret = Content_Validity_IsConstraintValid((&(pVal->mgt_valid)), pErrCode);
                                    if (ret) {
                                        ret = Content_Validity_IsConstraintValid((&(pVal->acc_valid)), pErrCode);
                                        if (ret) {
                                            ret = Content_Validity_IsConstraintValid((&(pVal->gyro_valid)), pErrCode);
                                            if (ret) {
                                                ret = Content_Validity_IsConstraintValid((&(pVal->temp_valid)), pErrCode);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag IMU_All_Data_Encode(const IMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? IMU_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mgt_raw */
	    ret = MGT_Raw_Data_Encode((&(pVal->mgt_raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode mgt_mgauss */
	        ret = MGT_MilliGauss_Data_Encode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode accel_raw */
	            ret = ACC_Raw_Data_Encode((&(pVal->accel_raw)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode accel_mg */
	                ret = ACC_MilliG_Data_Encode((&(pVal->accel_mg)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gyro_raw */
	                    ret = GYRO_Raw_Data_Encode((&(pVal->gyro_raw)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode gyro_mdps */
	                        ret = GYRO_MilliDPS_Data_Encode((&(pVal->gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode temp_raw */
	                            ret = T_Int16_Encode((&(pVal->temp_raw)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode temp_celsius */
	                                ret = T_Float_Encode((&(pVal->temp_celsius)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode mgt_valid */
	                                    ret = Content_Validity_Encode((&(pVal->mgt_valid)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode acc_valid */
	                                        ret = Content_Validity_Encode((&(pVal->acc_valid)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode gyro_valid */
	                                            ret = Content_Validity_Encode((&(pVal->gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode temp_valid */
	                                                ret = Content_Validity_Encode((&(pVal->temp_valid)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag IMU_All_Data_Decode(IMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mgt_raw */
	ret = MGT_Raw_Data_Decode((&(pVal->mgt_raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode mgt_mgauss */
	    ret = MGT_MilliGauss_Data_Decode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode accel_raw */
	        ret = ACC_Raw_Data_Decode((&(pVal->accel_raw)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode accel_mg */
	            ret = ACC_MilliG_Data_Decode((&(pVal->accel_mg)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gyro_raw */
	                ret = GYRO_Raw_Data_Decode((&(pVal->gyro_raw)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode gyro_mdps */
	                    ret = GYRO_MilliDPS_Data_Decode((&(pVal->gyro_mdps)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode temp_raw */
	                        ret = T_Int16_Decode((&(pVal->temp_raw)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode temp_celsius */
	                            ret = T_Float_Decode((&(pVal->temp_celsius)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode mgt_valid */
	                                ret = Content_Validity_Decode((&(pVal->mgt_valid)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode acc_valid */
	                                    ret = Content_Validity_Decode((&(pVal->acc_valid)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode gyro_valid */
	                                        ret = Content_Validity_Decode((&(pVal->gyro_valid)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode temp_valid */
	                                            ret = Content_Validity_Decode((&(pVal->temp_valid)), pBitStrm, pErrCode);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && IMU_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag IMU_All_Data_ACN_Encode(const IMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? IMU_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mgt_raw */
	    ret = MGT_Raw_Data_ACN_Encode((&(pVal->mgt_raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode mgt_mgauss */
	        ret = MGT_MilliGauss_Data_ACN_Encode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode accel_raw */
	            ret = ACC_Raw_Data_ACN_Encode((&(pVal->accel_raw)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode accel_mg */
	                ret = ACC_MilliG_Data_ACN_Encode((&(pVal->accel_mg)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gyro_raw */
	                    ret = GYRO_Raw_Data_ACN_Encode((&(pVal->gyro_raw)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode gyro_mdps */
	                        ret = GYRO_MilliDPS_Data_ACN_Encode((&(pVal->gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode temp_raw */
	                            ret = T_Int16_ACN_Encode((&(pVal->temp_raw)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode temp_celsius */
	                                ret = T_Float_ACN_Encode((&(pVal->temp_celsius)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode mgt_valid */
	                                    ret = Content_Validity_ACN_Encode((&(pVal->mgt_valid)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode acc_valid */
	                                        ret = Content_Validity_ACN_Encode((&(pVal->acc_valid)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode gyro_valid */
	                                            ret = Content_Validity_ACN_Encode((&(pVal->gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode temp_valid */
	                                                ret = Content_Validity_ACN_Encode((&(pVal->temp_valid)), pBitStrm, pErrCode, FALSE);
	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag IMU_All_Data_ACN_Decode(IMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mgt_raw */
	ret = MGT_Raw_Data_ACN_Decode((&(pVal->mgt_raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode mgt_mgauss */
	    ret = MGT_MilliGauss_Data_ACN_Decode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode accel_raw */
	        ret = ACC_Raw_Data_ACN_Decode((&(pVal->accel_raw)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode accel_mg */
	            ret = ACC_MilliG_Data_ACN_Decode((&(pVal->accel_mg)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gyro_raw */
	                ret = GYRO_Raw_Data_ACN_Decode((&(pVal->gyro_raw)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode gyro_mdps */
	                    ret = GYRO_MilliDPS_Data_ACN_Decode((&(pVal->gyro_mdps)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode temp_raw */
	                        ret = T_Int16_ACN_Decode((&(pVal->temp_raw)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode temp_celsius */
	                            ret = T_Float_ACN_Decode((&(pVal->temp_celsius)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode mgt_valid */
	                                ret = Content_Validity_ACN_Decode((&(pVal->mgt_valid)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode acc_valid */
	                                    ret = Content_Validity_ACN_Decode((&(pVal->acc_valid)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode gyro_valid */
	                                        ret = Content_Validity_ACN_Decode((&(pVal->gyro_valid)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode temp_valid */
	                                            ret = Content_Validity_ACN_Decode((&(pVal->temp_valid)), pBitStrm, pErrCode);
	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && IMU_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag TC74s_All_Data_elem_Equal(const TC74s_All_Data_elem* pVal1, const TC74s_All_Data_elem* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->temperature == pVal2->temperature);

    if (ret) {
        ret = (pVal1->validity == pVal2->validity);

    }

	return ret;

}

flag TC74s_All_Data_Equal(const TC74s_All_Data* pVal1, const TC74s_All_Data* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = TC74s_All_Data_elem_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

void TC74s_All_Data_elem_Initialize(TC74s_All_Data_elem* pVal)
{
	(void)pVal;



	/*set temperature */
	T_Float_Initialize((&(pVal->temperature)));
	/*set validity */
	Content_Validity_Initialize((&(pVal->validity)));
}
void TC74s_All_Data_Initialize(TC74s_All_Data* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 5) {
	    TC74s_All_Data_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag TC74s_All_Data_IsConstraintValid(const TC74s_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = T_Float_IsConstraintValid((&(pVal->arr[i1].temperature)), pErrCode);
    	if (ret) {
    	    ret = Content_Validity_IsConstraintValid((&(pVal->arr[i1].validity)), pErrCode);
    	}
    }

	return ret;
}

flag TC74s_All_Data_Encode(const TC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? TC74s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	/*Encode temperature */
	    	ret = T_Float_Encode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode validity */
	    	    ret = Content_Validity_Encode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC74s_All_Data_Decode(TC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		/*Decode temperature */
		ret = T_Float_Decode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode);
		if (ret) {
		    /*Decode validity */
		    ret = Content_Validity_Decode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode);
		}
	}

	return ret  && TC74s_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag TC74s_All_Data_ACN_Encode(const TC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? TC74s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	/*Encode temperature */
	    	ret = T_Float_ACN_Encode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode validity */
	    	    ret = Content_Validity_ACN_Encode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode, FALSE);
	    	}

	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC74s_All_Data_ACN_Decode(TC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		/*Decode temperature */
		ret = T_Float_ACN_Decode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode);
		if (ret) {
		    /*Decode validity */
		    ret = Content_Validity_ACN_Decode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode);
		}

	}

    return ret && TC74s_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag PT1000s_All_Data_validity_Equal(const PT1000s_All_Data_validity* pVal1, const PT1000s_All_Data_validity* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag PT1000s_All_Data_Equal(const PT1000s_All_Data* pVal1, const PT1000s_All_Data* pVal2)
{
	flag ret=TRUE;

    ret = PT1000s_Raw_Data_Equal((&(pVal1->raw)), (&(pVal2->raw)));

    if (ret) {
        ret = PT1000s_Celsius_Data_Equal((&(pVal1->celsius)), (&(pVal2->celsius)));

        if (ret) {
            ret = PT1000s_All_Data_validity_Equal((&(pVal1->validity)), (&(pVal2->validity)));

        }

    }

	return ret;

}

void PT1000s_All_Data_validity_Initialize(PT1000s_All_Data_validity* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 7) {
	    Content_Validity_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void PT1000s_All_Data_Initialize(PT1000s_All_Data* pVal)
{
	(void)pVal;



	/*set raw */
	PT1000s_Raw_Data_Initialize((&(pVal->raw)));
	/*set celsius */
	PT1000s_Celsius_Data_Initialize((&(pVal->celsius)));
	/*set validity */
	PT1000s_All_Data_validity_Initialize((&(pVal->validity)));
}

flag PT1000s_All_Data_IsConstraintValid(const PT1000s_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = PT1000s_Raw_Data_IsConstraintValid((&(pVal->raw)), pErrCode);
    if (ret) {
        ret = PT1000s_Celsius_Data_IsConstraintValid((&(pVal->celsius)), pErrCode);
        if (ret) {
            for(i1 = 0; ret && i1 < 7; i1++) 
            {
            	ret = Content_Validity_IsConstraintValid((&(pVal->validity.arr[i1])), pErrCode);
            }
        }
    }

	return ret;
}

flag PT1000s_All_Data_Encode(const PT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? PT1000s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode raw */
	    ret = PT1000s_Raw_Data_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode celsius */
	        ret = PT1000s_Celsius_Data_Encode((&(pVal->celsius)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            	
	            for(i1=0; (i1 < (int)7) && ret; i1++) 
	            {
	            	ret = Content_Validity_Encode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_All_Data_Decode(PT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode raw */
	ret = PT1000s_Raw_Data_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode celsius */
	    ret = PT1000s_Celsius_Data_Decode((&(pVal->celsius)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        	
	        for(i1=0; (i1 < (int)7) && ret; i1++) 
	        {
	        	ret = Content_Validity_Decode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && PT1000s_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag PT1000s_All_Data_ACN_Encode(const PT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? PT1000s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode raw */
	    ret = PT1000s_Raw_Data_ACN_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode celsius */
	        ret = PT1000s_Celsius_Data_ACN_Encode((&(pVal->celsius)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            	
	            for(i1=0; (i1 < (int)7) && ret; i1++) 
	            {
	            	ret = Content_Validity_ACN_Encode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_All_Data_ACN_Decode(PT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode raw */
	ret = PT1000s_Raw_Data_ACN_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode celsius */
	    ret = PT1000s_Celsius_Data_ACN_Decode((&(pVal->celsius)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        	
	        for(i1=0; (i1 < (int)7) && ret; i1++) 
	        {
	        	ret = Content_Validity_ACN_Decode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode);
	        }
	    }

	}


    return ret && PT1000s_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag Heater_Data_Equal(const Heater_Data* pVal1, const Heater_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->power_watts == pVal2->power_watts);

    if (ret) {
        ret = (pVal1->validity == pVal2->validity);

    }

	return ret;

}

void Heater_Data_Initialize(Heater_Data* pVal)
{
	(void)pVal;



	/*set power_watts */
	T_Float_Initialize((&(pVal->power_watts)));
	/*set validity */
	Content_Validity_Initialize((&(pVal->validity)));
}

flag Heater_Data_IsConstraintValid(const Heater_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Float_IsConstraintValid((&(pVal->power_watts)), pErrCode);
    if (ret) {
        ret = Content_Validity_IsConstraintValid((&(pVal->validity)), pErrCode);
    }

	return ret;
}

flag Heater_Data_Encode(const Heater_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? Heater_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode power_watts */
	    ret = T_Float_Encode((&(pVal->power_watts)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode validity */
	        ret = Content_Validity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Heater_Data_Decode(Heater_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode power_watts */
	ret = T_Float_Decode((&(pVal->power_watts)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode validity */
	    ret = Content_Validity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	}

	return ret  && Heater_Data_IsConstraintValid(pVal, pErrCode);
}

flag Heater_Data_ACN_Encode(const Heater_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? Heater_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode power_watts */
	    ret = T_Float_ACN_Encode((&(pVal->power_watts)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode validity */
	        ret = Content_Validity_ACN_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Heater_Data_ACN_Decode(Heater_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode power_watts */
	ret = T_Float_ACN_Decode((&(pVal->power_watts)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode validity */
	    ret = Content_Validity_ACN_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	}


    return ret && Heater_Data_IsConstraintValid(pVal, pErrCode);
}



flag HTL_GUI_pt1000s_validity_Equal(const HTL_GUI_pt1000s_validity* pVal1, const HTL_GUI_pt1000s_validity* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag HTL_GUI_pt1000s_Equal(const HTL_GUI_pt1000s* pVal1, const HTL_GUI_pt1000s* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->aire_abajo == pVal2->aire_abajo);

    if (ret) {
        ret = (pVal1->aire_arriba == pVal2->aire_arriba);

        if (ret) {
            ret = (pVal1->placa_abajo == pVal2->placa_abajo);

            if (ret) {
                ret = (pVal1->placa_arriba == pVal2->placa_arriba);

                if (ret) {
                    ret = (pVal1->infinito == pVal2->infinito);

                    if (ret) {
                        ret = (pVal1->exterior == pVal2->exterior);

                        if (ret) {
                            ret = (pVal1->vcc_volts == pVal2->vcc_volts);

                            if (ret) {
                                ret = HTL_GUI_pt1000s_validity_Equal((&(pVal1->validity)), (&(pVal2->validity)));

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

flag HTL_GUI_tc74s_validity_Equal(const HTL_GUI_tc74s_validity* pVal1, const HTL_GUI_tc74s_validity* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag HTL_GUI_tc74s_Equal(const HTL_GUI_tc74s* pVal1, const HTL_GUI_tc74s* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_positive == pVal2->x_positive);

    if (ret) {
        ret = (pVal1->x_negative == pVal2->x_negative);

        if (ret) {
            ret = (pVal1->y_positive == pVal2->y_positive);

            if (ret) {
                ret = (pVal1->y_negative == pVal2->y_negative);

                if (ret) {
                    ret = (pVal1->z_techo == pVal2->z_techo);

                    if (ret) {
                        ret = HTL_GUI_tc74s_validity_Equal((&(pVal1->validity)), (&(pVal2->validity)));

                    }

                }

            }

        }

    }

	return ret;

}

flag HTL_GUI_Equal(const HTL_GUI* pVal1, const HTL_GUI* pVal2)
{
	flag ret=TRUE;

    ret = Heater_Data_Equal((&(pVal1->heater)), (&(pVal2->heater)));

    if (ret) {
        ret = (pVal1->delta_T == pVal2->delta_T);

        if (ret) {
            ret = HTL_GUI_pt1000s_Equal((&(pVal1->pt1000s)), (&(pVal2->pt1000s)));

            if (ret) {
                ret = HTL_GUI_tc74s_Equal((&(pVal1->tc74s)), (&(pVal2->tc74s)));

            }

        }

    }

	return ret;

}

void HTL_GUI_pt1000s_validity_Initialize(HTL_GUI_pt1000s_validity* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 7) {
	    Content_Validity_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void HTL_GUI_pt1000s_Initialize(HTL_GUI_pt1000s* pVal)
{
	(void)pVal;



	/*set aire_abajo */
	T_Float_Initialize((&(pVal->aire_abajo)));
	/*set aire_arriba */
	T_Float_Initialize((&(pVal->aire_arriba)));
	/*set placa_abajo */
	T_Float_Initialize((&(pVal->placa_abajo)));
	/*set placa_arriba */
	T_Float_Initialize((&(pVal->placa_arriba)));
	/*set infinito */
	T_Float_Initialize((&(pVal->infinito)));
	/*set exterior */
	T_Float_Initialize((&(pVal->exterior)));
	/*set vcc_volts */
	T_Float_Initialize((&(pVal->vcc_volts)));
	/*set validity */
	HTL_GUI_pt1000s_validity_Initialize((&(pVal->validity)));
}
void HTL_GUI_tc74s_validity_Initialize(HTL_GUI_tc74s_validity* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 5) {
	    Content_Validity_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void HTL_GUI_tc74s_Initialize(HTL_GUI_tc74s* pVal)
{
	(void)pVal;



	/*set x_positive */
	T_Float_Initialize((&(pVal->x_positive)));
	/*set x_negative */
	T_Float_Initialize((&(pVal->x_negative)));
	/*set y_positive */
	T_Float_Initialize((&(pVal->y_positive)));
	/*set y_negative */
	T_Float_Initialize((&(pVal->y_negative)));
	/*set z_techo */
	T_Float_Initialize((&(pVal->z_techo)));
	/*set validity */
	HTL_GUI_tc74s_validity_Initialize((&(pVal->validity)));
}
void HTL_GUI_Initialize(HTL_GUI* pVal)
{
	(void)pVal;



	/*set heater */
	Heater_Data_Initialize((&(pVal->heater)));
	/*set delta_T */
	T_Float_Initialize((&(pVal->delta_T)));
	/*set pt1000s */
	HTL_GUI_pt1000s_Initialize((&(pVal->pt1000s)));
	/*set tc74s */
	HTL_GUI_tc74s_Initialize((&(pVal->tc74s)));
}

flag HTL_GUI_IsConstraintValid(const HTL_GUI* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = Heater_Data_IsConstraintValid((&(pVal->heater)), pErrCode);
    if (ret) {
        ret = T_Float_IsConstraintValid((&(pVal->delta_T)), pErrCode);
        if (ret) {
            ret = T_Float_IsConstraintValid((&(pVal->pt1000s.aire_abajo)), pErrCode);
            if (ret) {
                ret = T_Float_IsConstraintValid((&(pVal->pt1000s.aire_arriba)), pErrCode);
                if (ret) {
                    ret = T_Float_IsConstraintValid((&(pVal->pt1000s.placa_abajo)), pErrCode);
                    if (ret) {
                        ret = T_Float_IsConstraintValid((&(pVal->pt1000s.placa_arriba)), pErrCode);
                        if (ret) {
                            ret = T_Float_IsConstraintValid((&(pVal->pt1000s.infinito)), pErrCode);
                            if (ret) {
                                ret = T_Float_IsConstraintValid((&(pVal->pt1000s.exterior)), pErrCode);
                                if (ret) {
                                    ret = T_Float_IsConstraintValid((&(pVal->pt1000s.vcc_volts)), pErrCode);
                                    if (ret) {
                                        for(i1 = 0; ret && i1 < 7; i1++) 
                                        {
                                        	ret = Content_Validity_IsConstraintValid((&(pVal->pt1000s.validity.arr[i1])), pErrCode);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (ret) {
                ret = T_Float_IsConstraintValid((&(pVal->tc74s.x_positive)), pErrCode);
                if (ret) {
                    ret = T_Float_IsConstraintValid((&(pVal->tc74s.x_negative)), pErrCode);
                    if (ret) {
                        ret = T_Float_IsConstraintValid((&(pVal->tc74s.y_positive)), pErrCode);
                        if (ret) {
                            ret = T_Float_IsConstraintValid((&(pVal->tc74s.y_negative)), pErrCode);
                            if (ret) {
                                ret = T_Float_IsConstraintValid((&(pVal->tc74s.z_techo)), pErrCode);
                                if (ret) {
                                    for(i1 = 0; ret && i1 < 5; i1++) 
                                    {
                                    	ret = Content_Validity_IsConstraintValid((&(pVal->tc74s.validity.arr[i1])), pErrCode);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag HTL_GUI_Encode(const HTL_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? HTL_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heater */
	    ret = Heater_Data_Encode((&(pVal->heater)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode delta_T */
	        ret = T_Float_Encode((&(pVal->delta_T)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode pt1000s */
	            /*Encode aire_abajo */
	            ret = T_Float_Encode((&(pVal->pt1000s.aire_abajo)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode aire_arriba */
	                ret = T_Float_Encode((&(pVal->pt1000s.aire_arriba)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode placa_abajo */
	                    ret = T_Float_Encode((&(pVal->pt1000s.placa_abajo)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode placa_arriba */
	                        ret = T_Float_Encode((&(pVal->pt1000s.placa_arriba)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode infinito */
	                            ret = T_Float_Encode((&(pVal->pt1000s.infinito)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode exterior */
	                                ret = T_Float_Encode((&(pVal->pt1000s.exterior)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode vcc_volts */
	                                    ret = T_Float_Encode((&(pVal->pt1000s.vcc_volts)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode validity */
	                                        	
	                                        for(i1=0; (i1 < (int)7) && ret; i1++) 
	                                        {
	                                        	ret = Content_Validity_Encode((&(pVal->pt1000s.validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            if (ret) {
	                /*Encode tc74s */
	                /*Encode x_positive */
	                ret = T_Float_Encode((&(pVal->tc74s.x_positive)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode x_negative */
	                    ret = T_Float_Encode((&(pVal->tc74s.x_negative)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode y_positive */
	                        ret = T_Float_Encode((&(pVal->tc74s.y_positive)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode y_negative */
	                            ret = T_Float_Encode((&(pVal->tc74s.y_negative)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode z_techo */
	                                ret = T_Float_Encode((&(pVal->tc74s.z_techo)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode validity */
	                                    	
	                                    for(i1=0; (i1 < (int)5) && ret; i1++) 
	                                    {
	                                    	ret = Content_Validity_Encode((&(pVal->tc74s.validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag HTL_GUI_Decode(HTL_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode heater */
	ret = Heater_Data_Decode((&(pVal->heater)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode delta_T */
	    ret = T_Float_Decode((&(pVal->delta_T)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode pt1000s */
	        /*Decode aire_abajo */
	        ret = T_Float_Decode((&(pVal->pt1000s.aire_abajo)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode aire_arriba */
	            ret = T_Float_Decode((&(pVal->pt1000s.aire_arriba)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode placa_abajo */
	                ret = T_Float_Decode((&(pVal->pt1000s.placa_abajo)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode placa_arriba */
	                    ret = T_Float_Decode((&(pVal->pt1000s.placa_arriba)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode infinito */
	                        ret = T_Float_Decode((&(pVal->pt1000s.infinito)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode exterior */
	                            ret = T_Float_Decode((&(pVal->pt1000s.exterior)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode vcc_volts */
	                                ret = T_Float_Decode((&(pVal->pt1000s.vcc_volts)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode validity */
	                                    	
	                                    for(i1=0; (i1 < (int)7) && ret; i1++) 
	                                    {
	                                    	ret = Content_Validity_Decode((&(pVal->pt1000s.validity.arr[i1])), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (ret) {
	            /*Decode tc74s */
	            /*Decode x_positive */
	            ret = T_Float_Decode((&(pVal->tc74s.x_positive)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode x_negative */
	                ret = T_Float_Decode((&(pVal->tc74s.x_negative)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode y_positive */
	                    ret = T_Float_Decode((&(pVal->tc74s.y_positive)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode y_negative */
	                        ret = T_Float_Decode((&(pVal->tc74s.y_negative)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode z_techo */
	                            ret = T_Float_Decode((&(pVal->tc74s.z_techo)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode validity */
	                                	
	                                for(i1=0; (i1 < (int)5) && ret; i1++) 
	                                {
	                                	ret = Content_Validity_Decode((&(pVal->tc74s.validity.arr[i1])), pBitStrm, pErrCode);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && HTL_GUI_IsConstraintValid(pVal, pErrCode);
}

flag HTL_GUI_ACN_Encode(const HTL_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? HTL_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heater */
	    ret = Heater_Data_ACN_Encode((&(pVal->heater)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode delta_T */
	        ret = T_Float_ACN_Encode((&(pVal->delta_T)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode pt1000s */
	            /*Encode aire_abajo */
	            ret = T_Float_ACN_Encode((&(pVal->pt1000s.aire_abajo)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode aire_arriba */
	                ret = T_Float_ACN_Encode((&(pVal->pt1000s.aire_arriba)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode placa_abajo */
	                    ret = T_Float_ACN_Encode((&(pVal->pt1000s.placa_abajo)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode placa_arriba */
	                        ret = T_Float_ACN_Encode((&(pVal->pt1000s.placa_arriba)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode infinito */
	                            ret = T_Float_ACN_Encode((&(pVal->pt1000s.infinito)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode exterior */
	                                ret = T_Float_ACN_Encode((&(pVal->pt1000s.exterior)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode vcc_volts */
	                                    ret = T_Float_ACN_Encode((&(pVal->pt1000s.vcc_volts)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode validity */
	                                        	
	                                        for(i1=0; (i1 < (int)7) && ret; i1++) 
	                                        {
	                                        	ret = Content_Validity_ACN_Encode((&(pVal->pt1000s.validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	            if (ret) {
	                /*Encode tc74s */
	                /*Encode x_positive */
	                ret = T_Float_ACN_Encode((&(pVal->tc74s.x_positive)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode x_negative */
	                    ret = T_Float_ACN_Encode((&(pVal->tc74s.x_negative)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode y_positive */
	                        ret = T_Float_ACN_Encode((&(pVal->tc74s.y_positive)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode y_negative */
	                            ret = T_Float_ACN_Encode((&(pVal->tc74s.y_negative)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode z_techo */
	                                ret = T_Float_ACN_Encode((&(pVal->tc74s.z_techo)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode validity */
	                                    	
	                                    for(i1=0; (i1 < (int)5) && ret; i1++) 
	                                    {
	                                    	ret = Content_Validity_ACN_Encode((&(pVal->tc74s.validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                    }
	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag HTL_GUI_ACN_Decode(HTL_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode heater */
	ret = Heater_Data_ACN_Decode((&(pVal->heater)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode delta_T */
	    ret = T_Float_ACN_Decode((&(pVal->delta_T)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode pt1000s */
	        /*Decode aire_abajo */
	        ret = T_Float_ACN_Decode((&(pVal->pt1000s.aire_abajo)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode aire_arriba */
	            ret = T_Float_ACN_Decode((&(pVal->pt1000s.aire_arriba)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode placa_abajo */
	                ret = T_Float_ACN_Decode((&(pVal->pt1000s.placa_abajo)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode placa_arriba */
	                    ret = T_Float_ACN_Decode((&(pVal->pt1000s.placa_arriba)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode infinito */
	                        ret = T_Float_ACN_Decode((&(pVal->pt1000s.infinito)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode exterior */
	                            ret = T_Float_ACN_Decode((&(pVal->pt1000s.exterior)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode vcc_volts */
	                                ret = T_Float_ACN_Decode((&(pVal->pt1000s.vcc_volts)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode validity */
	                                    	
	                                    for(i1=0; (i1 < (int)7) && ret; i1++) 
	                                    {
	                                    	ret = Content_Validity_ACN_Decode((&(pVal->pt1000s.validity.arr[i1])), pBitStrm, pErrCode);
	                                    }
	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	        if (ret) {
	            /*Decode tc74s */
	            /*Decode x_positive */
	            ret = T_Float_ACN_Decode((&(pVal->tc74s.x_positive)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode x_negative */
	                ret = T_Float_ACN_Decode((&(pVal->tc74s.x_negative)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode y_positive */
	                    ret = T_Float_ACN_Decode((&(pVal->tc74s.y_positive)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode y_negative */
	                        ret = T_Float_ACN_Decode((&(pVal->tc74s.y_negative)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode z_techo */
	                            ret = T_Float_ACN_Decode((&(pVal->tc74s.z_techo)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode validity */
	                                	
	                                for(i1=0; (i1 < (int)5) && ret; i1++) 
	                                {
	                                	ret = Content_Validity_ACN_Decode((&(pVal->tc74s.validity.arr[i1])), pBitStrm, pErrCode);
	                                }
	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && HTL_GUI_IsConstraintValid(pVal, pErrCode);
}



flag PS_GUI_Equal(const PS_GUI* pVal1, const PS_GUI* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->pressure_mbar == pVal2->pressure_mbar);

    if (ret) {
        ret = (pVal1->temperature_celsius == pVal2->temperature_celsius);

        if (ret) {
            ret = (pVal1->validity == pVal2->validity);

        }

    }

	return ret;

}

void PS_GUI_Initialize(PS_GUI* pVal)
{
	(void)pVal;



	/*set pressure_mbar */
	T_Double_Initialize((&(pVal->pressure_mbar)));
	/*set temperature_celsius */
	T_Double_Initialize((&(pVal->temperature_celsius)));
	/*set validity */
	Content_Validity_Initialize((&(pVal->validity)));
}

flag PS_GUI_IsConstraintValid(const PS_GUI* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Double_IsConstraintValid((&(pVal->pressure_mbar)), pErrCode);
    if (ret) {
        ret = T_Double_IsConstraintValid((&(pVal->temperature_celsius)), pErrCode);
        if (ret) {
            ret = Content_Validity_IsConstraintValid((&(pVal->validity)), pErrCode);
        }
    }

	return ret;
}

flag PS_GUI_Encode(const PS_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? PS_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure_mbar */
	    ret = T_Double_Encode((&(pVal->pressure_mbar)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode temperature_celsius */
	        ret = T_Double_Encode((&(pVal->temperature_celsius)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            ret = Content_Validity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_GUI_Decode(PS_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure_mbar */
	ret = T_Double_Decode((&(pVal->pressure_mbar)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode temperature_celsius */
	    ret = T_Double_Decode((&(pVal->temperature_celsius)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        ret = Content_Validity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	    }
	}

	return ret  && PS_GUI_IsConstraintValid(pVal, pErrCode);
}

flag PS_GUI_ACN_Encode(const PS_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? PS_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure_mbar */
	    ret = T_Double_ACN_Encode((&(pVal->pressure_mbar)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode temperature_celsius */
	        ret = T_Double_ACN_Encode((&(pVal->temperature_celsius)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            ret = Content_Validity_ACN_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_GUI_ACN_Decode(PS_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure_mbar */
	ret = T_Double_ACN_Decode((&(pVal->pressure_mbar)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode temperature_celsius */
	    ret = T_Double_ACN_Decode((&(pVal->temperature_celsius)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        ret = Content_Validity_ACN_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	    }

	}


    return ret && PS_GUI_IsConstraintValid(pVal, pErrCode);
}



flag ENV_GUI_anemometer_Equal(const ENV_GUI_anemometer* pVal1, const ENV_GUI_anemometer* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->global_counter == pVal2->global_counter);

    if (ret) {
        ret = (pVal1->temperature_celsius == pVal2->temperature_celsius);

        if (ret) {
            ret = (pVal1->temperature_validity == pVal2->temperature_validity);

        }

    }

	return ret;

}

flag ENV_GUI_Equal(const ENV_GUI* pVal1, const ENV_GUI* pVal2)
{
	flag ret=TRUE;

    ret = PS_GUI_Equal((&(pVal1->pressure_sensor_1)), (&(pVal2->pressure_sensor_1)));

    if (ret) {
        ret = PS_GUI_Equal((&(pVal1->pressure_sensor_2)), (&(pVal2->pressure_sensor_2)));

        if (ret) {
            ret = ENV_GUI_anemometer_Equal((&(pVal1->anemometer)), (&(pVal2->anemometer)));

            if (ret) {
                ret = Heater_Data_Equal((&(pVal1->heater)), (&(pVal2->heater)));

            }

        }

    }

	return ret;

}

void ENV_GUI_anemometer_Initialize(ENV_GUI_anemometer* pVal)
{
	(void)pVal;



	/*set global_counter */
	T_UInt64_Initialize((&(pVal->global_counter)));
	/*set temperature_celsius */
	T_Float_Initialize((&(pVal->temperature_celsius)));
	/*set temperature_validity */
	Content_Validity_Initialize((&(pVal->temperature_validity)));
}
void ENV_GUI_Initialize(ENV_GUI* pVal)
{
	(void)pVal;



	/*set pressure_sensor_1 */
	PS_GUI_Initialize((&(pVal->pressure_sensor_1)));
	/*set pressure_sensor_2 */
	PS_GUI_Initialize((&(pVal->pressure_sensor_2)));
	/*set anemometer */
	ENV_GUI_anemometer_Initialize((&(pVal->anemometer)));
	/*set heater */
	Heater_Data_Initialize((&(pVal->heater)));
}

flag ENV_GUI_IsConstraintValid(const ENV_GUI* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = PS_GUI_IsConstraintValid((&(pVal->pressure_sensor_1)), pErrCode);
    if (ret) {
        ret = PS_GUI_IsConstraintValid((&(pVal->pressure_sensor_2)), pErrCode);
        if (ret) {
            ret = T_UInt64_IsConstraintValid((&(pVal->anemometer.global_counter)), pErrCode);
            if (ret) {
                ret = T_Float_IsConstraintValid((&(pVal->anemometer.temperature_celsius)), pErrCode);
                if (ret) {
                    ret = Content_Validity_IsConstraintValid((&(pVal->anemometer.temperature_validity)), pErrCode);
                }
            }
            if (ret) {
                ret = Heater_Data_IsConstraintValid((&(pVal->heater)), pErrCode);
            }
        }
    }

	return ret;
}

flag ENV_GUI_Encode(const ENV_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? ENV_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure_sensor_1 */
	    ret = PS_GUI_Encode((&(pVal->pressure_sensor_1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pressure_sensor_2 */
	        ret = PS_GUI_Encode((&(pVal->pressure_sensor_2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode anemometer */
	            /*Encode global_counter */
	            ret = T_UInt64_Encode((&(pVal->anemometer.global_counter)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode temperature_celsius */
	                ret = T_Float_Encode((&(pVal->anemometer.temperature_celsius)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode temperature_validity */
	                    ret = Content_Validity_Encode((&(pVal->anemometer.temperature_validity)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	            if (ret) {
	                /*Encode heater */
	                ret = Heater_Data_Encode((&(pVal->heater)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ENV_GUI_Decode(ENV_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure_sensor_1 */
	ret = PS_GUI_Decode((&(pVal->pressure_sensor_1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pressure_sensor_2 */
	    ret = PS_GUI_Decode((&(pVal->pressure_sensor_2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode anemometer */
	        /*Decode global_counter */
	        ret = T_UInt64_Decode((&(pVal->anemometer.global_counter)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode temperature_celsius */
	            ret = T_Float_Decode((&(pVal->anemometer.temperature_celsius)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode temperature_validity */
	                ret = Content_Validity_Decode((&(pVal->anemometer.temperature_validity)), pBitStrm, pErrCode);
	            }
	        }
	        if (ret) {
	            /*Decode heater */
	            ret = Heater_Data_Decode((&(pVal->heater)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && ENV_GUI_IsConstraintValid(pVal, pErrCode);
}

flag ENV_GUI_ACN_Encode(const ENV_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? ENV_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure_sensor_1 */
	    ret = PS_GUI_ACN_Encode((&(pVal->pressure_sensor_1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pressure_sensor_2 */
	        ret = PS_GUI_ACN_Encode((&(pVal->pressure_sensor_2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode anemometer */
	            /*Encode global_counter */
	            ret = T_UInt64_ACN_Encode((&(pVal->anemometer.global_counter)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode temperature_celsius */
	                ret = T_Float_ACN_Encode((&(pVal->anemometer.temperature_celsius)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode temperature_validity */
	                    ret = Content_Validity_ACN_Encode((&(pVal->anemometer.temperature_validity)), pBitStrm, pErrCode, FALSE);
	                }

	            }

	            if (ret) {
	                /*Encode heater */
	                ret = Heater_Data_ACN_Encode((&(pVal->heater)), pBitStrm, pErrCode, FALSE);
	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ENV_GUI_ACN_Decode(ENV_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure_sensor_1 */
	ret = PS_GUI_ACN_Decode((&(pVal->pressure_sensor_1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pressure_sensor_2 */
	    ret = PS_GUI_ACN_Decode((&(pVal->pressure_sensor_2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode anemometer */
	        /*Decode global_counter */
	        ret = T_UInt64_ACN_Decode((&(pVal->anemometer.global_counter)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode temperature_celsius */
	            ret = T_Float_ACN_Decode((&(pVal->anemometer.temperature_celsius)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode temperature_validity */
	                ret = Content_Validity_ACN_Decode((&(pVal->anemometer.temperature_validity)), pBitStrm, pErrCode);
	            }

	        }

	        if (ret) {
	            /*Decode heater */
	            ret = Heater_Data_ACN_Decode((&(pVal->heater)), pBitStrm, pErrCode);
	        }

	    }

	}


    return ret && ENV_GUI_IsConstraintValid(pVal, pErrCode);
}



flag Heater_On_Off_Equal(const Heater_On_Off* pVal1, const Heater_On_Off* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void Heater_On_Off_Initialize(Heater_On_Off* pVal)
{
	(void)pVal;


	(*(pVal)) = on;
}

flag Heater_On_Off_IsConstraintValid(const Heater_On_Off* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == on)) || (((*(pVal)) == off)));
    *pErrCode = ret ? 0 :  ERR_HEATER_ON_OFF; 

	return ret;
}

flag Heater_On_Off_Encode(const Heater_On_Off* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? Heater_On_Off_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case on:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case off:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_HEATER_ON_OFF; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Heater_On_Off_Decode(Heater_On_Off* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_HEATER_ON_OFF;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = on;
	                break;
	            case 1: 
	                (*(pVal)) = off;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_HEATER_ON_OFF;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = on;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Heater_On_Off_IsConstraintValid(pVal, pErrCode);
}

flag Heater_On_Off_ACN_Encode(const Heater_On_Off* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? Heater_On_Off_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case on:
	            uIntVal = 0;
	            break;
	        case off:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_HEATER_ON_OFF;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Heater_On_Off_ACN_Decode(Heater_On_Off* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_HEATER_ON_OFF;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = on;
	            break;
	        case 1:
	            (*(pVal)) = off;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_HEATER_ON_OFF;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && Heater_On_Off_IsConstraintValid(pVal, pErrCode);
}



flag T_Int32_Equal(const T_Int32* pVal1, const T_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Int32_Initialize(T_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && T_Int32_IsConstraintValid(pVal, pErrCode);
}

flag T_Int32_ACN_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_ACN_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && T_Int32_IsConstraintValid(pVal, pErrCode);
}



flag TC74s_I2CBuses_Equal(const TC74s_I2CBuses* pVal1, const TC74s_I2CBuses* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void TC74s_I2CBuses_Initialize(TC74s_I2CBuses* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 5) {
	    T_Int32_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag TC74s_I2CBuses_IsConstraintValid(const TC74s_I2CBuses* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = T_Int32_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag TC74s_I2CBuses_Encode(const TC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? TC74s_I2CBuses_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	ret = T_Int32_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC74s_I2CBuses_Decode(TC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		ret = T_Int32_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && TC74s_I2CBuses_IsConstraintValid(pVal, pErrCode);
}

flag TC74s_I2CBuses_ACN_Encode(const TC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? TC74s_I2CBuses_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	ret = T_Int32_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TC74s_I2CBuses_ACN_Decode(TC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		ret = T_Int32_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && TC74s_I2CBuses_IsConstraintValid(pVal, pErrCode);
}



flag PT1000s_Channels_Equal(const PT1000s_Channels* pVal1, const PT1000s_Channels* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void PT1000s_Channels_Initialize(PT1000s_Channels* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 7) {
	    T_Int32_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag PT1000s_Channels_IsConstraintValid(const PT1000s_Channels* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = T_Int32_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag PT1000s_Channels_Encode(const PT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? PT1000s_Channels_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	ret = T_Int32_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Channels_Decode(PT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		ret = T_Int32_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && PT1000s_Channels_IsConstraintValid(pVal, pErrCode);
}

flag PT1000s_Channels_ACN_Encode(const PT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? PT1000s_Channels_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	ret = T_Int32_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PT1000s_Channels_ACN_Decode(PT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		ret = T_Int32_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && PT1000s_Channels_IsConstraintValid(pVal, pErrCode);
}



flag PS_Processed_Data_Equal(const PS_Processed_Data* pVal1, const PS_Processed_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->pressure == pVal2->pressure);

    if (ret) {
        ret = (pVal1->temp == pVal2->temp);

    }

	return ret;

}

void PS_Processed_Data_Initialize(PS_Processed_Data* pVal)
{
	(void)pVal;



	/*set pressure */
	T_Int32_Initialize((&(pVal->pressure)));
	/*set temp */
	T_Int32_Initialize((&(pVal->temp)));
}

flag PS_Processed_Data_IsConstraintValid(const PS_Processed_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Int32_IsConstraintValid((&(pVal->pressure)), pErrCode);
    if (ret) {
        ret = T_Int32_IsConstraintValid((&(pVal->temp)), pErrCode);
    }

	return ret;
}

flag PS_Processed_Data_Encode(const PS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? PS_Processed_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure */
	    ret = T_Int32_Encode((&(pVal->pressure)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode temp */
	        ret = T_Int32_Encode((&(pVal->temp)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Processed_Data_Decode(PS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure */
	ret = T_Int32_Decode((&(pVal->pressure)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode temp */
	    ret = T_Int32_Decode((&(pVal->temp)), pBitStrm, pErrCode);
	}

	return ret  && PS_Processed_Data_IsConstraintValid(pVal, pErrCode);
}

flag PS_Processed_Data_ACN_Encode(const PS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? PS_Processed_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure */
	    ret = T_Int32_ACN_Encode((&(pVal->pressure)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode temp */
	        ret = T_Int32_ACN_Encode((&(pVal->temp)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Processed_Data_ACN_Decode(PS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure */
	ret = T_Int32_ACN_Decode((&(pVal->pressure)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode temp */
	    ret = T_Int32_ACN_Decode((&(pVal->temp)), pBitStrm, pErrCode);
	}


    return ret && PS_Processed_Data_IsConstraintValid(pVal, pErrCode);
}



flag TM_imu_Equal(const TM_imu* pVal1, const TM_imu* pVal2)
{
	flag ret=TRUE;

    ret = MGT_MilliGauss_Data_Equal((&(pVal1->mgt_mgauss)), (&(pVal2->mgt_mgauss)));

    if (ret) {
        ret = ACC_MilliG_Data_Equal((&(pVal1->accel_mg)), (&(pVal2->accel_mg)));

        if (ret) {
            ret = GYRO_MilliDPS_Data_Equal((&(pVal1->gyro_mdps)), (&(pVal2->gyro_mdps)));

            if (ret) {
                ret = (pVal1->temp_celsius == pVal2->temp_celsius);

                if (ret) {
                    ret = (pVal1->mgt_valid == pVal2->mgt_valid);

                    if (ret) {
                        ret = (pVal1->acc_valid == pVal2->acc_valid);

                        if (ret) {
                            ret = (pVal1->gyro_valid == pVal2->gyro_valid);

                            if (ret) {
                                ret = (pVal1->temp_valid == pVal2->temp_valid);

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

flag TM_Equal(const TM* pVal1, const TM* pVal2)
{
	flag ret=TRUE;

    ret = Heater_Data_Equal((&(pVal1->heater1)), (&(pVal2->heater1)));

    if (ret) {
        ret = Heater_Data_Equal((&(pVal1->heater2)), (&(pVal2->heater2)));

        if (ret) {
            ret = TC74s_All_Data_Equal((&(pVal1->tc74s)), (&(pVal2->tc74s)));

            if (ret) {
                ret = PT1000s_All_Data_Equal((&(pVal1->pt1000s)), (&(pVal2->pt1000s)));

                if (ret) {
                    ret = GPS_PVT_Equal((&(pVal1->gps)), (&(pVal2->gps)));

                    if (ret) {
                        ret = TM_imu_Equal((&(pVal1->imu)), (&(pVal2->imu)));

                        if (ret) {
                            ret = PS_Processed_Data_Equal((&(pVal1->ps1)), (&(pVal2->ps1)));

                            if (ret) {
                                ret = PS_Processed_Data_Equal((&(pVal1->ps2)), (&(pVal2->ps2)));

                                if (ret) {
                                    ret = (pVal1->ps1_validity == pVal2->ps1_validity);

                                    if (ret) {
                                        ret = (pVal1->ps2_validity == pVal2->ps2_validity);

                                        if (ret) {
                                            ret = (pVal1->anemometer == pVal2->anemometer);

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void TM_imu_Initialize(TM_imu* pVal)
{
	(void)pVal;



	/*set mgt_mgauss */
	MGT_MilliGauss_Data_Initialize((&(pVal->mgt_mgauss)));
	/*set accel_mg */
	ACC_MilliG_Data_Initialize((&(pVal->accel_mg)));
	/*set gyro_mdps */
	GYRO_MilliDPS_Data_Initialize((&(pVal->gyro_mdps)));
	/*set temp_celsius */
	T_Float_Initialize((&(pVal->temp_celsius)));
	/*set mgt_valid */
	Content_Validity_Initialize((&(pVal->mgt_valid)));
	/*set acc_valid */
	Content_Validity_Initialize((&(pVal->acc_valid)));
	/*set gyro_valid */
	Content_Validity_Initialize((&(pVal->gyro_valid)));
	/*set temp_valid */
	Content_Validity_Initialize((&(pVal->temp_valid)));
}
void TM_Initialize(TM* pVal)
{
	(void)pVal;



	/*set heater1 */
	Heater_Data_Initialize((&(pVal->heater1)));
	/*set heater2 */
	Heater_Data_Initialize((&(pVal->heater2)));
	/*set tc74s */
	TC74s_All_Data_Initialize((&(pVal->tc74s)));
	/*set pt1000s */
	PT1000s_All_Data_Initialize((&(pVal->pt1000s)));
	/*set gps */
	GPS_PVT_Initialize((&(pVal->gps)));
	/*set imu */
	TM_imu_Initialize((&(pVal->imu)));
	/*set ps1 */
	PS_Processed_Data_Initialize((&(pVal->ps1)));
	/*set ps2 */
	PS_Processed_Data_Initialize((&(pVal->ps2)));
	/*set ps1_validity */
	Content_Validity_Initialize((&(pVal->ps1_validity)));
	/*set ps2_validity */
	Content_Validity_Initialize((&(pVal->ps2_validity)));
	/*set anemometer */
	T_UInt64_Initialize((&(pVal->anemometer)));
}

flag TM_IsConstraintValid(const TM* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = Heater_Data_IsConstraintValid((&(pVal->heater1)), pErrCode);
    if (ret) {
        ret = Heater_Data_IsConstraintValid((&(pVal->heater2)), pErrCode);
        if (ret) {
            ret = TC74s_All_Data_IsConstraintValid((&(pVal->tc74s)), pErrCode);
            if (ret) {
                ret = PT1000s_All_Data_IsConstraintValid((&(pVal->pt1000s)), pErrCode);
                if (ret) {
                    ret = GPS_PVT_IsConstraintValid((&(pVal->gps)), pErrCode);
                    if (ret) {
                        ret = MGT_MilliGauss_Data_IsConstraintValid((&(pVal->imu.mgt_mgauss)), pErrCode);
                        if (ret) {
                            ret = ACC_MilliG_Data_IsConstraintValid((&(pVal->imu.accel_mg)), pErrCode);
                            if (ret) {
                                ret = GYRO_MilliDPS_Data_IsConstraintValid((&(pVal->imu.gyro_mdps)), pErrCode);
                                if (ret) {
                                    ret = T_Float_IsConstraintValid((&(pVal->imu.temp_celsius)), pErrCode);
                                    if (ret) {
                                        ret = Content_Validity_IsConstraintValid((&(pVal->imu.mgt_valid)), pErrCode);
                                        if (ret) {
                                            ret = Content_Validity_IsConstraintValid((&(pVal->imu.acc_valid)), pErrCode);
                                            if (ret) {
                                                ret = Content_Validity_IsConstraintValid((&(pVal->imu.gyro_valid)), pErrCode);
                                                if (ret) {
                                                    ret = Content_Validity_IsConstraintValid((&(pVal->imu.temp_valid)), pErrCode);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (ret) {
                            ret = PS_Processed_Data_IsConstraintValid((&(pVal->ps1)), pErrCode);
                            if (ret) {
                                ret = PS_Processed_Data_IsConstraintValid((&(pVal->ps2)), pErrCode);
                                if (ret) {
                                    ret = Content_Validity_IsConstraintValid((&(pVal->ps1_validity)), pErrCode);
                                    if (ret) {
                                        ret = Content_Validity_IsConstraintValid((&(pVal->ps2_validity)), pErrCode);
                                        if (ret) {
                                            ret = T_UInt64_IsConstraintValid((&(pVal->anemometer)), pErrCode);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag TM_Encode(const TM* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? TM_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heater1 */
	    ret = Heater_Data_Encode((&(pVal->heater1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heater2 */
	        ret = Heater_Data_Encode((&(pVal->heater2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode tc74s */
	            ret = TC74s_All_Data_Encode((&(pVal->tc74s)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode pt1000s */
	                ret = PT1000s_All_Data_Encode((&(pVal->pt1000s)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gps */
	                    ret = GPS_PVT_Encode((&(pVal->gps)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode imu */
	                        /*Encode mgt_mgauss */
	                        ret = MGT_MilliGauss_Data_Encode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode accel_mg */
	                            ret = ACC_MilliG_Data_Encode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode gyro_mdps */
	                                ret = GYRO_MilliDPS_Data_Encode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode temp_celsius */
	                                    ret = T_Float_Encode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode mgt_valid */
	                                        ret = Content_Validity_Encode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode acc_valid */
	                                            ret = Content_Validity_Encode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode gyro_valid */
	                                                ret = Content_Validity_Encode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode temp_valid */
	                                                    ret = Content_Validity_Encode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode, FALSE);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                        if (ret) {
	                            /*Encode ps1 */
	                            ret = PS_Processed_Data_Encode((&(pVal->ps1)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode ps2 */
	                                ret = PS_Processed_Data_Encode((&(pVal->ps2)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode ps1_validity */
	                                    ret = Content_Validity_Encode((&(pVal->ps1_validity)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode ps2_validity */
	                                        ret = Content_Validity_Encode((&(pVal->ps2_validity)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode anemometer */
	                                            ret = T_UInt64_Encode((&(pVal->anemometer)), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_Decode(TM* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode heater1 */
	ret = Heater_Data_Decode((&(pVal->heater1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heater2 */
	    ret = Heater_Data_Decode((&(pVal->heater2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode tc74s */
	        ret = TC74s_All_Data_Decode((&(pVal->tc74s)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode pt1000s */
	            ret = PT1000s_All_Data_Decode((&(pVal->pt1000s)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gps */
	                ret = GPS_PVT_Decode((&(pVal->gps)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode imu */
	                    /*Decode mgt_mgauss */
	                    ret = MGT_MilliGauss_Data_Decode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode accel_mg */
	                        ret = ACC_MilliG_Data_Decode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode gyro_mdps */
	                            ret = GYRO_MilliDPS_Data_Decode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode temp_celsius */
	                                ret = T_Float_Decode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode mgt_valid */
	                                    ret = Content_Validity_Decode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode acc_valid */
	                                        ret = Content_Validity_Decode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode gyro_valid */
	                                            ret = Content_Validity_Decode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode temp_valid */
	                                                ret = Content_Validity_Decode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                    if (ret) {
	                        /*Decode ps1 */
	                        ret = PS_Processed_Data_Decode((&(pVal->ps1)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode ps2 */
	                            ret = PS_Processed_Data_Decode((&(pVal->ps2)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode ps1_validity */
	                                ret = Content_Validity_Decode((&(pVal->ps1_validity)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode ps2_validity */
	                                    ret = Content_Validity_Decode((&(pVal->ps2_validity)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode anemometer */
	                                        ret = T_UInt64_Decode((&(pVal->anemometer)), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && TM_IsConstraintValid(pVal, pErrCode);
}

flag TM_ACN_Encode(const TM* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? TM_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heater1 */
	    ret = Heater_Data_ACN_Encode((&(pVal->heater1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heater2 */
	        ret = Heater_Data_ACN_Encode((&(pVal->heater2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode tc74s */
	            ret = TC74s_All_Data_ACN_Encode((&(pVal->tc74s)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode pt1000s */
	                ret = PT1000s_All_Data_ACN_Encode((&(pVal->pt1000s)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gps */
	                    ret = GPS_PVT_ACN_Encode((&(pVal->gps)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode imu */
	                        /*Encode mgt_mgauss */
	                        ret = MGT_MilliGauss_Data_ACN_Encode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode accel_mg */
	                            ret = ACC_MilliG_Data_ACN_Encode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode gyro_mdps */
	                                ret = GYRO_MilliDPS_Data_ACN_Encode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode temp_celsius */
	                                    ret = T_Float_ACN_Encode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode mgt_valid */
	                                        ret = Content_Validity_ACN_Encode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode acc_valid */
	                                            ret = Content_Validity_ACN_Encode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode gyro_valid */
	                                                ret = Content_Validity_ACN_Encode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode temp_valid */
	                                                    ret = Content_Validity_ACN_Encode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode, FALSE);
	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                        if (ret) {
	                            /*Encode ps1 */
	                            ret = PS_Processed_Data_ACN_Encode((&(pVal->ps1)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode ps2 */
	                                ret = PS_Processed_Data_ACN_Encode((&(pVal->ps2)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode ps1_validity */
	                                    ret = Content_Validity_ACN_Encode((&(pVal->ps1_validity)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode ps2_validity */
	                                        ret = Content_Validity_ACN_Encode((&(pVal->ps2_validity)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode anemometer */
	                                            ret = T_UInt64_ACN_Encode((&(pVal->anemometer)), pBitStrm, pErrCode, FALSE);
	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TM_ACN_Decode(TM* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode heater1 */
	ret = Heater_Data_ACN_Decode((&(pVal->heater1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heater2 */
	    ret = Heater_Data_ACN_Decode((&(pVal->heater2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode tc74s */
	        ret = TC74s_All_Data_ACN_Decode((&(pVal->tc74s)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode pt1000s */
	            ret = PT1000s_All_Data_ACN_Decode((&(pVal->pt1000s)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gps */
	                ret = GPS_PVT_ACN_Decode((&(pVal->gps)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode imu */
	                    /*Decode mgt_mgauss */
	                    ret = MGT_MilliGauss_Data_ACN_Decode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode accel_mg */
	                        ret = ACC_MilliG_Data_ACN_Decode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode gyro_mdps */
	                            ret = GYRO_MilliDPS_Data_ACN_Decode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode temp_celsius */
	                                ret = T_Float_ACN_Decode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode mgt_valid */
	                                    ret = Content_Validity_ACN_Decode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode acc_valid */
	                                        ret = Content_Validity_ACN_Decode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode gyro_valid */
	                                            ret = Content_Validity_ACN_Decode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode temp_valid */
	                                                ret = Content_Validity_ACN_Decode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode);
	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                    if (ret) {
	                        /*Decode ps1 */
	                        ret = PS_Processed_Data_ACN_Decode((&(pVal->ps1)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode ps2 */
	                            ret = PS_Processed_Data_ACN_Decode((&(pVal->ps2)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode ps1_validity */
	                                ret = Content_Validity_ACN_Decode((&(pVal->ps1_validity)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode ps2_validity */
	                                    ret = Content_Validity_ACN_Decode((&(pVal->ps2_validity)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode anemometer */
	                                        ret = T_UInt64_ACN_Decode((&(pVal->anemometer)), pBitStrm, pErrCode);
	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && TM_IsConstraintValid(pVal, pErrCode);
}



flag Date_Time_Equal(const Date_Time* pVal1, const Date_Time* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->day == pVal2->day);

    if (ret) {
        ret = (pVal1->month == pVal2->month);

        if (ret) {
            ret = (pVal1->year == pVal2->year);

            if (ret) {
                ret = (pVal1->hour == pVal2->hour);

                if (ret) {
                    ret = (pVal1->minute == pVal2->minute);

                    if (ret) {
                        ret = (pVal1->second == pVal2->second);

                    }

                }

            }

        }

    }

	return ret;

}

void Date_Time_Initialize(Date_Time* pVal)
{
	(void)pVal;



	/*set day */
	T_Int32_Initialize((&(pVal->day)));
	/*set month */
	T_Int32_Initialize((&(pVal->month)));
	/*set year */
	T_Int32_Initialize((&(pVal->year)));
	/*set hour */
	T_Int32_Initialize((&(pVal->hour)));
	/*set minute */
	T_Int32_Initialize((&(pVal->minute)));
	/*set second */
	T_Int32_Initialize((&(pVal->second)));
}

flag Date_Time_IsConstraintValid(const Date_Time* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_Int32_IsConstraintValid((&(pVal->day)), pErrCode);
    if (ret) {
        ret = T_Int32_IsConstraintValid((&(pVal->month)), pErrCode);
        if (ret) {
            ret = T_Int32_IsConstraintValid((&(pVal->year)), pErrCode);
            if (ret) {
                ret = T_Int32_IsConstraintValid((&(pVal->hour)), pErrCode);
                if (ret) {
                    ret = T_Int32_IsConstraintValid((&(pVal->minute)), pErrCode);
                    if (ret) {
                        ret = T_Int32_IsConstraintValid((&(pVal->second)), pErrCode);
                    }
                }
            }
        }
    }

	return ret;
}

flag Date_Time_Encode(const Date_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? Date_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode day */
	    ret = T_Int32_Encode((&(pVal->day)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode month */
	        ret = T_Int32_Encode((&(pVal->month)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode year */
	            ret = T_Int32_Encode((&(pVal->year)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode hour */
	                ret = T_Int32_Encode((&(pVal->hour)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode minute */
	                    ret = T_Int32_Encode((&(pVal->minute)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode second */
	                        ret = T_Int32_Encode((&(pVal->second)), pBitStrm, pErrCode, FALSE);
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Date_Time_Decode(Date_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode day */
	ret = T_Int32_Decode((&(pVal->day)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode month */
	    ret = T_Int32_Decode((&(pVal->month)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode year */
	        ret = T_Int32_Decode((&(pVal->year)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode hour */
	            ret = T_Int32_Decode((&(pVal->hour)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode minute */
	                ret = T_Int32_Decode((&(pVal->minute)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode second */
	                    ret = T_Int32_Decode((&(pVal->second)), pBitStrm, pErrCode);
	                }
	            }
	        }
	    }
	}

	return ret  && Date_Time_IsConstraintValid(pVal, pErrCode);
}

flag Date_Time_ACN_Encode(const Date_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? Date_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode day */
	    ret = T_Int32_ACN_Encode((&(pVal->day)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode month */
	        ret = T_Int32_ACN_Encode((&(pVal->month)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode year */
	            ret = T_Int32_ACN_Encode((&(pVal->year)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode hour */
	                ret = T_Int32_ACN_Encode((&(pVal->hour)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode minute */
	                    ret = T_Int32_ACN_Encode((&(pVal->minute)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode second */
	                        ret = T_Int32_ACN_Encode((&(pVal->second)), pBitStrm, pErrCode, FALSE);
	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Date_Time_ACN_Decode(Date_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode day */
	ret = T_Int32_ACN_Decode((&(pVal->day)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode month */
	    ret = T_Int32_ACN_Decode((&(pVal->month)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode year */
	        ret = T_Int32_ACN_Decode((&(pVal->year)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode hour */
	            ret = T_Int32_ACN_Decode((&(pVal->hour)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode minute */
	                ret = T_Int32_ACN_Decode((&(pVal->minute)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode second */
	                    ret = T_Int32_ACN_Decode((&(pVal->second)), pBitStrm, pErrCode);
	                }

	            }

	        }

	    }

	}


    return ret && Date_Time_IsConstraintValid(pVal, pErrCode);
}



flag ATT_GUI_imu_Equal(const ATT_GUI_imu* pVal1, const ATT_GUI_imu* pVal2)
{
	flag ret=TRUE;

    ret = MGT_MilliGauss_Data_Equal((&(pVal1->mgt_mgauss)), (&(pVal2->mgt_mgauss)));

    if (ret) {
        ret = ACC_MilliG_Data_Equal((&(pVal1->accel_mg)), (&(pVal2->accel_mg)));

        if (ret) {
            ret = GYRO_MilliDPS_Data_Equal((&(pVal1->gyro_mdps)), (&(pVal2->gyro_mdps)));

            if (ret) {
                ret = (pVal1->temp_celsius == pVal2->temp_celsius);

                if (ret) {
                    ret = (pVal1->mgt_valid == pVal2->mgt_valid);

                    if (ret) {
                        ret = (pVal1->acc_valid == pVal2->acc_valid);

                        if (ret) {
                            ret = (pVal1->gyro_valid == pVal2->gyro_valid);

                            if (ret) {
                                ret = (pVal1->temp_valid == pVal2->temp_valid);

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

flag ATT_GUI_Equal(const ATT_GUI* pVal1, const ATT_GUI* pVal2)
{
	flag ret=TRUE;

    ret = GPS_PVT_Equal((&(pVal1->gps)), (&(pVal2->gps)));

    if (ret) {
        ret = Date_Time_Equal((&(pVal1->gps_date_time)), (&(pVal2->gps_date_time)));

        if (ret) {
            ret = ATT_GUI_imu_Equal((&(pVal1->imu)), (&(pVal2->imu)));

        }

    }

	return ret;

}

void ATT_GUI_imu_Initialize(ATT_GUI_imu* pVal)
{
	(void)pVal;



	/*set mgt_mgauss */
	MGT_MilliGauss_Data_Initialize((&(pVal->mgt_mgauss)));
	/*set accel_mg */
	ACC_MilliG_Data_Initialize((&(pVal->accel_mg)));
	/*set gyro_mdps */
	GYRO_MilliDPS_Data_Initialize((&(pVal->gyro_mdps)));
	/*set temp_celsius */
	T_Float_Initialize((&(pVal->temp_celsius)));
	/*set mgt_valid */
	Content_Validity_Initialize((&(pVal->mgt_valid)));
	/*set acc_valid */
	Content_Validity_Initialize((&(pVal->acc_valid)));
	/*set gyro_valid */
	Content_Validity_Initialize((&(pVal->gyro_valid)));
	/*set temp_valid */
	Content_Validity_Initialize((&(pVal->temp_valid)));
}
void ATT_GUI_Initialize(ATT_GUI* pVal)
{
	(void)pVal;



	/*set gps */
	GPS_PVT_Initialize((&(pVal->gps)));
	/*set gps_date_time */
	Date_Time_Initialize((&(pVal->gps_date_time)));
	/*set imu */
	ATT_GUI_imu_Initialize((&(pVal->imu)));
}

flag ATT_GUI_IsConstraintValid(const ATT_GUI* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = GPS_PVT_IsConstraintValid((&(pVal->gps)), pErrCode);
    if (ret) {
        ret = Date_Time_IsConstraintValid((&(pVal->gps_date_time)), pErrCode);
        if (ret) {
            ret = MGT_MilliGauss_Data_IsConstraintValid((&(pVal->imu.mgt_mgauss)), pErrCode);
            if (ret) {
                ret = ACC_MilliG_Data_IsConstraintValid((&(pVal->imu.accel_mg)), pErrCode);
                if (ret) {
                    ret = GYRO_MilliDPS_Data_IsConstraintValid((&(pVal->imu.gyro_mdps)), pErrCode);
                    if (ret) {
                        ret = T_Float_IsConstraintValid((&(pVal->imu.temp_celsius)), pErrCode);
                        if (ret) {
                            ret = Content_Validity_IsConstraintValid((&(pVal->imu.mgt_valid)), pErrCode);
                            if (ret) {
                                ret = Content_Validity_IsConstraintValid((&(pVal->imu.acc_valid)), pErrCode);
                                if (ret) {
                                    ret = Content_Validity_IsConstraintValid((&(pVal->imu.gyro_valid)), pErrCode);
                                    if (ret) {
                                        ret = Content_Validity_IsConstraintValid((&(pVal->imu.temp_valid)), pErrCode);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag ATT_GUI_Encode(const ATT_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? ATT_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode gps */
	    ret = GPS_PVT_Encode((&(pVal->gps)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode gps_date_time */
	        ret = Date_Time_Encode((&(pVal->gps_date_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode imu */
	            /*Encode mgt_mgauss */
	            ret = MGT_MilliGauss_Data_Encode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode accel_mg */
	                ret = ACC_MilliG_Data_Encode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gyro_mdps */
	                    ret = GYRO_MilliDPS_Data_Encode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode temp_celsius */
	                        ret = T_Float_Encode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode mgt_valid */
	                            ret = Content_Validity_Encode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode acc_valid */
	                                ret = Content_Validity_Encode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode gyro_valid */
	                                    ret = Content_Validity_Encode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode temp_valid */
	                                        ret = Content_Validity_Encode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode, FALSE);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ATT_GUI_Decode(ATT_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode gps */
	ret = GPS_PVT_Decode((&(pVal->gps)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode gps_date_time */
	    ret = Date_Time_Decode((&(pVal->gps_date_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode imu */
	        /*Decode mgt_mgauss */
	        ret = MGT_MilliGauss_Data_Decode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode accel_mg */
	            ret = ACC_MilliG_Data_Decode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gyro_mdps */
	                ret = GYRO_MilliDPS_Data_Decode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode temp_celsius */
	                    ret = T_Float_Decode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode mgt_valid */
	                        ret = Content_Validity_Decode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode acc_valid */
	                            ret = Content_Validity_Decode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode gyro_valid */
	                                ret = Content_Validity_Decode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode temp_valid */
	                                    ret = Content_Validity_Decode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && ATT_GUI_IsConstraintValid(pVal, pErrCode);
}

flag ATT_GUI_ACN_Encode(const ATT_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? ATT_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode gps */
	    ret = GPS_PVT_ACN_Encode((&(pVal->gps)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode gps_date_time */
	        ret = Date_Time_ACN_Encode((&(pVal->gps_date_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode imu */
	            /*Encode mgt_mgauss */
	            ret = MGT_MilliGauss_Data_ACN_Encode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode accel_mg */
	                ret = ACC_MilliG_Data_ACN_Encode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gyro_mdps */
	                    ret = GYRO_MilliDPS_Data_ACN_Encode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode temp_celsius */
	                        ret = T_Float_ACN_Encode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode mgt_valid */
	                            ret = Content_Validity_ACN_Encode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode acc_valid */
	                                ret = Content_Validity_ACN_Encode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode gyro_valid */
	                                    ret = Content_Validity_ACN_Encode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode temp_valid */
	                                        ret = Content_Validity_ACN_Encode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode, FALSE);
	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ATT_GUI_ACN_Decode(ATT_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode gps */
	ret = GPS_PVT_ACN_Decode((&(pVal->gps)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode gps_date_time */
	    ret = Date_Time_ACN_Decode((&(pVal->gps_date_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode imu */
	        /*Decode mgt_mgauss */
	        ret = MGT_MilliGauss_Data_ACN_Decode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode accel_mg */
	            ret = ACC_MilliG_Data_ACN_Decode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gyro_mdps */
	                ret = GYRO_MilliDPS_Data_ACN_Decode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode temp_celsius */
	                    ret = T_Float_ACN_Decode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode mgt_valid */
	                        ret = Content_Validity_ACN_Decode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode acc_valid */
	                            ret = Content_Validity_ACN_Decode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode gyro_valid */
	                                ret = Content_Validity_ACN_Decode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode temp_valid */
	                                    ret = Content_Validity_ACN_Decode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode);
	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && ATT_GUI_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt32_Equal(const T_UInt32* pVal1, const T_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt32_Initialize(T_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && T_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt32_ACN_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_ACN_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && T_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag PS_Raw_Data_Equal(const PS_Raw_Data* pVal1, const PS_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->d1 == pVal2->d1);

    if (ret) {
        ret = (pVal1->d2 == pVal2->d2);

    }

	return ret;

}

void PS_Raw_Data_Initialize(PS_Raw_Data* pVal)
{
	(void)pVal;



	/*set d1 */
	T_UInt32_Initialize((&(pVal->d1)));
	/*set d2 */
	T_UInt32_Initialize((&(pVal->d2)));
}

flag PS_Raw_Data_IsConstraintValid(const PS_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt32_IsConstraintValid((&(pVal->d1)), pErrCode);
    if (ret) {
        ret = T_UInt32_IsConstraintValid((&(pVal->d2)), pErrCode);
    }

	return ret;
}

flag PS_Raw_Data_Encode(const PS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? PS_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode d1 */
	    ret = T_UInt32_Encode((&(pVal->d1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode d2 */
	        ret = T_UInt32_Encode((&(pVal->d2)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Raw_Data_Decode(PS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode d1 */
	ret = T_UInt32_Decode((&(pVal->d1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode d2 */
	    ret = T_UInt32_Decode((&(pVal->d2)), pBitStrm, pErrCode);
	}

	return ret  && PS_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag PS_Raw_Data_ACN_Encode(const PS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? PS_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode d1 */
	    ret = T_UInt32_ACN_Encode((&(pVal->d1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode d2 */
	        ret = T_UInt32_ACN_Encode((&(pVal->d2)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_Raw_Data_ACN_Decode(PS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode d1 */
	ret = T_UInt32_ACN_Decode((&(pVal->d1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode d2 */
	    ret = T_UInt32_ACN_Decode((&(pVal->d2)), pBitStrm, pErrCode);
	}


    return ret && PS_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag PS_All_Data_Equal(const PS_All_Data* pVal1, const PS_All_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->exist.calib == pVal2->exist.calib);
    if (ret && pVal1->exist.calib) {
    	ret = PS_Calibration_Data_Equal((&(pVal1->calib)), (&(pVal2->calib)));
    }

    if (ret) {
        ret = PS_Raw_Data_Equal((&(pVal1->raw)), (&(pVal2->raw)));

        if (ret) {
            ret = PS_Processed_Data_Equal((&(pVal1->processed)), (&(pVal2->processed)));

            if (ret) {
                ret = (pVal1->validity == pVal2->validity);

            }

        }

    }

	return ret;

}

void PS_All_Data_Initialize(PS_All_Data* pVal)
{
	(void)pVal;



	/*set calib */
	pVal->exist.calib = 1;
	PS_Calibration_Data_Initialize((&(pVal->calib)));
	/*set raw */
	PS_Raw_Data_Initialize((&(pVal->raw)));
	/*set processed */
	PS_Processed_Data_Initialize((&(pVal->processed)));
	/*set validity */
	Content_Validity_Initialize((&(pVal->validity)));
}

flag PS_All_Data_IsConstraintValid(const PS_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.calib) {
    	ret = PS_Calibration_Data_IsConstraintValid((&(pVal->calib)), pErrCode);
    }
    if (ret) {
        ret = PS_Raw_Data_IsConstraintValid((&(pVal->raw)), pErrCode);
        if (ret) {
            ret = PS_Processed_Data_IsConstraintValid((&(pVal->processed)), pErrCode);
            if (ret) {
                ret = Content_Validity_IsConstraintValid((&(pVal->validity)), pErrCode);
            }
        }
    }

	return ret;
}

flag PS_All_Data_Encode(const PS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? PS_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.calib);
	    if (ret) {
	        /*Encode calib */
	        if (pVal->exist.calib) {
	        	ret = PS_Calibration_Data_Encode((&(pVal->calib)), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode raw */
	            ret = PS_Raw_Data_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode processed */
	                ret = PS_Processed_Data_Encode((&(pVal->processed)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode validity */
	                    ret = Content_Validity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_All_Data_Decode(PS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.calib = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PS_ALL_DATA;
	if (ret) {
	    /*Decode calib */
	    if (pVal->exist.calib) {
	    	ret = PS_Calibration_Data_Decode((&(pVal->calib)), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode raw */
	        ret = PS_Raw_Data_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode processed */
	            ret = PS_Processed_Data_Decode((&(pVal->processed)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode validity */
	                ret = Content_Validity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	            }
	        }
	    }
	}

	return ret  && PS_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag PS_All_Data_ACN_Encode(const PS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? PS_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.calib);
	    if (ret) {
	        /*Encode calib */
	        if (pVal->exist.calib) {
	        	ret = PS_Calibration_Data_ACN_Encode((&(pVal->calib)), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode raw */
	            ret = PS_Raw_Data_ACN_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode processed */
	                ret = PS_Processed_Data_ACN_Encode((&(pVal->processed)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode validity */
	                    ret = Content_Validity_ACN_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PS_All_Data_ACN_Decode(PS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.calib = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PS_ALL_DATA;
	if (ret) {
	    /*Decode calib */
	    if (pVal->exist.calib) {
	    	ret = PS_Calibration_Data_ACN_Decode((&(pVal->calib)), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode raw */
	        ret = PS_Raw_Data_ACN_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode processed */
	            ret = PS_Processed_Data_ACN_Decode((&(pVal->processed)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode validity */
	                ret = Content_Validity_ACN_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	            }

	        }

	    }

	}


    return ret && PS_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag OBSW_DP_Data_gps_Equal(const OBSW_DP_Data_gps* pVal1, const OBSW_DP_Data_gps* pVal2)
{
	flag ret=TRUE;

    ret = GPS_PVT_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag OBSW_DP_Data_imu_Equal(const OBSW_DP_Data_imu* pVal1, const OBSW_DP_Data_imu* pVal2)
{
	flag ret=TRUE;

    ret = IMU_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag OBSW_DP_Data_tc74s_Equal(const OBSW_DP_Data_tc74s* pVal1, const OBSW_DP_Data_tc74s* pVal2)
{
	flag ret=TRUE;

    ret = TC74s_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag OBSW_DP_Data_pt1000s_Equal(const OBSW_DP_Data_pt1000s* pVal1, const OBSW_DP_Data_pt1000s* pVal2)
{
	flag ret=TRUE;

    ret = PT1000s_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag OBSW_DP_Data_ps1_Equal(const OBSW_DP_Data_ps1* pVal1, const OBSW_DP_Data_ps1* pVal2)
{
	flag ret=TRUE;

    ret = PS_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag OBSW_DP_Data_ps2_Equal(const OBSW_DP_Data_ps2* pVal1, const OBSW_DP_Data_ps2* pVal2)
{
	flag ret=TRUE;

    ret = PS_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag OBSW_DP_Data_heater1_Equal(const OBSW_DP_Data_heater1* pVal1, const OBSW_DP_Data_heater1* pVal2)
{
	flag ret=TRUE;

    ret = Heater_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag OBSW_DP_Data_heater2_Equal(const OBSW_DP_Data_heater2* pVal1, const OBSW_DP_Data_heater2* pVal2)
{
	flag ret=TRUE;

    ret = Heater_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag OBSW_DP_Data_anemometer_Equal(const OBSW_DP_Data_anemometer* pVal1, const OBSW_DP_Data_anemometer* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->data == pVal2->data);

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag OBSW_DP_Data_Equal(const OBSW_DP_Data* pVal1, const OBSW_DP_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->exist.gps == pVal2->exist.gps);
    if (ret && pVal1->exist.gps) {
    	ret = OBSW_DP_Data_gps_Equal((&(pVal1->gps)), (&(pVal2->gps)));
    }

    if (ret) {
        ret = (pVal1->exist.imu == pVal2->exist.imu);
        if (ret && pVal1->exist.imu) {
        	ret = OBSW_DP_Data_imu_Equal((&(pVal1->imu)), (&(pVal2->imu)));
        }

        if (ret) {
            ret = (pVal1->exist.tc74s == pVal2->exist.tc74s);
            if (ret && pVal1->exist.tc74s) {
            	ret = OBSW_DP_Data_tc74s_Equal((&(pVal1->tc74s)), (&(pVal2->tc74s)));
            }

            if (ret) {
                ret = (pVal1->exist.pt1000s == pVal2->exist.pt1000s);
                if (ret && pVal1->exist.pt1000s) {
                	ret = OBSW_DP_Data_pt1000s_Equal((&(pVal1->pt1000s)), (&(pVal2->pt1000s)));
                }

                if (ret) {
                    ret = (pVal1->exist.ps1 == pVal2->exist.ps1);
                    if (ret && pVal1->exist.ps1) {
                    	ret = OBSW_DP_Data_ps1_Equal((&(pVal1->ps1)), (&(pVal2->ps1)));
                    }

                    if (ret) {
                        ret = (pVal1->exist.ps2 == pVal2->exist.ps2);
                        if (ret && pVal1->exist.ps2) {
                        	ret = OBSW_DP_Data_ps2_Equal((&(pVal1->ps2)), (&(pVal2->ps2)));
                        }

                        if (ret) {
                            ret = (pVal1->exist.heater1 == pVal2->exist.heater1);
                            if (ret && pVal1->exist.heater1) {
                            	ret = OBSW_DP_Data_heater1_Equal((&(pVal1->heater1)), (&(pVal2->heater1)));
                            }

                            if (ret) {
                                ret = (pVal1->exist.heater2 == pVal2->exist.heater2);
                                if (ret && pVal1->exist.heater2) {
                                	ret = OBSW_DP_Data_heater2_Equal((&(pVal1->heater2)), (&(pVal2->heater2)));
                                }

                                if (ret) {
                                    ret = (pVal1->exist.anemometer == pVal2->exist.anemometer);
                                    if (ret && pVal1->exist.anemometer) {
                                    	ret = OBSW_DP_Data_anemometer_Equal((&(pVal1->anemometer)), (&(pVal2->anemometer)));
                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void OBSW_DP_Data_gps_Initialize(OBSW_DP_Data_gps* pVal)
{
	(void)pVal;



	/*set data */
	GPS_PVT_Initialize((&(pVal->data)));
	/*set gps_time */
	T_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	T_Double_Initialize((&(pVal->mission_time)));
}
void OBSW_DP_Data_imu_Initialize(OBSW_DP_Data_imu* pVal)
{
	(void)pVal;



	/*set data */
	IMU_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	T_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	T_Double_Initialize((&(pVal->mission_time)));
}
void OBSW_DP_Data_tc74s_Initialize(OBSW_DP_Data_tc74s* pVal)
{
	(void)pVal;



	/*set data */
	TC74s_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	T_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	T_Double_Initialize((&(pVal->mission_time)));
}
void OBSW_DP_Data_pt1000s_Initialize(OBSW_DP_Data_pt1000s* pVal)
{
	(void)pVal;



	/*set data */
	PT1000s_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	T_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	T_Double_Initialize((&(pVal->mission_time)));
}
void OBSW_DP_Data_ps1_Initialize(OBSW_DP_Data_ps1* pVal)
{
	(void)pVal;



	/*set data */
	PS_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	T_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	T_Double_Initialize((&(pVal->mission_time)));
}
void OBSW_DP_Data_ps2_Initialize(OBSW_DP_Data_ps2* pVal)
{
	(void)pVal;



	/*set data */
	PS_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	T_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	T_Double_Initialize((&(pVal->mission_time)));
}
void OBSW_DP_Data_heater1_Initialize(OBSW_DP_Data_heater1* pVal)
{
	(void)pVal;



	/*set data */
	Heater_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	T_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	T_Double_Initialize((&(pVal->mission_time)));
}
void OBSW_DP_Data_heater2_Initialize(OBSW_DP_Data_heater2* pVal)
{
	(void)pVal;



	/*set data */
	Heater_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	T_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	T_Double_Initialize((&(pVal->mission_time)));
}
void OBSW_DP_Data_anemometer_Initialize(OBSW_DP_Data_anemometer* pVal)
{
	(void)pVal;



	/*set data */
	T_UInt64_Initialize((&(pVal->data)));
	/*set gps_time */
	T_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	T_Double_Initialize((&(pVal->mission_time)));
}
void OBSW_DP_Data_Initialize(OBSW_DP_Data* pVal)
{
	(void)pVal;



	/*set gps */
	pVal->exist.gps = 1;
	OBSW_DP_Data_gps_Initialize((&(pVal->gps)));
	/*set imu */
	pVal->exist.imu = 1;
	OBSW_DP_Data_imu_Initialize((&(pVal->imu)));
	/*set tc74s */
	pVal->exist.tc74s = 1;
	OBSW_DP_Data_tc74s_Initialize((&(pVal->tc74s)));
	/*set pt1000s */
	pVal->exist.pt1000s = 1;
	OBSW_DP_Data_pt1000s_Initialize((&(pVal->pt1000s)));
	/*set ps1 */
	pVal->exist.ps1 = 1;
	OBSW_DP_Data_ps1_Initialize((&(pVal->ps1)));
	/*set ps2 */
	pVal->exist.ps2 = 1;
	OBSW_DP_Data_ps2_Initialize((&(pVal->ps2)));
	/*set heater1 */
	pVal->exist.heater1 = 1;
	OBSW_DP_Data_heater1_Initialize((&(pVal->heater1)));
	/*set heater2 */
	pVal->exist.heater2 = 1;
	OBSW_DP_Data_heater2_Initialize((&(pVal->heater2)));
	/*set anemometer */
	pVal->exist.anemometer = 1;
	OBSW_DP_Data_anemometer_Initialize((&(pVal->anemometer)));
}

flag OBSW_DP_Data_IsConstraintValid(const OBSW_DP_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.gps) {
    	ret = GPS_PVT_IsConstraintValid((&(pVal->gps.data)), pErrCode);
    	if (ret) {
    	    ret = T_Double_IsConstraintValid((&(pVal->gps.gps_time)), pErrCode);
    	    if (ret) {
    	        ret = T_Double_IsConstraintValid((&(pVal->gps.mission_time)), pErrCode);
    	    }
    	}
    }
    if (ret) {
        if (pVal->exist.imu) {
        	ret = IMU_All_Data_IsConstraintValid((&(pVal->imu.data)), pErrCode);
        	if (ret) {
        	    ret = T_Double_IsConstraintValid((&(pVal->imu.gps_time)), pErrCode);
        	    if (ret) {
        	        ret = T_Double_IsConstraintValid((&(pVal->imu.mission_time)), pErrCode);
        	    }
        	}
        }
        if (ret) {
            if (pVal->exist.tc74s) {
            	ret = TC74s_All_Data_IsConstraintValid((&(pVal->tc74s.data)), pErrCode);
            	if (ret) {
            	    ret = T_Double_IsConstraintValid((&(pVal->tc74s.gps_time)), pErrCode);
            	    if (ret) {
            	        ret = T_Double_IsConstraintValid((&(pVal->tc74s.mission_time)), pErrCode);
            	    }
            	}
            }
            if (ret) {
                if (pVal->exist.pt1000s) {
                	ret = PT1000s_All_Data_IsConstraintValid((&(pVal->pt1000s.data)), pErrCode);
                	if (ret) {
                	    ret = T_Double_IsConstraintValid((&(pVal->pt1000s.gps_time)), pErrCode);
                	    if (ret) {
                	        ret = T_Double_IsConstraintValid((&(pVal->pt1000s.mission_time)), pErrCode);
                	    }
                	}
                }
                if (ret) {
                    if (pVal->exist.ps1) {
                    	ret = PS_All_Data_IsConstraintValid((&(pVal->ps1.data)), pErrCode);
                    	if (ret) {
                    	    ret = T_Double_IsConstraintValid((&(pVal->ps1.gps_time)), pErrCode);
                    	    if (ret) {
                    	        ret = T_Double_IsConstraintValid((&(pVal->ps1.mission_time)), pErrCode);
                    	    }
                    	}
                    }
                    if (ret) {
                        if (pVal->exist.ps2) {
                        	ret = PS_All_Data_IsConstraintValid((&(pVal->ps2.data)), pErrCode);
                        	if (ret) {
                        	    ret = T_Double_IsConstraintValid((&(pVal->ps2.gps_time)), pErrCode);
                        	    if (ret) {
                        	        ret = T_Double_IsConstraintValid((&(pVal->ps2.mission_time)), pErrCode);
                        	    }
                        	}
                        }
                        if (ret) {
                            if (pVal->exist.heater1) {
                            	ret = Heater_Data_IsConstraintValid((&(pVal->heater1.data)), pErrCode);
                            	if (ret) {
                            	    ret = T_Double_IsConstraintValid((&(pVal->heater1.gps_time)), pErrCode);
                            	    if (ret) {
                            	        ret = T_Double_IsConstraintValid((&(pVal->heater1.mission_time)), pErrCode);
                            	    }
                            	}
                            }
                            if (ret) {
                                if (pVal->exist.heater2) {
                                	ret = Heater_Data_IsConstraintValid((&(pVal->heater2.data)), pErrCode);
                                	if (ret) {
                                	    ret = T_Double_IsConstraintValid((&(pVal->heater2.gps_time)), pErrCode);
                                	    if (ret) {
                                	        ret = T_Double_IsConstraintValid((&(pVal->heater2.mission_time)), pErrCode);
                                	    }
                                	}
                                }
                                if (ret) {
                                    if (pVal->exist.anemometer) {
                                    	ret = T_UInt64_IsConstraintValid((&(pVal->anemometer.data)), pErrCode);
                                    	if (ret) {
                                    	    ret = T_Double_IsConstraintValid((&(pVal->anemometer.gps_time)), pErrCode);
                                    	    if (ret) {
                                    	        ret = T_Double_IsConstraintValid((&(pVal->anemometer.mission_time)), pErrCode);
                                    	    }
                                    	}
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag OBSW_DP_Data_Encode(const OBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? OBSW_DP_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.gps);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.imu);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.tc74s);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.pt1000s);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.ps1);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.ps2);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.heater1);
	                            if (ret) {
	                                BitStream_AppendBit(pBitStrm,pVal->exist.heater2);
	                                if (ret) {
	                                    BitStream_AppendBit(pBitStrm,pVal->exist.anemometer);
	                                    if (ret) {
	                                        /*Encode gps */
	                                        if (pVal->exist.gps) {
	                                        	/*Encode data */
	                                        	ret = GPS_PVT_Encode((&(pVal->gps.data)), pBitStrm, pErrCode, FALSE);
	                                        	if (ret) {
	                                        	    /*Encode gps_time */
	                                        	    ret = T_Double_Encode((&(pVal->gps.gps_time)), pBitStrm, pErrCode, FALSE);
	                                        	    if (ret) {
	                                        	        /*Encode mission_time */
	                                        	        ret = T_Double_Encode((&(pVal->gps.mission_time)), pBitStrm, pErrCode, FALSE);
	                                        	    }
	                                        	}
	                                        }
	                                        if (ret) {
	                                            /*Encode imu */
	                                            if (pVal->exist.imu) {
	                                            	/*Encode data */
	                                            	ret = IMU_All_Data_Encode((&(pVal->imu.data)), pBitStrm, pErrCode, FALSE);
	                                            	if (ret) {
	                                            	    /*Encode gps_time */
	                                            	    ret = T_Double_Encode((&(pVal->imu.gps_time)), pBitStrm, pErrCode, FALSE);
	                                            	    if (ret) {
	                                            	        /*Encode mission_time */
	                                            	        ret = T_Double_Encode((&(pVal->imu.mission_time)), pBitStrm, pErrCode, FALSE);
	                                            	    }
	                                            	}
	                                            }
	                                            if (ret) {
	                                                /*Encode tc74s */
	                                                if (pVal->exist.tc74s) {
	                                                	/*Encode data */
	                                                	ret = TC74s_All_Data_Encode((&(pVal->tc74s.data)), pBitStrm, pErrCode, FALSE);
	                                                	if (ret) {
	                                                	    /*Encode gps_time */
	                                                	    ret = T_Double_Encode((&(pVal->tc74s.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                	    if (ret) {
	                                                	        /*Encode mission_time */
	                                                	        ret = T_Double_Encode((&(pVal->tc74s.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                	    }
	                                                	}
	                                                }
	                                                if (ret) {
	                                                    /*Encode pt1000s */
	                                                    if (pVal->exist.pt1000s) {
	                                                    	/*Encode data */
	                                                    	ret = PT1000s_All_Data_Encode((&(pVal->pt1000s.data)), pBitStrm, pErrCode, FALSE);
	                                                    	if (ret) {
	                                                    	    /*Encode gps_time */
	                                                    	    ret = T_Double_Encode((&(pVal->pt1000s.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                    	    if (ret) {
	                                                    	        /*Encode mission_time */
	                                                    	        ret = T_Double_Encode((&(pVal->pt1000s.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                    	    }
	                                                    	}
	                                                    }
	                                                    if (ret) {
	                                                        /*Encode ps1 */
	                                                        if (pVal->exist.ps1) {
	                                                        	/*Encode data */
	                                                        	ret = PS_All_Data_Encode((&(pVal->ps1.data)), pBitStrm, pErrCode, FALSE);
	                                                        	if (ret) {
	                                                        	    /*Encode gps_time */
	                                                        	    ret = T_Double_Encode((&(pVal->ps1.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                        	    if (ret) {
	                                                        	        /*Encode mission_time */
	                                                        	        ret = T_Double_Encode((&(pVal->ps1.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                        	    }
	                                                        	}
	                                                        }
	                                                        if (ret) {
	                                                            /*Encode ps2 */
	                                                            if (pVal->exist.ps2) {
	                                                            	/*Encode data */
	                                                            	ret = PS_All_Data_Encode((&(pVal->ps2.data)), pBitStrm, pErrCode, FALSE);
	                                                            	if (ret) {
	                                                            	    /*Encode gps_time */
	                                                            	    ret = T_Double_Encode((&(pVal->ps2.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                            	    if (ret) {
	                                                            	        /*Encode mission_time */
	                                                            	        ret = T_Double_Encode((&(pVal->ps2.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                            	    }
	                                                            	}
	                                                            }
	                                                            if (ret) {
	                                                                /*Encode heater1 */
	                                                                if (pVal->exist.heater1) {
	                                                                	/*Encode data */
	                                                                	ret = Heater_Data_Encode((&(pVal->heater1.data)), pBitStrm, pErrCode, FALSE);
	                                                                	if (ret) {
	                                                                	    /*Encode gps_time */
	                                                                	    ret = T_Double_Encode((&(pVal->heater1.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                	    if (ret) {
	                                                                	        /*Encode mission_time */
	                                                                	        ret = T_Double_Encode((&(pVal->heater1.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                	    }
	                                                                	}
	                                                                }
	                                                                if (ret) {
	                                                                    /*Encode heater2 */
	                                                                    if (pVal->exist.heater2) {
	                                                                    	/*Encode data */
	                                                                    	ret = Heater_Data_Encode((&(pVal->heater2.data)), pBitStrm, pErrCode, FALSE);
	                                                                    	if (ret) {
	                                                                    	    /*Encode gps_time */
	                                                                    	    ret = T_Double_Encode((&(pVal->heater2.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                    	    if (ret) {
	                                                                    	        /*Encode mission_time */
	                                                                    	        ret = T_Double_Encode((&(pVal->heater2.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                    	    }
	                                                                    	}
	                                                                    }
	                                                                    if (ret) {
	                                                                        /*Encode anemometer */
	                                                                        if (pVal->exist.anemometer) {
	                                                                        	/*Encode data */
	                                                                        	ret = T_UInt64_Encode((&(pVal->anemometer.data)), pBitStrm, pErrCode, FALSE);
	                                                                        	if (ret) {
	                                                                        	    /*Encode gps_time */
	                                                                        	    ret = T_Double_Encode((&(pVal->anemometer.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                        	    if (ret) {
	                                                                        	        /*Encode mission_time */
	                                                                        	        ret = T_Double_Encode((&(pVal->anemometer.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                        	    }
	                                                                        	}
	                                                                        }
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag OBSW_DP_Data_Decode(OBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.gps = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.imu = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.tc74s = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.pt1000s = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.ps1 = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.ps2 = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.heater1 = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                        if (ret) {
	                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                            pVal->exist.heater2 = presenceBit == 0 ? 0 : 1;
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                            if (ret) {
	                                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                pVal->exist.anemometer = presenceBit == 0 ? 0 : 1;
	                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                                if (ret) {
	                                    /*Decode gps */
	                                    if (pVal->exist.gps) {
	                                    	/*Decode data */
	                                    	ret = GPS_PVT_Decode((&(pVal->gps.data)), pBitStrm, pErrCode);
	                                    	if (ret) {
	                                    	    /*Decode gps_time */
	                                    	    ret = T_Double_Decode((&(pVal->gps.gps_time)), pBitStrm, pErrCode);
	                                    	    if (ret) {
	                                    	        /*Decode mission_time */
	                                    	        ret = T_Double_Decode((&(pVal->gps.mission_time)), pBitStrm, pErrCode);
	                                    	    }
	                                    	}
	                                    }
	                                    if (ret) {
	                                        /*Decode imu */
	                                        if (pVal->exist.imu) {
	                                        	/*Decode data */
	                                        	ret = IMU_All_Data_Decode((&(pVal->imu.data)), pBitStrm, pErrCode);
	                                        	if (ret) {
	                                        	    /*Decode gps_time */
	                                        	    ret = T_Double_Decode((&(pVal->imu.gps_time)), pBitStrm, pErrCode);
	                                        	    if (ret) {
	                                        	        /*Decode mission_time */
	                                        	        ret = T_Double_Decode((&(pVal->imu.mission_time)), pBitStrm, pErrCode);
	                                        	    }
	                                        	}
	                                        }
	                                        if (ret) {
	                                            /*Decode tc74s */
	                                            if (pVal->exist.tc74s) {
	                                            	/*Decode data */
	                                            	ret = TC74s_All_Data_Decode((&(pVal->tc74s.data)), pBitStrm, pErrCode);
	                                            	if (ret) {
	                                            	    /*Decode gps_time */
	                                            	    ret = T_Double_Decode((&(pVal->tc74s.gps_time)), pBitStrm, pErrCode);
	                                            	    if (ret) {
	                                            	        /*Decode mission_time */
	                                            	        ret = T_Double_Decode((&(pVal->tc74s.mission_time)), pBitStrm, pErrCode);
	                                            	    }
	                                            	}
	                                            }
	                                            if (ret) {
	                                                /*Decode pt1000s */
	                                                if (pVal->exist.pt1000s) {
	                                                	/*Decode data */
	                                                	ret = PT1000s_All_Data_Decode((&(pVal->pt1000s.data)), pBitStrm, pErrCode);
	                                                	if (ret) {
	                                                	    /*Decode gps_time */
	                                                	    ret = T_Double_Decode((&(pVal->pt1000s.gps_time)), pBitStrm, pErrCode);
	                                                	    if (ret) {
	                                                	        /*Decode mission_time */
	                                                	        ret = T_Double_Decode((&(pVal->pt1000s.mission_time)), pBitStrm, pErrCode);
	                                                	    }
	                                                	}
	                                                }
	                                                if (ret) {
	                                                    /*Decode ps1 */
	                                                    if (pVal->exist.ps1) {
	                                                    	/*Decode data */
	                                                    	ret = PS_All_Data_Decode((&(pVal->ps1.data)), pBitStrm, pErrCode);
	                                                    	if (ret) {
	                                                    	    /*Decode gps_time */
	                                                    	    ret = T_Double_Decode((&(pVal->ps1.gps_time)), pBitStrm, pErrCode);
	                                                    	    if (ret) {
	                                                    	        /*Decode mission_time */
	                                                    	        ret = T_Double_Decode((&(pVal->ps1.mission_time)), pBitStrm, pErrCode);
	                                                    	    }
	                                                    	}
	                                                    }
	                                                    if (ret) {
	                                                        /*Decode ps2 */
	                                                        if (pVal->exist.ps2) {
	                                                        	/*Decode data */
	                                                        	ret = PS_All_Data_Decode((&(pVal->ps2.data)), pBitStrm, pErrCode);
	                                                        	if (ret) {
	                                                        	    /*Decode gps_time */
	                                                        	    ret = T_Double_Decode((&(pVal->ps2.gps_time)), pBitStrm, pErrCode);
	                                                        	    if (ret) {
	                                                        	        /*Decode mission_time */
	                                                        	        ret = T_Double_Decode((&(pVal->ps2.mission_time)), pBitStrm, pErrCode);
	                                                        	    }
	                                                        	}
	                                                        }
	                                                        if (ret) {
	                                                            /*Decode heater1 */
	                                                            if (pVal->exist.heater1) {
	                                                            	/*Decode data */
	                                                            	ret = Heater_Data_Decode((&(pVal->heater1.data)), pBitStrm, pErrCode);
	                                                            	if (ret) {
	                                                            	    /*Decode gps_time */
	                                                            	    ret = T_Double_Decode((&(pVal->heater1.gps_time)), pBitStrm, pErrCode);
	                                                            	    if (ret) {
	                                                            	        /*Decode mission_time */
	                                                            	        ret = T_Double_Decode((&(pVal->heater1.mission_time)), pBitStrm, pErrCode);
	                                                            	    }
	                                                            	}
	                                                            }
	                                                            if (ret) {
	                                                                /*Decode heater2 */
	                                                                if (pVal->exist.heater2) {
	                                                                	/*Decode data */
	                                                                	ret = Heater_Data_Decode((&(pVal->heater2.data)), pBitStrm, pErrCode);
	                                                                	if (ret) {
	                                                                	    /*Decode gps_time */
	                                                                	    ret = T_Double_Decode((&(pVal->heater2.gps_time)), pBitStrm, pErrCode);
	                                                                	    if (ret) {
	                                                                	        /*Decode mission_time */
	                                                                	        ret = T_Double_Decode((&(pVal->heater2.mission_time)), pBitStrm, pErrCode);
	                                                                	    }
	                                                                	}
	                                                                }
	                                                                if (ret) {
	                                                                    /*Decode anemometer */
	                                                                    if (pVal->exist.anemometer) {
	                                                                    	/*Decode data */
	                                                                    	ret = T_UInt64_Decode((&(pVal->anemometer.data)), pBitStrm, pErrCode);
	                                                                    	if (ret) {
	                                                                    	    /*Decode gps_time */
	                                                                    	    ret = T_Double_Decode((&(pVal->anemometer.gps_time)), pBitStrm, pErrCode);
	                                                                    	    if (ret) {
	                                                                    	        /*Decode mission_time */
	                                                                    	        ret = T_Double_Decode((&(pVal->anemometer.mission_time)), pBitStrm, pErrCode);
	                                                                    	    }
	                                                                    	}
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && OBSW_DP_Data_IsConstraintValid(pVal, pErrCode);
}

flag OBSW_DP_Data_ACN_Encode(const OBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? OBSW_DP_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.gps);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.imu);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.tc74s);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.pt1000s);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.ps1);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.ps2);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.heater1);
	                            if (ret) {
	                                BitStream_AppendBit(pBitStrm,pVal->exist.heater2);
	                                if (ret) {
	                                    BitStream_AppendBit(pBitStrm,pVal->exist.anemometer);
	                                    if (ret) {
	                                        /*Encode gps */
	                                        if (pVal->exist.gps) {
	                                        	/*Encode data */
	                                        	ret = GPS_PVT_ACN_Encode((&(pVal->gps.data)), pBitStrm, pErrCode, FALSE);
	                                        	if (ret) {
	                                        	    /*Encode gps_time */
	                                        	    ret = T_Double_ACN_Encode((&(pVal->gps.gps_time)), pBitStrm, pErrCode, FALSE);
	                                        	    if (ret) {
	                                        	        /*Encode mission_time */
	                                        	        ret = T_Double_ACN_Encode((&(pVal->gps.mission_time)), pBitStrm, pErrCode, FALSE);
	                                        	    }

	                                        	}

	                                        }
	                                        if (ret) {
	                                            /*Encode imu */
	                                            if (pVal->exist.imu) {
	                                            	/*Encode data */
	                                            	ret = IMU_All_Data_ACN_Encode((&(pVal->imu.data)), pBitStrm, pErrCode, FALSE);
	                                            	if (ret) {
	                                            	    /*Encode gps_time */
	                                            	    ret = T_Double_ACN_Encode((&(pVal->imu.gps_time)), pBitStrm, pErrCode, FALSE);
	                                            	    if (ret) {
	                                            	        /*Encode mission_time */
	                                            	        ret = T_Double_ACN_Encode((&(pVal->imu.mission_time)), pBitStrm, pErrCode, FALSE);
	                                            	    }

	                                            	}

	                                            }
	                                            if (ret) {
	                                                /*Encode tc74s */
	                                                if (pVal->exist.tc74s) {
	                                                	/*Encode data */
	                                                	ret = TC74s_All_Data_ACN_Encode((&(pVal->tc74s.data)), pBitStrm, pErrCode, FALSE);
	                                                	if (ret) {
	                                                	    /*Encode gps_time */
	                                                	    ret = T_Double_ACN_Encode((&(pVal->tc74s.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                	    if (ret) {
	                                                	        /*Encode mission_time */
	                                                	        ret = T_Double_ACN_Encode((&(pVal->tc74s.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                	    }

	                                                	}

	                                                }
	                                                if (ret) {
	                                                    /*Encode pt1000s */
	                                                    if (pVal->exist.pt1000s) {
	                                                    	/*Encode data */
	                                                    	ret = PT1000s_All_Data_ACN_Encode((&(pVal->pt1000s.data)), pBitStrm, pErrCode, FALSE);
	                                                    	if (ret) {
	                                                    	    /*Encode gps_time */
	                                                    	    ret = T_Double_ACN_Encode((&(pVal->pt1000s.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                    	    if (ret) {
	                                                    	        /*Encode mission_time */
	                                                    	        ret = T_Double_ACN_Encode((&(pVal->pt1000s.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                    	    }

	                                                    	}

	                                                    }
	                                                    if (ret) {
	                                                        /*Encode ps1 */
	                                                        if (pVal->exist.ps1) {
	                                                        	/*Encode data */
	                                                        	ret = PS_All_Data_ACN_Encode((&(pVal->ps1.data)), pBitStrm, pErrCode, FALSE);
	                                                        	if (ret) {
	                                                        	    /*Encode gps_time */
	                                                        	    ret = T_Double_ACN_Encode((&(pVal->ps1.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                        	    if (ret) {
	                                                        	        /*Encode mission_time */
	                                                        	        ret = T_Double_ACN_Encode((&(pVal->ps1.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                        	    }

	                                                        	}

	                                                        }
	                                                        if (ret) {
	                                                            /*Encode ps2 */
	                                                            if (pVal->exist.ps2) {
	                                                            	/*Encode data */
	                                                            	ret = PS_All_Data_ACN_Encode((&(pVal->ps2.data)), pBitStrm, pErrCode, FALSE);
	                                                            	if (ret) {
	                                                            	    /*Encode gps_time */
	                                                            	    ret = T_Double_ACN_Encode((&(pVal->ps2.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                            	    if (ret) {
	                                                            	        /*Encode mission_time */
	                                                            	        ret = T_Double_ACN_Encode((&(pVal->ps2.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                            	    }

	                                                            	}

	                                                            }
	                                                            if (ret) {
	                                                                /*Encode heater1 */
	                                                                if (pVal->exist.heater1) {
	                                                                	/*Encode data */
	                                                                	ret = Heater_Data_ACN_Encode((&(pVal->heater1.data)), pBitStrm, pErrCode, FALSE);
	                                                                	if (ret) {
	                                                                	    /*Encode gps_time */
	                                                                	    ret = T_Double_ACN_Encode((&(pVal->heater1.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                	    if (ret) {
	                                                                	        /*Encode mission_time */
	                                                                	        ret = T_Double_ACN_Encode((&(pVal->heater1.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                	    }

	                                                                	}

	                                                                }
	                                                                if (ret) {
	                                                                    /*Encode heater2 */
	                                                                    if (pVal->exist.heater2) {
	                                                                    	/*Encode data */
	                                                                    	ret = Heater_Data_ACN_Encode((&(pVal->heater2.data)), pBitStrm, pErrCode, FALSE);
	                                                                    	if (ret) {
	                                                                    	    /*Encode gps_time */
	                                                                    	    ret = T_Double_ACN_Encode((&(pVal->heater2.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                    	    if (ret) {
	                                                                    	        /*Encode mission_time */
	                                                                    	        ret = T_Double_ACN_Encode((&(pVal->heater2.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                    	    }

	                                                                    	}

	                                                                    }
	                                                                    if (ret) {
	                                                                        /*Encode anemometer */
	                                                                        if (pVal->exist.anemometer) {
	                                                                        	/*Encode data */
	                                                                        	ret = T_UInt64_ACN_Encode((&(pVal->anemometer.data)), pBitStrm, pErrCode, FALSE);
	                                                                        	if (ret) {
	                                                                        	    /*Encode gps_time */
	                                                                        	    ret = T_Double_ACN_Encode((&(pVal->anemometer.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                        	    if (ret) {
	                                                                        	        /*Encode mission_time */
	                                                                        	        ret = T_Double_ACN_Encode((&(pVal->anemometer.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                        	    }

	                                                                        	}

	                                                                        }
	                                                                    }

	                                                                }

	                                                            }

	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag OBSW_DP_Data_ACN_Decode(OBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.gps = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.imu = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.tc74s = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.pt1000s = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.ps1 = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.ps2 = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.heater1 = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                        if (ret) {
	                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                            pVal->exist.heater2 = presenceBit == 0 ? 0 : 1;
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                            if (ret) {
	                                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                pVal->exist.anemometer = presenceBit == 0 ? 0 : 1;
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                                if (ret) {
	                                    /*Decode gps */
	                                    if (pVal->exist.gps) {
	                                    	/*Decode data */
	                                    	ret = GPS_PVT_ACN_Decode((&(pVal->gps.data)), pBitStrm, pErrCode);
	                                    	if (ret) {
	                                    	    /*Decode gps_time */
	                                    	    ret = T_Double_ACN_Decode((&(pVal->gps.gps_time)), pBitStrm, pErrCode);
	                                    	    if (ret) {
	                                    	        /*Decode mission_time */
	                                    	        ret = T_Double_ACN_Decode((&(pVal->gps.mission_time)), pBitStrm, pErrCode);
	                                    	    }

	                                    	}

	                                    }
	                                    if (ret) {
	                                        /*Decode imu */
	                                        if (pVal->exist.imu) {
	                                        	/*Decode data */
	                                        	ret = IMU_All_Data_ACN_Decode((&(pVal->imu.data)), pBitStrm, pErrCode);
	                                        	if (ret) {
	                                        	    /*Decode gps_time */
	                                        	    ret = T_Double_ACN_Decode((&(pVal->imu.gps_time)), pBitStrm, pErrCode);
	                                        	    if (ret) {
	                                        	        /*Decode mission_time */
	                                        	        ret = T_Double_ACN_Decode((&(pVal->imu.mission_time)), pBitStrm, pErrCode);
	                                        	    }

	                                        	}

	                                        }
	                                        if (ret) {
	                                            /*Decode tc74s */
	                                            if (pVal->exist.tc74s) {
	                                            	/*Decode data */
	                                            	ret = TC74s_All_Data_ACN_Decode((&(pVal->tc74s.data)), pBitStrm, pErrCode);
	                                            	if (ret) {
	                                            	    /*Decode gps_time */
	                                            	    ret = T_Double_ACN_Decode((&(pVal->tc74s.gps_time)), pBitStrm, pErrCode);
	                                            	    if (ret) {
	                                            	        /*Decode mission_time */
	                                            	        ret = T_Double_ACN_Decode((&(pVal->tc74s.mission_time)), pBitStrm, pErrCode);
	                                            	    }

	                                            	}

	                                            }
	                                            if (ret) {
	                                                /*Decode pt1000s */
	                                                if (pVal->exist.pt1000s) {
	                                                	/*Decode data */
	                                                	ret = PT1000s_All_Data_ACN_Decode((&(pVal->pt1000s.data)), pBitStrm, pErrCode);
	                                                	if (ret) {
	                                                	    /*Decode gps_time */
	                                                	    ret = T_Double_ACN_Decode((&(pVal->pt1000s.gps_time)), pBitStrm, pErrCode);
	                                                	    if (ret) {
	                                                	        /*Decode mission_time */
	                                                	        ret = T_Double_ACN_Decode((&(pVal->pt1000s.mission_time)), pBitStrm, pErrCode);
	                                                	    }

	                                                	}

	                                                }
	                                                if (ret) {
	                                                    /*Decode ps1 */
	                                                    if (pVal->exist.ps1) {
	                                                    	/*Decode data */
	                                                    	ret = PS_All_Data_ACN_Decode((&(pVal->ps1.data)), pBitStrm, pErrCode);
	                                                    	if (ret) {
	                                                    	    /*Decode gps_time */
	                                                    	    ret = T_Double_ACN_Decode((&(pVal->ps1.gps_time)), pBitStrm, pErrCode);
	                                                    	    if (ret) {
	                                                    	        /*Decode mission_time */
	                                                    	        ret = T_Double_ACN_Decode((&(pVal->ps1.mission_time)), pBitStrm, pErrCode);
	                                                    	    }

	                                                    	}

	                                                    }
	                                                    if (ret) {
	                                                        /*Decode ps2 */
	                                                        if (pVal->exist.ps2) {
	                                                        	/*Decode data */
	                                                        	ret = PS_All_Data_ACN_Decode((&(pVal->ps2.data)), pBitStrm, pErrCode);
	                                                        	if (ret) {
	                                                        	    /*Decode gps_time */
	                                                        	    ret = T_Double_ACN_Decode((&(pVal->ps2.gps_time)), pBitStrm, pErrCode);
	                                                        	    if (ret) {
	                                                        	        /*Decode mission_time */
	                                                        	        ret = T_Double_ACN_Decode((&(pVal->ps2.mission_time)), pBitStrm, pErrCode);
	                                                        	    }

	                                                        	}

	                                                        }
	                                                        if (ret) {
	                                                            /*Decode heater1 */
	                                                            if (pVal->exist.heater1) {
	                                                            	/*Decode data */
	                                                            	ret = Heater_Data_ACN_Decode((&(pVal->heater1.data)), pBitStrm, pErrCode);
	                                                            	if (ret) {
	                                                            	    /*Decode gps_time */
	                                                            	    ret = T_Double_ACN_Decode((&(pVal->heater1.gps_time)), pBitStrm, pErrCode);
	                                                            	    if (ret) {
	                                                            	        /*Decode mission_time */
	                                                            	        ret = T_Double_ACN_Decode((&(pVal->heater1.mission_time)), pBitStrm, pErrCode);
	                                                            	    }

	                                                            	}

	                                                            }
	                                                            if (ret) {
	                                                                /*Decode heater2 */
	                                                                if (pVal->exist.heater2) {
	                                                                	/*Decode data */
	                                                                	ret = Heater_Data_ACN_Decode((&(pVal->heater2.data)), pBitStrm, pErrCode);
	                                                                	if (ret) {
	                                                                	    /*Decode gps_time */
	                                                                	    ret = T_Double_ACN_Decode((&(pVal->heater2.gps_time)), pBitStrm, pErrCode);
	                                                                	    if (ret) {
	                                                                	        /*Decode mission_time */
	                                                                	        ret = T_Double_ACN_Decode((&(pVal->heater2.mission_time)), pBitStrm, pErrCode);
	                                                                	    }

	                                                                	}

	                                                                }
	                                                                if (ret) {
	                                                                    /*Decode anemometer */
	                                                                    if (pVal->exist.anemometer) {
	                                                                    	/*Decode data */
	                                                                    	ret = T_UInt64_ACN_Decode((&(pVal->anemometer.data)), pBitStrm, pErrCode);
	                                                                    	if (ret) {
	                                                                    	    /*Decode gps_time */
	                                                                    	    ret = T_Double_ACN_Decode((&(pVal->anemometer.gps_time)), pBitStrm, pErrCode);
	                                                                    	    if (ret) {
	                                                                    	        /*Decode mission_time */
	                                                                    	        ret = T_Double_ACN_Decode((&(pVal->anemometer.mission_time)), pBitStrm, pErrCode);
	                                                                    	    }

	                                                                    	}

	                                                                    }
	                                                                }

	                                                            }

	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && OBSW_DP_Data_IsConstraintValid(pVal, pErrCode);
}



flag T_Int8_Equal(const T_Int8* pVal1, const T_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Int8_Initialize(T_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && T_Int8_IsConstraintValid(pVal, pErrCode);
}

flag T_Int8_ACN_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_ACN_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && T_Int8_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt8_Equal(const T_UInt8* pVal1, const T_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_UInt8_Initialize(T_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && T_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt8_ACN_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_ACN_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && T_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag SPI_ID_Equal(const SPI_ID* pVal1, const SPI_ID* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->bus == pVal2->bus);

    if (ret) {
        ret = (pVal1->cs == pVal2->cs);

    }

	return ret;

}

void SPI_ID_Initialize(SPI_ID* pVal)
{
	(void)pVal;



	/*set bus */
	T_UInt8_Initialize((&(pVal->bus)));
	/*set cs */
	T_UInt8_Initialize((&(pVal->cs)));
}

flag SPI_ID_IsConstraintValid(const SPI_ID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt8_IsConstraintValid((&(pVal->bus)), pErrCode);
    if (ret) {
        ret = T_UInt8_IsConstraintValid((&(pVal->cs)), pErrCode);
    }

	return ret;
}

flag SPI_ID_Encode(const SPI_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? SPI_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = T_UInt8_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode cs */
	        ret = T_UInt8_Encode((&(pVal->cs)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SPI_ID_Decode(SPI_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = T_UInt8_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode cs */
	    ret = T_UInt8_Decode((&(pVal->cs)), pBitStrm, pErrCode);
	}

	return ret  && SPI_ID_IsConstraintValid(pVal, pErrCode);
}

flag SPI_ID_ACN_Encode(const SPI_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? SPI_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = T_UInt8_ACN_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode cs */
	        ret = T_UInt8_ACN_Encode((&(pVal->cs)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SPI_ID_ACN_Decode(SPI_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = T_UInt8_ACN_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode cs */
	    ret = T_UInt8_ACN_Decode((&(pVal->cs)), pBitStrm, pErrCode);
	}


    return ret && SPI_ID_IsConstraintValid(pVal, pErrCode);
}



flag I2C_ID_Equal(const I2C_ID* pVal1, const I2C_ID* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->bus == pVal2->bus);

    if (ret) {
        ret = (pVal1->address == pVal2->address);

    }

	return ret;

}

void I2C_ID_Initialize(I2C_ID* pVal)
{
	(void)pVal;



	/*set bus */
	T_UInt8_Initialize((&(pVal->bus)));
	/*set address */
	T_UInt8_Initialize((&(pVal->address)));
}

flag I2C_ID_IsConstraintValid(const I2C_ID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt8_IsConstraintValid((&(pVal->bus)), pErrCode);
    if (ret) {
        ret = T_UInt8_IsConstraintValid((&(pVal->address)), pErrCode);
    }

	return ret;
}

flag I2C_ID_Encode(const I2C_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? I2C_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = T_UInt8_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode address */
	        ret = T_UInt8_Encode((&(pVal->address)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag I2C_ID_Decode(I2C_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = T_UInt8_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode address */
	    ret = T_UInt8_Decode((&(pVal->address)), pBitStrm, pErrCode);
	}

	return ret  && I2C_ID_IsConstraintValid(pVal, pErrCode);
}

flag I2C_ID_ACN_Encode(const I2C_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? I2C_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = T_UInt8_ACN_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode address */
	        ret = T_UInt8_ACN_Encode((&(pVal->address)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag I2C_ID_ACN_Decode(I2C_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = T_UInt8_ACN_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode address */
	    ret = T_UInt8_ACN_Decode((&(pVal->address)), pBitStrm, pErrCode);
	}


    return ret && I2C_ID_IsConstraintValid(pVal, pErrCode);
}



flag T_Boolean_Equal(const T_Boolean* pVal1, const T_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void T_Boolean_Initialize(T_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && T_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag T_Boolean_ACN_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_ACN_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && T_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag T_Null_Record_Equal(const T_Null_Record* pVal1, const T_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

void T_Null_Record_Initialize(T_Null_Record* pVal)
{
	(void)pVal;


}

flag T_Null_Record_IsConstraintValid(const T_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag T_Null_Record_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag T_Null_Record_ACN_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_ACN_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}

