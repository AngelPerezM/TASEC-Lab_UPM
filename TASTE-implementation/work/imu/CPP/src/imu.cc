// Body file for function IMU
// Generated by TASTE on 2021-05-18 16:35:43
// You can edit this file, it will not be overwritten
// Provided interfaces : readAccelData, readGyroData, readMGTdata
// Required interfaces : 
// User-defined properties for this function:
//   |_ Taste::Active_Interfaces = any
//   |_ Taste::coordinates = 120468 142358 146108 157161
// Timers              : 

#include "imu.h"
#include "imu_state.h"
#include <iostream>

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere
imu_state ctxt_imu;

// All component interfaces
///////////////////////////////////////////////////////////////////////////////

void imu_startup(void)
{
   // Write your initialisation code, but DO NOT CALL REQUIRED INTERFACES
    std::cout << "[IMU] Startup" << std::endl;
}

void imu_PI_readIMUdata( asn1SccIMU_All_Data *OUT_all_data)
{
    int16_t x, y, z;
    bool valid = false;
    
    // Accel:
    valid = ctxt_imu.imu.accAndGyro.isAccelAvailable();
    OUT_all_data->acc_valid = valid ? asn1Sccvalid : asn1Sccinvalid;
    if (valid) {
        ctxt_imu.imu.accAndGyro.readRawAccel(x, y, z);    
        OUT_all_data->accel_raw.x_axis = x;
        OUT_all_data->accel_raw.y_axis = y;
        OUT_all_data->accel_raw.z_axis = z;
        OUT_all_data->accel_mg.x_axis = 
                            float(x) * ctxt_imu.imu.accAndGyro.getAccelSensitivity();
        OUT_all_data->accel_mg.y_axis = 
                            float(y) * ctxt_imu.imu.accAndGyro.getAccelSensitivity();
        OUT_all_data->accel_mg.z_axis = 
                            float(z) * ctxt_imu.imu.accAndGyro.getAccelSensitivity();     
        std::cout << "accel OK" << std::endl;
    }
 
    // Gyro:
    valid = ctxt_imu.imu.accAndGyro.isGyroAvailable();
    OUT_all_data->gyro_valid = valid ? asn1Sccvalid : asn1Sccinvalid;
    if (valid) {
        ctxt_imu.imu.accAndGyro.readRawGyro(x, y, z);
        OUT_all_data->gyro_raw.x_axis = x;
        OUT_all_data->gyro_raw.y_axis = y;
        OUT_all_data->gyro_raw.z_axis = z;    
        OUT_all_data->gyro_mdps.x_axis = float(x) * ctxt_imu.imu.accAndGyro.getGyroSensitivity();
        OUT_all_data->gyro_mdps.y_axis = float(y) * ctxt_imu.imu.accAndGyro.getGyroSensitivity();
        OUT_all_data->gyro_mdps.z_axis = float(z) * ctxt_imu.imu.accAndGyro.getGyroSensitivity();
        std::cout << "gyro OK" << std::endl;
    }
    
    // MGT:
    valid = ctxt_imu.imu.magnetometer.isDataAvailable(1) ||
            ctxt_imu.imu.magnetometer.isDataAvailable(2) ||
            ctxt_imu.imu.magnetometer.isDataAvailable(3);
    OUT_all_data->mgt_valid = valid ? asn1Sccvalid : asn1Sccinvalid;
    if (valid) {
        ctxt_imu.imu.magnetometer.readRawData(x, y, z);
        OUT_all_data->mgt_raw.x_axis = x;
        OUT_all_data->mgt_raw.y_axis = y;
        OUT_all_data->mgt_raw.z_axis = z;    
        OUT_all_data->mgt_mgauss.x_axis = float(x) * ctxt_imu.imu.magnetometer.getSensitivity();
        OUT_all_data->mgt_mgauss.y_axis = float(y) * ctxt_imu.imu.magnetometer.getSensitivity();
        OUT_all_data->mgt_mgauss.z_axis = float(z) * ctxt_imu.imu.magnetometer.getSensitivity();    
        std::cout << "MGT OK" << std::endl;
    }
    
    // Temp:
    valid = ctxt_imu.imu.accAndGyro.isTempAvailable();
    OUT_all_data->temp_valid = valid ? asn1Sccvalid : asn1Sccinvalid;
    if (valid) {
        OUT_all_data->temp_raw = ctxt_imu.imu.accAndGyro.readRawTemp();
        OUT_all_data->temp_celsius = ( (((float) OUT_all_data->temp_raw) / 16.384f) + 25.0f );
        std::cout << "IMU: TEMP OK" << std::endl;
    }
}
