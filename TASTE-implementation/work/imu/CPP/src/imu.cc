// Body file for function IMU
// Generated by TASTE on 2021-05-18 16:35:43
// You can edit this file, it will not be overwritten
// Provided interfaces : readAccelData, readGyroData, readMGTdata
// Required interfaces : 
// User-defined properties for this function:
//   |_ Taste::Active_Interfaces = any
//   |_ Taste::coordinates = 120468 142358 146108 157161
// Timers              : 

#include "imu.h"
#include "imu_state.h"
#include <iostream>

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere
imu_state ctxt_imu;
static bool stopped_imu = false;

static bool isFIFOEmpty () {
    return (ctxt_imu.imu.accAndGyro.getNSamplesFIFO() == 0);
}

// All component interfaces
///////////////////////////////////////////////////////////////////////////////

void imu_startup(void)
{
   // Write your initialisation code, but DO NOT CALL REQUIRED INTERFACES
    std::cout << "[IMU] Startup" << std::endl;
    // Turn on FIFO and set threshold to 32 samples.
    ctxt_imu.imu.accAndGyro.enableFIFO();
    usleep(50000);
    ctxt_imu.imu.accAndGyro.setFIFO(6, ctxt_imu.fifo_capacity); // FIFO, overwrite (25 samples).
}

void imu_PI_readMgt( asn1SccMGT_MilliGauss_Data *mgauss, asn1SccMGT_Raw_Data *raw,
                     asn1SccContent_Validity * validity)
{
    if (stopped_imu) {
        return;
    }
    
    int16_t x, y, z;
    bool valid = false;
    
    // MGT:
    valid = ctxt_imu.imu.magnetometer.isDataAvailable();
    *validity = valid ? asn1Sccvalid : asn1Sccinvalid;
    if (valid) {
        ctxt_imu.imu.magnetometer.readRawData(x, y, z);
        raw->x_axis = x;
        raw->y_axis = y;
        raw->z_axis = z;    
        mgauss->x_axis = float(x) * ctxt_imu.imu.magnetometer.getSensitivity();
        mgauss->y_axis = float(y) * ctxt_imu.imu.magnetometer.getSensitivity();
        mgauss->z_axis = float(z) * ctxt_imu.imu.magnetometer.getSensitivity();
    }
}

void imu_PI_readTemp( asn1SccT_Float *celsius, asn1SccT_Int16 *raw,
                      asn1SccContent_Validity * validity)
{
    if (stopped_imu) {
        return;
    }

    // Temp:
    bool valid = ctxt_imu.imu.accAndGyro.isTempAvailable();
    *validity = valid ? asn1Sccvalid : asn1Sccinvalid;
    if (valid) {
        *raw = ctxt_imu.imu.accAndGyro.readRawTemp();
        *celsius = ( (((float) *raw) / 16.384f) + 25.0f );
    }
    
}

void imu_PI_readAccel( asn1SccACC_MilliG_Data *acc_mg, asn1SccACC_Raw_Data *acc_raw,
                       asn1SccContent_Validity * acc_validity )
{
    if (stopped_imu) {
        return;
    }
    
    int16_t x, y, z;
    bool valid = false;

    // Accel:
    valid = ctxt_imu.imu.accAndGyro.isAccelAvailable() || !isFIFOEmpty();
    *acc_validity = valid ? asn1Sccvalid : asn1Sccinvalid;
    if (valid) {
        ctxt_imu.imu.accAndGyro.readRawAccel(x, y, z);    
        acc_raw->x_axis = x;
        acc_raw->y_axis = y;
        acc_raw->z_axis = z;
        
        acc_mg->x_axis = float(x) * ctxt_imu.imu.accAndGyro.getAccelSensitivity();
        acc_mg->y_axis = float(y) * ctxt_imu.imu.accAndGyro.getAccelSensitivity();
        acc_mg->z_axis = float(z) * ctxt_imu.imu.accAndGyro.getAccelSensitivity();
    }
}


void imu_PI_readGyro( asn1SccGYRO_MilliDPS_Data *gyro_mdps, asn1SccGYRO_Raw_Data *gyro_raw,
                      asn1SccContent_Validity *gyro_validity )
{
    if (stopped_imu) {
        return;
    }
        
    int16_t x, y, z;
    bool valid = false;
    
    valid = ctxt_imu.imu.accAndGyro.isGyroAvailable() || !isFIFOEmpty();
    *gyro_validity = valid ? asn1Sccvalid : asn1Sccinvalid;
    if (valid) {
        ctxt_imu.imu.accAndGyro.readRawGyro(x, y, z);
        gyro_raw->x_axis = x;
        gyro_raw->y_axis = y;
        gyro_raw->z_axis = z;
        
        gyro_mdps->x_axis = float(x) * ctxt_imu.imu.accAndGyro.getGyroSensitivity();
        gyro_mdps->y_axis = float(y) * ctxt_imu.imu.accAndGyro.getGyroSensitivity();
        gyro_mdps->z_axis = float(z) * ctxt_imu.imu.accAndGyro.getGyroSensitivity();
    }
}

void imu_PI_stop( ) {
    stopped_imu = true;
    ctxt_imu.stop();
}
