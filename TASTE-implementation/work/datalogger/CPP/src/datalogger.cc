// Body file for function DataLogger
// Generated by TASTE on 2021-05-17 12:48:29
// You can edit this file, it will not be overwritten
// Provided interfaces : RecordAllData
// Required interfaces : RetreiveAllData
// User-defined properties for this function:
//   |_ Taste::Active_Interfaces = any
//   |_ Taste::coordinates = 168767 64723 201721 75473
// Timers              : 

#include "datalogger.h"
#include "datalogger_state.h"
#include <iostream>

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere
datalogger_state ctxt_dl;

// Auxiliary functions
////////////////////////////////////////////////////////////////////////////////
inline std::string get_htl_state(void) {
    asn1SccHTL_State state;
    datalogger_RI_getCurrentMode( &state );
    std::string state_str;
    switch (state) {
        case (asn1Scca1):
            state_str = "A1";
            break;
        case (asn1Scca2):
            state_str = "A2";
            break;
        case (asn1Sccf1):
            state_str = "F1";
            break;
        case (asn1Sccf2):
            state_str = "F2";
            break;
        case (asn1Sccf3):
            state_str = "F3";
            break;
        case (asn1Sccerror):
            state_str = "ERROR state";
            break;
    }
    return state_str;
}

inline void TimespecToEpoch(asn1SccT_Double epoch, char *buf, int buf_size) {
    struct tm ts;
    time_t time = epoch;
    ts = *localtime(&time);
    strftime(buf, buf_size, "%a %Y-%m-%d %H:%M:%S %Z", &ts);
}

inline void log_anemo() {
    char time[81];
    TimespecToEpoch(ctxt_dl.all_data.anemometer.gps_time, time, sizeof(time));
    ctxt_dl.csv_anemometer.newRow() <<
        get_htl_state() << time << ctxt_dl.all_data.anemometer.mission_time <<
        ctxt_dl.all_data.anemometer.data;
}

inline void log_gps() {
    char time[81];
    TimespecToEpoch(ctxt_dl.all_data.gps.data.date_and_time, time, sizeof(time));
    ctxt_dl.csv_gps.newRow() <<
        get_htl_state() <<
        ctxt_dl.all_data.gps.mission_time <<
        time << ctxt_dl.all_data.gps.data.ept <<
        ctxt_dl.all_data.gps.data.latitude <<
        ctxt_dl.all_data.gps.data.epy <<
        ctxt_dl.all_data.gps.data.longitude <<
        ctxt_dl.all_data.gps.data.epx <<
        ctxt_dl.all_data.gps.data.altitude <<
        ctxt_dl.all_data.gps.data.epv <<
        ctxt_dl.all_data.gps.data.course <<
        ctxt_dl.all_data.gps.data.epd <<
        ctxt_dl.all_data.gps.data.speed <<
        ctxt_dl.all_data.gps.data.eps <<
        ctxt_dl.all_data.gps.data.climb <<
        ctxt_dl.all_data.gps.data.epc;

}

inline void log_heaters(void) {
    char time1[81], time2[81];
    bool h1_valid = ctxt_dl.all_data.heater1.data.validity == asn1Sccvalid;
    bool h2_valid = ctxt_dl.all_data.heater2.data.validity == asn1Sccvalid;
    
    TimespecToEpoch(ctxt_dl.all_data.heater1.gps_time, time1, sizeof(time1));
    TimespecToEpoch(ctxt_dl.all_data.heater2.gps_time, time2, sizeof(time2));
    ctxt_dl.csv_heaters.newRow() <<
        get_htl_state() <<
        time1 << ctxt_dl.all_data.heater1.mission_time <<
        (h1_valid ? std::to_string(ctxt_dl.all_data.heater1.data.power_watts) : " ") <<
        time2 << ctxt_dl.all_data.heater2.mission_time <<
        (h2_valid ? std::to_string(ctxt_dl.all_data.heater2.data.power_watts) : " ");
}

inline void log_tc74s(void) {
    char time[81];
    TimespecToEpoch(ctxt_dl.all_data.tc74s.gps_time, time, sizeof(time));
    std::string temps [n_of_TC74s];

    for (int i = 0; i < n_of_TC74s; ++i) {
        asn1SccTC74s_All_Data_elem elem = ctxt_dl.all_data.tc74s.data.arr[i];
        if (elem.validity == asn1Sccvalid) {
            temps[i] = std::to_string(elem.temperature);
        } else {
            temps[i] = " ";
        }
    }
    
    ctxt_dl.csv_tc74s.newRow() <<
        get_htl_state() << time <<
        std::to_string(ctxt_dl.all_data.tc74s.mission_time) <<
        temps[0] << temps[1] << temps[2] << temps[3] << temps[4];
}

inline void log_pt1000s (void) {
    char time[81];
    TimespecToEpoch(ctxt_dl.all_data.pt1000s.gps_time, time, sizeof(time));
    std::string temps_volts [n_of_pt1000];
    std::string vcc [n_of_pt1000];
    std::string temps_celsius [n_of_pt1000];
    
    for (int i = 0; i < n_of_pt1000; ++i) {
        if (ctxt_dl.all_data.pt1000s.data.validity.arr[i] == asn1Sccvalid) {
            temps_volts[i] =  
                std::to_string (float (ctxt_dl.all_data.pt1000s.data.raw.arr[i].pt1000));
            vcc [i] =
                std::to_string (float (ctxt_dl.all_data.pt1000s.data.raw.arr[i].vcc_volts));
            temps_celsius[i] =
                std::to_string (float (ctxt_dl.all_data.pt1000s.data.celsius.arr[i]));
        } else {
            temps_volts[i] = " ";
            temps_celsius[i] = " ";
            vcc[i] = " ";
        }
    }
        
    ctxt_dl.csv_pt1000s.newRow()
        << get_htl_state() << time    
        << std::to_string(ctxt_dl.all_data.pt1000s.mission_time)
        << temps_celsius[0] << temps_volts [0] << vcc [0]
        << temps_celsius[1] << temps_volts [1] << vcc [1]
        << temps_celsius[2] << temps_volts [2] << vcc [2]
        << temps_celsius[3] << temps_volts [3] << vcc [3]
        << temps_celsius[4] << temps_volts [4] << vcc [4]
        << temps_celsius[5] << temps_volts [5] << vcc [5]
        << temps_celsius[6] << temps_volts [6] << vcc [6];
}

inline void log_pressure_sensors (void) {
    static bool first_sample = true;
    
    char time[81];
    TimespecToEpoch(ctxt_dl.all_data.ps1.gps_time, time, sizeof(time));
    
    if (first_sample) {
        first_sample = false;
        
        if (ctxt_dl.all_data.ps1.data.validity == asn1Sccinvalid) {
            ctxt_dl.csv_pressure_sensors.newRow() << "Calibration data of PS1:";
            ctxt_dl.csv_pressure_sensors.newRow() << 
                "c1" << "c2" << "c3" << "c4" << "c5" << "c6" <<
                "sens t1" << "off t1" << "tcs" << "tco" << "tref" << "temp sens"; 
            ctxt_dl.csv_pressure_sensors.newRow() << 
                ctxt_dl.all_data.ps1.data.calib.c1 << ctxt_dl.all_data.ps1.data.calib.c2 << 
                ctxt_dl.all_data.ps1.data.calib.c3 << ctxt_dl.all_data.ps1.data.calib.c4 << 
                ctxt_dl.all_data.ps1.data.calib.c5 << ctxt_dl.all_data.ps1.data.calib.c6 <<
                ctxt_dl.all_data.ps1.data.calib.sens_t1 << ctxt_dl.all_data.ps1.data.calib.off_t1 <<
                ctxt_dl.all_data.ps1.data.calib.tcs << ctxt_dl.all_data.ps1.data.calib.tco <<
                ctxt_dl.all_data.ps1.data.calib.tref << ctxt_dl.all_data.ps1.data.calib.temp_sens; 
        }
        
        if (ctxt_dl.all_data.ps2.data.validity == asn1Sccinvalid) {
            ctxt_dl.csv_pressure_sensors.newRow() << "Calibration data of PS2:";
            ctxt_dl.csv_pressure_sensors.newRow() << 
                "c1" << "c2" << "c3" << "c4" << "c5" << "c6" <<
                "sens t1" << "off t1" << "tcs" << "tco" << "tref" << "temp sens"; 
            ctxt_dl.csv_pressure_sensors.newRow() << 
                ctxt_dl.all_data.ps2.data.calib.c1 << ctxt_dl.all_data.ps2.data.calib.c2 << 
                ctxt_dl.all_data.ps2.data.calib.c3 << ctxt_dl.all_data.ps2.data.calib.c4 << 
                ctxt_dl.all_data.ps2.data.calib.c5 << ctxt_dl.all_data.ps2.data.calib.c6 <<
                ctxt_dl.all_data.ps2.data.calib.sens_t1 << ctxt_dl.all_data.ps2.data.calib.off_t1 <<
                ctxt_dl.all_data.ps2.data.calib.tcs << ctxt_dl.all_data.ps2.data.calib.tco <<
                ctxt_dl.all_data.ps2.data.calib.tref << ctxt_dl.all_data.ps2.data.calib.temp_sens; 
        }
        
        ctxt_dl.csv_pressure_sensors.newRow() << 
            "HTL state" << "Time GPS" << "Mission time" <<
            "PS1 pressure mbar" << "PS1 temp Celsius" <<
            "PS1 d1" << "PS1 d2" <<
            "PS2 pressure mbar" << "PS2 temp Celsius" <<
            "PS2 d1" << "PS2 d2";
        
    } else {
        char time[81];
        TimespecToEpoch(ctxt_dl.all_data.ps1.gps_time, time, sizeof(time));
        ctxt_dl.csv_pressure_sensors.newRow() <<
            get_htl_state() << time << ctxt_dl.all_data.ps1.mission_time <<
            ctxt_dl.all_data.ps1.data.raw.d1 << ctxt_dl.all_data.ps1.data.raw.d2 <<
            ctxt_dl.all_data.ps1.data.processed.pressure/100.0 <<  ctxt_dl.all_data.ps1.data.processed.temp/100.0 <<
            ctxt_dl.all_data.ps2.data.raw.d1 << ctxt_dl.all_data.ps2.data.raw.d2 <<
            ctxt_dl.all_data.ps2.data.processed.pressure/100.0 <<  ctxt_dl.all_data.ps2.data.processed.temp/100.0;
    }
}

// Component implementation:
////////////////////////////////////////////////////////////////////////////////
void datalogger_startup(void)
{
   // Write your initialisation code, but DO NOT CALL REQUIRED INTERFACES
    std::cout << "[DataLogger] Startup" << std::endl;
}

void datalogger_PI_RecordAllData(void)
{
    if (ctxt_dl.stopped_dl) {
        return;
    }
        
    datalogger_RI_RetreiveAllData( &ctxt_dl.all_data );
    
    if (ctxt_dl.nIters >= 10) {
        ctxt_dl.nIters = 1;
        ctxt_dl.writeToFile();
    }
    
    log_anemo();
    log_gps();
    log_heaters();
    log_tc74s();
    log_pt1000s();
    log_pressure_sensors();
    
    ctxt_dl.nIters++;
}

void datalogger_PI_notifyIMU( const asn1SccIMU_Queue *imu_data_queue ) {

    for (int i = 0; i < imu_queue_size; ++i) {
        char time[81];
        std::string mgt [6] = { " ", " ", " ", " ", " ", " "};
        std::string accel [6] = { " ", " ", " ", " ", " ", " "};
        std::string gyro [6] = { " ", " ", " ", " ", " ", " "};
        std::string temp [2] = {" ", " "};
        
        TimespecToEpoch(imu_data_queue->arr[i].gps_time, time, sizeof(time));
        
        if (imu_data_queue->arr[i].data.mgt_valid == asn1Sccvalid) {
            mgt[0] = std::to_string(imu_data_queue->arr[i].data.mgt_raw.x_axis);
            mgt[1] = std::to_string(imu_data_queue->arr[i].data.mgt_raw.y_axis);
            mgt[2] = std::to_string(imu_data_queue->arr[i].data.mgt_raw.z_axis);
            mgt[3] = std::to_string(imu_data_queue->arr[i].data.mgt_mgauss.x_axis);
            mgt[4] = std::to_string(imu_data_queue->arr[i].data.mgt_mgauss.y_axis);
            mgt[5] = std::to_string(imu_data_queue->arr[i].data.mgt_mgauss.z_axis);
        }
        
        if (imu_data_queue->arr[i].data.acc_valid == asn1Sccvalid) {
            accel[0] = std::to_string(imu_data_queue->arr[i].data.accel_raw.x_axis);
            accel[1] = std::to_string(imu_data_queue->arr[i].data.accel_raw.y_axis);
            accel[2] = std::to_string(imu_data_queue->arr[i].data.accel_raw.z_axis);
            accel[3] = std::to_string(imu_data_queue->arr[i].data.accel_mg.x_axis);
            accel[4] = std::to_string(imu_data_queue->arr[i].data.accel_mg.y_axis);
            accel[5] = std::to_string(imu_data_queue->arr[i].data.accel_mg.z_axis);
        }
        
        if (imu_data_queue->arr[i].data.gyro_valid == asn1Sccvalid) {
            gyro[0] = std::to_string(imu_data_queue->arr[i].data.gyro_raw.x_axis);
            gyro[1] = std::to_string(imu_data_queue->arr[i].data.gyro_raw.y_axis);
            gyro[2] = std::to_string(imu_data_queue->arr[i].data.gyro_raw.z_axis);
            gyro[3] = std::to_string(imu_data_queue->arr[i].data.gyro_mdps.x_axis);
            gyro[4] = std::to_string(imu_data_queue->arr[i].data.gyro_mdps.y_axis);
            gyro[5] = std::to_string(imu_data_queue->arr[i].data.gyro_mdps.z_axis);
        }
        
        if (imu_data_queue->arr[i].data.temp_valid == asn1Sccvalid) {
            temp[0] = std::to_string(imu_data_queue->arr[i].data.temp_raw);
            temp[1] = std::to_string(imu_data_queue->arr[i].data.temp_celsius);
        }
        
        ctxt_dl.csv_imu.newRow() 
            << get_htl_state() << time << imu_data_queue->arr[i].mission_time
            << mgt[0] << mgt[1] << mgt[2] << mgt[3] << mgt[4] << mgt[5]
            << accel[0] << accel[1] << accel[2] << accel[3] << accel[4] << accel[5]
            << gyro[0] << gyro[1] << gyro[2] << gyro[3] << gyro[4] << gyro[5]
            << temp[0] << temp[1];
    }
}

void datalogger_PI_stop( ) {
    ctxt_dl.stopped_dl = true;
    ctxt_dl.writeToFile();  // save the remaining data.
}
