// Body file for function TM
// Generated by TASTE on 2021-05-21 15:43:53
// You can edit this file, it will not be overwritten
// Provided interfaces : HK_tick
// Required interfaces : RetreiveAllData, sendTM
// User-defined properties for this function:
//   |_ Taste::Active_Interfaces = any
//   |_ Taste::coordinates = 180396 66118 205745 82594
// Timers              : 

#include "tm.h"
#include "tm_state.h"
#include <iostream>

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere
tm_state ctxt_tm;


void tm_startup(void)
{
   // Write your initialisation code, but DO NOT CALL REQUIRED INTERFACES
    std::cout << "[TM] Startup" << std::endl;
}

void tm_PI_HK_tick(void)
{
    asn1SccOBSW_DP_Data dp_data;
    tm_RI_RetreiveAllData(&dp_data);
    
    asn1SccTM tm;
    
    tm.heater1 = dp_data.heater1.data;
    tm.heater2 = dp_data.heater2.data;
    
    tm.tc74s = dp_data.tc74s.data;
    tm.pt1000s = dp_data.pt1000s.data;
    
    tm.gps = dp_data.gps.data;
    
    tm.imu = {
        .mgt_mgauss = dp_data.imu.data.mgt_mgauss,
        .accel_mg = dp_data.imu.data.accel_mg,
        .gyro_mdps = dp_data.imu.data.gyro_mdps,
        .temp_celsius = dp_data.imu.data.temp_celsius,
        .mgt_valid = dp_data.imu.data.mgt_valid,
        .acc_valid = dp_data.imu.data.acc_valid,
        .gyro_valid = dp_data.imu.data.gyro_valid,
        .temp_valid = dp_data.imu.data.temp_valid
    };
    
    tm.ps1 = dp_data.ps1.data.processed;
    tm.ps1_validity = dp_data.ps1.data.validity;
    tm.ps2 = dp_data.ps2.data.processed;
    tm.ps2_validity = dp_data.ps2.data.validity;
    
    tm.anemometer = dp_data.anemometer.data;
    
    tm_RI_getCurrentMode(&tm.state_htl);
    
    // Send data to GroundSW:
    tm_RI_tm(&tm);
}
