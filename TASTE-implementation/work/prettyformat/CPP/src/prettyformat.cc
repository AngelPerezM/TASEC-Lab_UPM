// Body file for function PrettyFormat
// Generated by TASTE on 2021-06-01 02:57:22
// You can edit this file, it will not be overwritten
// Provided interfaces : tm
// Required interfaces : Attitude_Data, Environmental_Data, HTL_Data
// User-defined properties for this function:
//   |_ Taste::Active_Interfaces = any
//   |_ Taste::coordinates = 63658 52504 89323 71325
// Timers              : 

#include "prettyformat.h"
#include "prettyformat_state.h"
#include <iostream>
#include <math.h>   // isfinite

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere
prettyformat_state ctxt_prettyformat;


void prettyformat_startup(void)
{
   // Write your initialisation code, but DO NOT CALL REQUIRED INTERFACES
    std::cout << "[PrettyFormat] Startup" << std::endl;
}

void prettyformat_PI_tm (const asn1SccTM *tm)

{
   // Write your code here
    asn1SccATT_GUI att = {
        .gps = tm->gps,
        .imu = {
            .mgt_mgauss = tm->imu.mgt_mgauss,
            .accel_mg = tm->imu.accel_mg,
            .gyro_mdps = tm->imu.gyro_mdps,
            .temp_celsius = tm->imu.temp_celsius,
            .mgt_valid = tm->imu.mgt_valid,
            .acc_valid = tm->imu.acc_valid,
            .gyro_valid = tm->imu.gyro_valid,
            .temp_valid = tm->imu.temp_valid
        }
    };
    
    if (isfinite(tm->gps.date_and_time)) {
        time_t time = tm->gps.date_and_time;
        struct tm ts = *localtime(&time);
        // ts = *localtime(&time);
        // strftime((char *) &att.gps_date_time_str, sizeof(att.gps_date_time_str), "%a %Y-%m-%d %H:%M:%S %Z", &ts);
        puts("------------------------------------");
        printf("now: %d-%02d-%02d %02d:%02d:%02d\n", ts.tm_year + 1900, ts.tm_mon + 1, ts.tm_mday, ts.tm_hour, ts.tm_min, ts.tm_sec);
        puts("------------------------------------");
        att.gps_date_time.year = 1900+ts.tm_year;
        att.gps_date_time.month = ts.tm_mon + 1;
        att.gps_date_time.day = ts.tm_mday;
        att.gps_date_time.hour = ts.tm_hour;
        att.gps_date_time.minute = ts.tm_min;
        att.gps_date_time.second = ts.tm_sec;
    }
    
    prettyformat_RI_Attitude_Data( &att );
    
    asn1SccENV_GUI env = {
        .pressure_sensor_1 = {
            .pressure_mbar = tm->ps1.pressure/1.0e2,
            .temperature_celsius = tm->ps1.temp/100.0,
            .validity = tm->ps1_validity
        },
        .pressure_sensor_2 = {
            .pressure_mbar = tm->ps2.pressure/1.0e2,
            .temperature_celsius = tm->ps2.temp/100.0,
            .validity = tm->ps2_validity
        },
        .anemometer = {
            .global_counter = tm->anemometer,
            .temperature_celsius = tm->pt1000s.celsius.arr[0],
            .temperature_validity = tm->pt1000s.validity.arr[0]
        },
        .heater = tm->heater1
    };
    prettyformat_RI_Environmental_Data( &env );
    
    asn1SccHTL_GUI htl = {
        .state = tm->state_htl,
        .heater = tm->heater2,
        .pt1000s = {
            .aire_abajo = tm->pt1000s.celsius.arr[1],
            .aire_arriba = tm->pt1000s.celsius.arr[3],
            .placa_abajo = tm->pt1000s.celsius.arr[6],
            .placa_arriba = tm->pt1000s.celsius.arr[5],
            .infinito = tm->pt1000s.celsius.arr[2],
            .exterior = tm->pt1000s.celsius.arr[4],
            .validity = {
                .arr = {
                    tm->pt1000s.validity.arr[1],
                    tm->pt1000s.validity.arr[3],
                    tm->pt1000s.validity.arr[6],
                    tm->pt1000s.validity.arr[5],
                    tm->pt1000s.validity.arr[2],
                    tm->pt1000s.validity.arr[4]
                }
            }
        },
        .tc74s = {
            .x_positive = tm->tc74s.arr[0].temperature,
            .x_negative = tm->tc74s.arr[1].temperature,
            .y_positive = tm->tc74s.arr[2].temperature,
            .y_negative = tm->tc74s.arr[3].temperature,
            .z_techo = tm->tc74s.arr[4].temperature,
            .validity = { 
                    .arr = {tm->tc74s.arr[0].validity,
                            tm->tc74s.arr[1].validity,
                            tm->tc74s.arr[2].validity,
                            tm->tc74s.arr[3].validity,
                            tm->tc74s.arr[4].validity
                }  
            }
        }
    };
    
    htl.delta_T = abs(htl.pt1000s.infinito - (htl.pt1000s.placa_abajo + htl.pt1000s.placa_arriba)/2.0),
    
    prettyformat_RI_HTL_Data( &htl );
}
