// Body file for function TC
// Generated by TASTE on 2021-05-24 05:14:53
// You can edit this file, it will not be overwritten
// Provided interfaces : tc
// Required interfaces : setPowerH1, setPowerH2
// User-defined properties for this function:
//   |_ Taste::Active_Interfaces = any
//   |_ Taste::coordinates = 128189 67541 153700 82975
// Timers              : 

#include "tc.h"
#include "tc_state.h"
#include <iostream>

// Define and use function state inside this context structure
// avoid defining global/static variable elsewhere
tc_state ctxt_tc;


void tc_startup(void)
{
   // Write your initialisation code, but DO NOT CALL REQUIRED INTERFACES
    std::cout << "[TC] Startup" << std::endl;
}

void tc_PI_tc
      (const asn1SccTC *IN_tc)

{
    asn1SccT_Float off = 0;
    asn1SccT_Float on = 1000; // Algo muy por encima lo ajusta.
    
    if (IN_tc->heater_of_HTL.heater == asn1Sccheater_HTL) {
        if (IN_tc->heater_of_HTL.command.kind == power_manual_PRESENT) {
            tc_RI_setPowerH2( &IN_tc->heater_of_HTL.command.u.power_manual );
        } else if (IN_tc->heater_of_HTL.command.kind == max_min_PRESENT) {            
            if (IN_tc->heater_of_HTL.command.u.max_min == asn1Sccmax) {
                tc_RI_setPowerH2( &on );
            } else {
                tc_RI_setPowerH2( &off );
            }
        }        
    } else {
        if (IN_tc->heater_of_HTL.command.kind == power_manual_PRESENT) {
            tc_RI_setPowerH1( &IN_tc->heater_of_HTL.command.u.power_manual );
        } else if (IN_tc->heater_of_HTL.command.kind == max_min_PRESENT) {
            if (IN_tc->heater_of_HTL.command.u.max_min == asn1Sccmax) {
                tc_RI_setPowerH1( &on );
            } else {
                tc_RI_setPowerH1( &off );
            }
        }            
    }
    
    tc_RI_configureParameters( &(IN_tc->config_of_HTL) );
}
