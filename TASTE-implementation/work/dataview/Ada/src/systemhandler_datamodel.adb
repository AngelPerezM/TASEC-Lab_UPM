pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");
pragma Warnings (On, "redundant with clause in body");

package body Systemhandler_Datamodel with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccSystemhandler_States_Equal (val1, val2 :  asn1SccSystemhandler_States) return Boolean
is

begin
	return val1 = val2;

end asn1SccSystemhandler_States_Equal;

function asn1SccSystemhandler_States_Init return asn1SccSystemhandler_States
is
    val: asn1SccSystemhandler_States;
begin
    val := asn1Sccwait;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSystemhandler_States_Init;

function asn1SccSystemhandler_States_IsConstraintValid(val : asn1SccSystemhandler_States) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val = asn1Sccwait);
    ret.ErrorCode := (if ret.Success then 0 else ERR_SYSTEMHANDLER_STATES);
    return ret;
end asn1SccSystemhandler_States_IsConstraintValid;



function asn1SccSystemhandler_Context_Equal (val1, val2 :  asn1SccSystemhandler_Context) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.state = val2.state);

    if ret then
        ret := (val1.init_done = val2.init_done);

    end if;
	return ret;

end asn1SccSystemhandler_Context_Equal;

function asn1SccSystemhandler_Context_Init return asn1SccSystemhandler_Context
is
    val: asn1SccSystemhandler_Context;
begin

    --set state 
    val.state := asn1SccSystemhandler_States_Init;
    --set init_done 
    val.init_done := FALSE;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSystemhandler_Context_Init;

function asn1SccSystemhandler_Context_IsConstraintValid(val : asn1SccSystemhandler_Context) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccSystemhandler_States_IsConstraintValid(val.state);
    return ret;
end asn1SccSystemhandler_Context_IsConstraintValid;



function asn1SccOBSW_DP_SingleData_selection_Equal (val1, val2 :  asn1SccOBSW_DP_SingleData_selection) return Boolean
is

begin
	return val1 = val2;

end asn1SccOBSW_DP_SingleData_selection_Equal;

function asn1SccOBSW_DP_SingleData_selection_Init return asn1SccOBSW_DP_SingleData_selection
is
    val: asn1SccOBSW_DP_SingleData_selection;
begin
    val := asn1Sccgps_present;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_SingleData_selection_Init;

function asn1SccOBSW_DP_SingleData_selection_IsConstraintValid(val : asn1SccOBSW_DP_SingleData_selection) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((((((((((((((val = asn1Sccgps_present)) OR ((val = asn1Sccimu_present)))) OR ((val = asn1Scctc74s_present)))) OR ((val = asn1Sccpt1000s_present)))) OR ((val = asn1Sccps1_present)))) OR ((val = asn1Sccps2_present)))) OR ((val = asn1Sccheater1_present)))) OR ((val = asn1Sccheater2_present)))) OR ((val = asn1Sccanemometer_present)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_OBSW_DP_SINGLEDATA_SELECTION_2);
    return ret;
end asn1SccOBSW_DP_SingleData_selection_IsConstraintValid;



function asn1SccTC_Heater_command_selection_Equal (val1, val2 :  asn1SccTC_Heater_command_selection) return Boolean
is

begin
	return val1 = val2;

end asn1SccTC_Heater_command_selection_Equal;

function asn1SccTC_Heater_command_selection_Init return asn1SccTC_Heater_command_selection
is
    val: asn1SccTC_Heater_command_selection;
begin
    val := asn1Sccpower_manual_present;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_Heater_command_selection_Init;

function asn1SccTC_Heater_command_selection_IsConstraintValid(val : asn1SccTC_Heater_command_selection) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccpower_manual_present)) OR ((val = asn1Sccmax_min_present)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_TC_HEATER_COMMAND_SELECTION_2);
    return ret;
end asn1SccTC_Heater_command_selection_IsConstraintValid;



function asn1SccTC_selection_Equal (val1, val2 :  asn1SccTC_selection) return Boolean
is

begin
	return val1 = val2;

end asn1SccTC_selection_Equal;

function asn1SccTC_selection_Init return asn1SccTC_selection
is
    val: asn1SccTC_selection;
begin
    val := asn1Sccheater_commands_present;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_selection_Init;

function asn1SccTC_selection_IsConstraintValid(val : asn1SccTC_selection) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccheater_commands_present)) OR ((val = asn1Sccsystem_commands_present)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_TC_SELECTION_2);
    return ret;
end asn1SccTC_selection_IsConstraintValid;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end Systemhandler_Datamodel;