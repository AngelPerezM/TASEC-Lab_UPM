/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview-uniq.h"

const asn1SccSint n_of_TC74s = 5;
const asn1SccSint n_of_pt1000 = 7;


flag asn1SccT_Int16_Equal(const asn1SccT_Int16* pVal1, const asn1SccT_Int16* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Int16_Initialize(asn1SccT_Int16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int16_IsConstraintValid(const asn1SccT_Int16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-32768LL <= (*(pVal))) && ((*(pVal)) <= 32767LL));
    *pErrCode = ret ? 0 :  ERR_T_INT16; 

	return ret;
}

flag asn1SccT_Int16_Encode(const asn1SccT_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int16_Decode(asn1SccT_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT16;

	return ret  && asn1SccT_Int16_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int16_ACN_Encode(const asn1SccT_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int16_ACN_Decode(asn1SccT_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT16;

    return ret && asn1SccT_Int16_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccMGT_Raw_Data_Equal(const asn1SccMGT_Raw_Data* pVal1, const asn1SccMGT_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void asn1SccMGT_Raw_Data_Initialize(asn1SccMGT_Raw_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	asn1SccT_Int16_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	asn1SccT_Int16_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	asn1SccT_Int16_Initialize((&(pVal->z_axis)));
}

flag asn1SccMGT_Raw_Data_IsConstraintValid(const asn1SccMGT_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_Int16_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = asn1SccT_Int16_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = asn1SccT_Int16_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag asn1SccMGT_Raw_Data_Encode(const asn1SccMGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccMGT_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Int16_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Int16_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Int16_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMGT_Raw_Data_Decode(asn1SccMGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Int16_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Int16_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Int16_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccMGT_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMGT_Raw_Data_ACN_Encode(const asn1SccMGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccMGT_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Int16_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Int16_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Int16_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMGT_Raw_Data_ACN_Decode(asn1SccMGT_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Int16_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Int16_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Int16_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && asn1SccMGT_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccACC_Raw_Data_Equal(const asn1SccACC_Raw_Data* pVal1, const asn1SccACC_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void asn1SccACC_Raw_Data_Initialize(asn1SccACC_Raw_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	asn1SccT_Int16_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	asn1SccT_Int16_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	asn1SccT_Int16_Initialize((&(pVal->z_axis)));
}

flag asn1SccACC_Raw_Data_IsConstraintValid(const asn1SccACC_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_Int16_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = asn1SccT_Int16_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = asn1SccT_Int16_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag asn1SccACC_Raw_Data_Encode(const asn1SccACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccACC_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Int16_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Int16_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Int16_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccACC_Raw_Data_Decode(asn1SccACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Int16_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Int16_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Int16_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccACC_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccACC_Raw_Data_ACN_Encode(const asn1SccACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccACC_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Int16_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Int16_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Int16_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccACC_Raw_Data_ACN_Decode(asn1SccACC_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Int16_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Int16_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Int16_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && asn1SccACC_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccGYRO_Raw_Data_Equal(const asn1SccGYRO_Raw_Data* pVal1, const asn1SccGYRO_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void asn1SccGYRO_Raw_Data_Initialize(asn1SccGYRO_Raw_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	asn1SccT_Int16_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	asn1SccT_Int16_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	asn1SccT_Int16_Initialize((&(pVal->z_axis)));
}

flag asn1SccGYRO_Raw_Data_IsConstraintValid(const asn1SccGYRO_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_Int16_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = asn1SccT_Int16_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = asn1SccT_Int16_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag asn1SccGYRO_Raw_Data_Encode(const asn1SccGYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccGYRO_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Int16_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Int16_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Int16_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccGYRO_Raw_Data_Decode(asn1SccGYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Int16_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Int16_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Int16_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccGYRO_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccGYRO_Raw_Data_ACN_Encode(const asn1SccGYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccGYRO_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Int16_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Int16_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Int16_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccGYRO_Raw_Data_ACN_Decode(asn1SccGYRO_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Int16_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Int16_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Int16_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && asn1SccGYRO_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt16_Equal(const asn1SccT_UInt16* pVal1, const asn1SccT_UInt16* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_UInt16_Initialize(asn1SccT_UInt16* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt16_IsConstraintValid(const asn1SccT_UInt16* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT16; 

	return ret;
}

flag asn1SccT_UInt16_Encode(const asn1SccT_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt16_Decode(asn1SccT_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT16;

	return ret  && asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt16_ACN_Encode(const asn1SccT_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt16_ACN_Decode(asn1SccT_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT16;

    return ret && asn1SccT_UInt16_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt64_Equal(const asn1SccT_UInt64* pVal1, const asn1SccT_UInt64* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_UInt64_Initialize(asn1SccT_UInt64* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt64_IsConstraintValid(const asn1SccT_UInt64* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_UInt64_Encode(const asn1SccT_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt64_Decode(asn1SccT_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT64;

	return ret  && asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt64_ACN_Encode(const asn1SccT_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt64_ACN_Decode(asn1SccT_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT64;

    return ret && asn1SccT_UInt64_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Float_Equal(const asn1SccT_Float* pVal1, const asn1SccT_Float* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Float_Initialize(asn1SccT_Float* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.00000000000000000000E+000;
}

flag asn1SccT_Float_IsConstraintValid(const asn1SccT_Float* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-3.40000000000000000000E+038 <= (*(pVal))) && ((*(pVal)) <= 3.40000000000000000000E+038));
    *pErrCode = ret ? 0 :  ERR_T_FLOAT; 

	return ret;
}

flag asn1SccT_Float_Encode(const asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Float_Decode(asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FLOAT;

	return ret  && asn1SccT_Float_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Float_ACN_Encode(const asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Float_ACN_Decode(asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_FLOAT;

    return ret && asn1SccT_Float_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccMGT_MilliGauss_Data_Equal(const asn1SccMGT_MilliGauss_Data* pVal1, const asn1SccMGT_MilliGauss_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void asn1SccMGT_MilliGauss_Data_Initialize(asn1SccMGT_MilliGauss_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	asn1SccT_Float_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	asn1SccT_Float_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	asn1SccT_Float_Initialize((&(pVal->z_axis)));
}

flag asn1SccMGT_MilliGauss_Data_IsConstraintValid(const asn1SccMGT_MilliGauss_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_Float_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = asn1SccT_Float_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = asn1SccT_Float_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag asn1SccMGT_MilliGauss_Data_Encode(const asn1SccMGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccMGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Float_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Float_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Float_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMGT_MilliGauss_Data_Decode(asn1SccMGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Float_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Float_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Float_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccMGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMGT_MilliGauss_Data_ACN_Encode(const asn1SccMGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccMGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Float_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Float_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Float_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMGT_MilliGauss_Data_ACN_Decode(asn1SccMGT_MilliGauss_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Float_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Float_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Float_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && asn1SccMGT_MilliGauss_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccACC_MilliG_Data_Equal(const asn1SccACC_MilliG_Data* pVal1, const asn1SccACC_MilliG_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void asn1SccACC_MilliG_Data_Initialize(asn1SccACC_MilliG_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	asn1SccT_Float_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	asn1SccT_Float_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	asn1SccT_Float_Initialize((&(pVal->z_axis)));
}

flag asn1SccACC_MilliG_Data_IsConstraintValid(const asn1SccACC_MilliG_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_Float_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = asn1SccT_Float_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = asn1SccT_Float_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag asn1SccACC_MilliG_Data_Encode(const asn1SccACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccACC_MilliG_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Float_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Float_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Float_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccACC_MilliG_Data_Decode(asn1SccACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Float_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Float_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Float_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccACC_MilliG_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccACC_MilliG_Data_ACN_Encode(const asn1SccACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccACC_MilliG_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Float_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Float_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Float_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccACC_MilliG_Data_ACN_Decode(asn1SccACC_MilliG_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Float_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Float_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Float_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && asn1SccACC_MilliG_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccGYRO_MilliDPS_Data_Equal(const asn1SccGYRO_MilliDPS_Data* pVal1, const asn1SccGYRO_MilliDPS_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_axis == pVal2->x_axis);

    if (ret) {
        ret = (pVal1->y_axis == pVal2->y_axis);

        if (ret) {
            ret = (pVal1->z_axis == pVal2->z_axis);

        }

    }

	return ret;

}

void asn1SccGYRO_MilliDPS_Data_Initialize(asn1SccGYRO_MilliDPS_Data* pVal)
{
	(void)pVal;



	/*set x_axis */
	asn1SccT_Float_Initialize((&(pVal->x_axis)));
	/*set y_axis */
	asn1SccT_Float_Initialize((&(pVal->y_axis)));
	/*set z_axis */
	asn1SccT_Float_Initialize((&(pVal->z_axis)));
}

flag asn1SccGYRO_MilliDPS_Data_IsConstraintValid(const asn1SccGYRO_MilliDPS_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_Float_IsConstraintValid((&(pVal->x_axis)), pErrCode);
    if (ret) {
        ret = asn1SccT_Float_IsConstraintValid((&(pVal->y_axis)), pErrCode);
        if (ret) {
            ret = asn1SccT_Float_IsConstraintValid((&(pVal->z_axis)), pErrCode);
        }
    }

	return ret;
}

flag asn1SccGYRO_MilliDPS_Data_Encode(const asn1SccGYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccGYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Float_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Float_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Float_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccGYRO_MilliDPS_Data_Decode(asn1SccGYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Float_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Float_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Float_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccGYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccGYRO_MilliDPS_Data_ACN_Encode(const asn1SccGYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccGYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x_axis */
	    ret = asn1SccT_Float_ACN_Encode((&(pVal->x_axis)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y_axis */
	        ret = asn1SccT_Float_ACN_Encode((&(pVal->y_axis)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z_axis */
	            ret = asn1SccT_Float_ACN_Encode((&(pVal->z_axis)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccGYRO_MilliDPS_Data_ACN_Decode(asn1SccGYRO_MilliDPS_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode x_axis */
	ret = asn1SccT_Float_ACN_Decode((&(pVal->x_axis)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y_axis */
	    ret = asn1SccT_Float_ACN_Decode((&(pVal->y_axis)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z_axis */
	        ret = asn1SccT_Float_ACN_Decode((&(pVal->z_axis)), pBitStrm, pErrCode);
	    }

	}


    return ret && asn1SccGYRO_MilliDPS_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPT1000s_Raw_Data_elem_Equal(const asn1SccPT1000s_Raw_Data_elem* pVal1, const asn1SccPT1000s_Raw_Data_elem* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->vcc_volts == pVal2->vcc_volts);

    if (ret) {
        ret = (pVal1->pt1000 == pVal2->pt1000);

    }

	return ret;

}

flag asn1SccPT1000s_Raw_Data_Equal(const asn1SccPT1000s_Raw_Data* pVal1, const asn1SccPT1000s_Raw_Data* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = asn1SccPT1000s_Raw_Data_elem_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

void asn1SccPT1000s_Raw_Data_elem_Initialize(asn1SccPT1000s_Raw_Data_elem* pVal)
{
	(void)pVal;



	/*set vcc_volts */
	asn1SccT_Float_Initialize((&(pVal->vcc_volts)));
	/*set pt1000 */
	asn1SccT_Float_Initialize((&(pVal->pt1000)));
}
void asn1SccPT1000s_Raw_Data_Initialize(asn1SccPT1000s_Raw_Data* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 7) {
	    asn1SccPT1000s_Raw_Data_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccPT1000s_Raw_Data_IsConstraintValid(const asn1SccPT1000s_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1].vcc_volts)), pErrCode);
    	if (ret) {
    	    ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1].pt1000)), pErrCode);
    	}
    }

	return ret;
}

flag asn1SccPT1000s_Raw_Data_Encode(const asn1SccPT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? asn1SccPT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	/*Encode vcc_volts */
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode pt1000 */
	    	    ret = asn1SccT_Float_Encode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPT1000s_Raw_Data_Decode(asn1SccPT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		/*Decode vcc_volts */
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode);
		if (ret) {
		    /*Decode pt1000 */
		    ret = asn1SccT_Float_Decode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode);
		}
	}

	return ret  && asn1SccPT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPT1000s_Raw_Data_ACN_Encode(const asn1SccPT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? asn1SccPT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	/*Encode vcc_volts */
	    	ret = asn1SccT_Float_ACN_Encode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode pt1000 */
	    	    ret = asn1SccT_Float_ACN_Encode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode, FALSE);
	    	}

	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPT1000s_Raw_Data_ACN_Decode(asn1SccPT1000s_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		/*Decode vcc_volts */
		ret = asn1SccT_Float_ACN_Decode((&(pVal->arr[i1].vcc_volts)), pBitStrm, pErrCode);
		if (ret) {
		    /*Decode pt1000 */
		    ret = asn1SccT_Float_ACN_Decode((&(pVal->arr[i1].pt1000)), pBitStrm, pErrCode);
		}

	}

    return ret && asn1SccPT1000s_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPT1000s_Celsius_Data_Equal(const asn1SccPT1000s_Celsius_Data* pVal1, const asn1SccPT1000s_Celsius_Data* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void asn1SccPT1000s_Celsius_Data_Initialize(asn1SccPT1000s_Celsius_Data* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 7) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccPT1000s_Celsius_Data_IsConstraintValid(const asn1SccPT1000s_Celsius_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccPT1000s_Celsius_Data_Encode(const asn1SccPT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? asn1SccPT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPT1000s_Celsius_Data_Decode(asn1SccPT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccPT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPT1000s_Celsius_Data_ACN_Encode(const asn1SccPT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? asn1SccPT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPT1000s_Celsius_Data_ACN_Decode(asn1SccPT1000s_Celsius_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		ret = asn1SccT_Float_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && asn1SccPT1000s_Celsius_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPS_Calibration_Data_Equal(const asn1SccPS_Calibration_Data* pVal1, const asn1SccPS_Calibration_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->c1 == pVal2->c1);

    if (ret) {
        ret = (pVal1->c2 == pVal2->c2);

        if (ret) {
            ret = (pVal1->c3 == pVal2->c3);

            if (ret) {
                ret = (pVal1->c4 == pVal2->c4);

                if (ret) {
                    ret = (pVal1->c5 == pVal2->c5);

                    if (ret) {
                        ret = (pVal1->c6 == pVal2->c6);

                        if (ret) {
                            ret = (pVal1->sens_t1 == pVal2->sens_t1);

                            if (ret) {
                                ret = (pVal1->off_t1 == pVal2->off_t1);

                                if (ret) {
                                    ret = (pVal1->tcs == pVal2->tcs);

                                    if (ret) {
                                        ret = (pVal1->tco == pVal2->tco);

                                        if (ret) {
                                            ret = (pVal1->tref == pVal2->tref);

                                            if (ret) {
                                                ret = (pVal1->temp_sens == pVal2->temp_sens);

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void asn1SccPS_Calibration_Data_Initialize(asn1SccPS_Calibration_Data* pVal)
{
	(void)pVal;



	/*set c1 */
	asn1SccT_UInt16_Initialize((&(pVal->c1)));
	/*set c2 */
	asn1SccT_UInt16_Initialize((&(pVal->c2)));
	/*set c3 */
	asn1SccT_UInt16_Initialize((&(pVal->c3)));
	/*set c4 */
	asn1SccT_UInt16_Initialize((&(pVal->c4)));
	/*set c5 */
	asn1SccT_UInt16_Initialize((&(pVal->c5)));
	/*set c6 */
	asn1SccT_UInt16_Initialize((&(pVal->c6)));
	/*set sens_t1 */
	asn1SccT_Float_Initialize((&(pVal->sens_t1)));
	/*set off_t1 */
	asn1SccT_Float_Initialize((&(pVal->off_t1)));
	/*set tcs */
	asn1SccT_Float_Initialize((&(pVal->tcs)));
	/*set tco */
	asn1SccT_Float_Initialize((&(pVal->tco)));
	/*set tref */
	asn1SccT_Float_Initialize((&(pVal->tref)));
	/*set temp_sens */
	asn1SccT_Float_Initialize((&(pVal->temp_sens)));
}

flag asn1SccPS_Calibration_Data_IsConstraintValid(const asn1SccPS_Calibration_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt16_IsConstraintValid((&(pVal->c1)), pErrCode);
    if (ret) {
        ret = asn1SccT_UInt16_IsConstraintValid((&(pVal->c2)), pErrCode);
        if (ret) {
            ret = asn1SccT_UInt16_IsConstraintValid((&(pVal->c3)), pErrCode);
            if (ret) {
                ret = asn1SccT_UInt16_IsConstraintValid((&(pVal->c4)), pErrCode);
                if (ret) {
                    ret = asn1SccT_UInt16_IsConstraintValid((&(pVal->c5)), pErrCode);
                    if (ret) {
                        ret = asn1SccT_UInt16_IsConstraintValid((&(pVal->c6)), pErrCode);
                        if (ret) {
                            ret = asn1SccT_Float_IsConstraintValid((&(pVal->sens_t1)), pErrCode);
                            if (ret) {
                                ret = asn1SccT_Float_IsConstraintValid((&(pVal->off_t1)), pErrCode);
                                if (ret) {
                                    ret = asn1SccT_Float_IsConstraintValid((&(pVal->tcs)), pErrCode);
                                    if (ret) {
                                        ret = asn1SccT_Float_IsConstraintValid((&(pVal->tco)), pErrCode);
                                        if (ret) {
                                            ret = asn1SccT_Float_IsConstraintValid((&(pVal->tref)), pErrCode);
                                            if (ret) {
                                                ret = asn1SccT_Float_IsConstraintValid((&(pVal->temp_sens)), pErrCode);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccPS_Calibration_Data_Encode(const asn1SccPS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccPS_Calibration_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode c1 */
	    ret = asn1SccT_UInt16_Encode((&(pVal->c1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode c2 */
	        ret = asn1SccT_UInt16_Encode((&(pVal->c2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode c3 */
	            ret = asn1SccT_UInt16_Encode((&(pVal->c3)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode c4 */
	                ret = asn1SccT_UInt16_Encode((&(pVal->c4)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode c5 */
	                    ret = asn1SccT_UInt16_Encode((&(pVal->c5)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode c6 */
	                        ret = asn1SccT_UInt16_Encode((&(pVal->c6)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode sens_t1 */
	                            ret = asn1SccT_Float_Encode((&(pVal->sens_t1)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode off_t1 */
	                                ret = asn1SccT_Float_Encode((&(pVal->off_t1)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode tcs */
	                                    ret = asn1SccT_Float_Encode((&(pVal->tcs)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode tco */
	                                        ret = asn1SccT_Float_Encode((&(pVal->tco)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode tref */
	                                            ret = asn1SccT_Float_Encode((&(pVal->tref)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode temp_sens */
	                                                ret = asn1SccT_Float_Encode((&(pVal->temp_sens)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPS_Calibration_Data_Decode(asn1SccPS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode c1 */
	ret = asn1SccT_UInt16_Decode((&(pVal->c1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode c2 */
	    ret = asn1SccT_UInt16_Decode((&(pVal->c2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode c3 */
	        ret = asn1SccT_UInt16_Decode((&(pVal->c3)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode c4 */
	            ret = asn1SccT_UInt16_Decode((&(pVal->c4)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode c5 */
	                ret = asn1SccT_UInt16_Decode((&(pVal->c5)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode c6 */
	                    ret = asn1SccT_UInt16_Decode((&(pVal->c6)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode sens_t1 */
	                        ret = asn1SccT_Float_Decode((&(pVal->sens_t1)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode off_t1 */
	                            ret = asn1SccT_Float_Decode((&(pVal->off_t1)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode tcs */
	                                ret = asn1SccT_Float_Decode((&(pVal->tcs)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode tco */
	                                    ret = asn1SccT_Float_Decode((&(pVal->tco)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode tref */
	                                        ret = asn1SccT_Float_Decode((&(pVal->tref)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode temp_sens */
	                                            ret = asn1SccT_Float_Decode((&(pVal->temp_sens)), pBitStrm, pErrCode);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccPS_Calibration_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPS_Calibration_Data_ACN_Encode(const asn1SccPS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccPS_Calibration_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode c1 */
	    ret = asn1SccT_UInt16_ACN_Encode((&(pVal->c1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode c2 */
	        ret = asn1SccT_UInt16_ACN_Encode((&(pVal->c2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode c3 */
	            ret = asn1SccT_UInt16_ACN_Encode((&(pVal->c3)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode c4 */
	                ret = asn1SccT_UInt16_ACN_Encode((&(pVal->c4)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode c5 */
	                    ret = asn1SccT_UInt16_ACN_Encode((&(pVal->c5)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode c6 */
	                        ret = asn1SccT_UInt16_ACN_Encode((&(pVal->c6)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode sens_t1 */
	                            ret = asn1SccT_Float_ACN_Encode((&(pVal->sens_t1)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode off_t1 */
	                                ret = asn1SccT_Float_ACN_Encode((&(pVal->off_t1)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode tcs */
	                                    ret = asn1SccT_Float_ACN_Encode((&(pVal->tcs)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode tco */
	                                        ret = asn1SccT_Float_ACN_Encode((&(pVal->tco)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode tref */
	                                            ret = asn1SccT_Float_ACN_Encode((&(pVal->tref)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode temp_sens */
	                                                ret = asn1SccT_Float_ACN_Encode((&(pVal->temp_sens)), pBitStrm, pErrCode, FALSE);
	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPS_Calibration_Data_ACN_Decode(asn1SccPS_Calibration_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode c1 */
	ret = asn1SccT_UInt16_ACN_Decode((&(pVal->c1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode c2 */
	    ret = asn1SccT_UInt16_ACN_Decode((&(pVal->c2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode c3 */
	        ret = asn1SccT_UInt16_ACN_Decode((&(pVal->c3)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode c4 */
	            ret = asn1SccT_UInt16_ACN_Decode((&(pVal->c4)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode c5 */
	                ret = asn1SccT_UInt16_ACN_Decode((&(pVal->c5)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode c6 */
	                    ret = asn1SccT_UInt16_ACN_Decode((&(pVal->c6)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode sens_t1 */
	                        ret = asn1SccT_Float_ACN_Decode((&(pVal->sens_t1)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode off_t1 */
	                            ret = asn1SccT_Float_ACN_Decode((&(pVal->off_t1)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode tcs */
	                                ret = asn1SccT_Float_ACN_Decode((&(pVal->tcs)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode tco */
	                                    ret = asn1SccT_Float_ACN_Decode((&(pVal->tco)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode tref */
	                                        ret = asn1SccT_Float_ACN_Decode((&(pVal->tref)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode temp_sens */
	                                            ret = asn1SccT_Float_ACN_Decode((&(pVal->temp_sens)), pBitStrm, pErrCode);
	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && asn1SccPS_Calibration_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccTC_Heater_heater_Equal(const asn1SccTC_Heater_heater* pVal1, const asn1SccTC_Heater_heater* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccTC_Heater_command_max_min_Equal(const asn1SccTC_Heater_command_max_min* pVal1, const asn1SccTC_Heater_command_max_min* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccTC_Heater_command_Equal(const asn1SccTC_Heater_command* pVal1, const asn1SccTC_Heater_command* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->kind == pVal2->kind);
    if (ret) {
    	switch(pVal1->kind) 
    	{
    	case power_manual_PRESENT:
    		ret = (pVal1->u.power_manual == pVal2->u.power_manual);
    		break;
    	case max_min_PRESENT:
    		ret = asn1SccTC_Heater_command_max_min_Equal((&(pVal1->u.max_min)), (&(pVal2->u.max_min)));
    		break;
    	default: /*COVERAGE_IGNORE*/
    		ret = FALSE;    /*COVERAGE_IGNORE*/
    	}
    } /*COVERAGE_IGNORE*/
	return ret;

}

flag asn1SccTC_Heater_Equal(const asn1SccTC_Heater* pVal1, const asn1SccTC_Heater* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccTC_Heater_heater_Equal((&(pVal1->heater)), (&(pVal2->heater)));

    if (ret) {
        ret = asn1SccTC_Heater_command_Equal((&(pVal1->command)), (&(pVal2->command)));

    }

	return ret;

}

void asn1SccTC_Heater_heater_Initialize(asn1SccTC_Heater_heater* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1Sccheater_HTL;
}
void asn1SccTC_Heater_command_max_min_Initialize(asn1SccTC_Heater_command_max_min* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1Sccmax;
}
void asn1SccTC_Heater_command_Initialize(asn1SccTC_Heater_command* pVal)
{
	(void)pVal;


	/*set power_manual*/
	pVal->kind = power_manual_PRESENT;
	asn1SccT_Float_Initialize((&(pVal->u.power_manual)));
}
void asn1SccTC_Heater_Initialize(asn1SccTC_Heater* pVal)
{
	(void)pVal;



	/*set heater */
	asn1SccTC_Heater_heater_Initialize((&(pVal->heater)));
	/*set command */
	asn1SccTC_Heater_command_Initialize((&(pVal->command)));
}

flag asn1SccTC_Heater_IsConstraintValid(const asn1SccTC_Heater* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (((pVal->heater == asn1Sccheater_HTL)) || ((pVal->heater == asn1Sccheater_anemo)));
    *pErrCode = ret ? 0 :  ERR_TC_HEATER_HEATER; 
    if (ret) {
        if (pVal->command.kind == power_manual_PRESENT) {
        	ret = asn1SccT_Float_IsConstraintValid((&(pVal->command.u.power_manual)), pErrCode);
        }
        if (ret) {
            if (pVal->command.kind == max_min_PRESENT) {
            	ret = (((pVal->command.u.max_min == asn1Sccmax)) || ((pVal->command.u.max_min == asn1Sccmin)));
            	*pErrCode = ret ? 0 :  ERR_TC_HEATER_COMMAND_MAX_MIN; 
            }
        }
    }

	return ret;
}

flag asn1SccTC_Heater_Encode(const asn1SccTC_Heater* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccTC_Heater_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heater */
	    switch(pVal->heater) 
	    {
	        case asn1Sccheater_HTL:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case asn1Sccheater_anemo:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_TC_HEATER_HEATER; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	        /*Encode command */
	        switch(pVal->command.kind) 
	        {
	        case power_manual_PRESENT:
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	ret = asn1SccT_Float_Encode((&(pVal->command.u.power_manual)), pBitStrm, pErrCode, FALSE);
	        	break;
	        case max_min_PRESENT:
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	switch(pVal->command.u.max_min) 
	        	{
	        	    case asn1Sccmax:   
	        	        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	    	break;
	        	    case asn1Sccmin:   
	        	        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	    	break;
	        	    default:                    /*COVERAGE_IGNORE*/
	        		    *pErrCode = ERR_UPER_ENCODE_TC_HEATER_COMMAND_MAX_MIN; /*COVERAGE_IGNORE*/
	        		    ret = FALSE;            /*COVERAGE_IGNORE*/
	        	}
	        	break;
	        default:                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_UPER_ENCODE_TC_HEATER_COMMAND;         /*COVERAGE_IGNORE*/
	            ret = FALSE;                    /*COVERAGE_IGNORE*/
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTC_Heater_Decode(asn1SccTC_Heater* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint asn1SccTC_Heater_command_index_tmp;

	/*Decode heater */
	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TC_HEATER_HEATER;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                pVal->heater = asn1Sccheater_HTL;
	                break;
	            case 1: 
	                pVal->heater = asn1Sccheater_anemo;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_TC_HEATER_HEATER;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        pVal->heater = asn1Sccheater_HTL;             /*COVERAGE_IGNORE*/
	    }
	}
	if (ret) {
	    /*Decode command */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &asn1SccTC_Heater_command_index_tmp, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TC_HEATER_COMMAND;
	    if (ret) {
	        switch(asn1SccTC_Heater_command_index_tmp) 
	        {
	        case 0:
	        	pVal->command.kind = power_manual_PRESENT;
	        	ret = asn1SccT_Float_Decode((&(pVal->command.u.power_manual)), pBitStrm, pErrCode);
	        	break;
	        case 1:
	        	pVal->command.kind = max_min_PRESENT;
	        	{
	        	    asn1SccSint enumIndex;
	        	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	        	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TC_HEATER_COMMAND_MAX_MIN;
	        	    if (ret) {
	        	        switch(enumIndex) 
	        	        {
	        	            case 0: 
	        	                pVal->command.u.max_min = asn1Sccmax;
	        	                break;
	        	            case 1: 
	        	                pVal->command.u.max_min = asn1Sccmin;
	        	                break;
	        	            default:                        /*COVERAGE_IGNORE*/
	        		            *pErrCode = ERR_UPER_DECODE_TC_HEATER_COMMAND_MAX_MIN;     /*COVERAGE_IGNORE*/
	        		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        	        }
	        	    } else {
	        	        pVal->command.u.max_min = asn1Sccmax;             /*COVERAGE_IGNORE*/
	        	    }
	        	}
	        	break;
	        default:                        /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_UPER_DECODE_TC_HEATER_COMMAND;     /*COVERAGE_IGNORE*/
	            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    }  /*COVERAGE_IGNORE*/
	}

	return ret  && asn1SccTC_Heater_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccTC_Heater_ACN_Encode(const asn1SccTC_Heater* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccTC_Heater_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heater */
	    switch(pVal->heater) { 
	        case asn1Sccheater_HTL:
	            uIntVal = 0;
	            break;
	        case asn1Sccheater_anemo:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TC_HEATER_HEATER;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
	    if (ret) {
	        /*Encode command */
	        switch(pVal->command.kind) 
	        {
	        case power_manual_PRESENT:
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	ret = asn1SccT_Float_ACN_Encode((&(pVal->command.u.power_manual)), pBitStrm, pErrCode, FALSE);
	        	break;
	        case max_min_PRESENT:
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	switch(pVal->command.u.max_min) { 
	        	    case asn1Sccmax:
	        	        uIntVal = 0;
	        	        break;
	        	    case asn1Sccmin:
	        	        uIntVal = 1;
	        	        break;
	        	    default:                                    /*COVERAGE_IGNORE*/
	        	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	        *pErrCode = ERR_ACN_ENCODE_TC_HEATER_COMMAND_MAX_MIN;                 /*COVERAGE_IGNORE*/
	        	}
	        	if (ret) {
	        		BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	        	}
	        	break;
	        default: /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_TC_HEATER_COMMAND;         /*COVERAGE_IGNORE*/
	            ret = FALSE;                    /*COVERAGE_IGNORE*/
	        } /*COVERAGE_IGNORE*/
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTC_Heater_ACN_Decode(asn1SccTC_Heater* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;
	asn1SccSint TASEC_LAB_B2SPACE_DATAVIEW_TC_Heater_command_index_tmp;

	/*Decode heater */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TC_HEATER_HEATER;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            pVal->heater = asn1Sccheater_HTL;
	            break;
	        case 1:
	            pVal->heater = asn1Sccheater_anemo;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_TC_HEATER_HEATER;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/
	if (ret) {
	    /*Decode command */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &TASEC_LAB_B2SPACE_DATAVIEW_TC_Heater_command_index_tmp, 0, 1);
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_TC_HEATER_COMMAND;
	    if (ret) {
	        switch(TASEC_LAB_B2SPACE_DATAVIEW_TC_Heater_command_index_tmp) 
	        {
	        case 0:
	        	pVal->command.kind = power_manual_PRESENT;
	        	ret = asn1SccT_Float_ACN_Decode((&(pVal->command.u.power_manual)), pBitStrm, pErrCode);
	        	break;
	        case 1:
	        	pVal->command.kind = max_min_PRESENT;
	        	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	        	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TC_HEATER_COMMAND_MAX_MIN;
	        	if (ret) {
	        	    switch (uIntVal) {
	        	        case 0:
	        	            pVal->command.u.max_min = asn1Sccmax;
	        	            break;
	        	        case 1:
	        	            pVal->command.u.max_min = asn1Sccmin;
	        	            break;
	        	    default:                                    /*COVERAGE_IGNORE*/
	        	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        	        *pErrCode = ERR_ACN_DECODE_TC_HEATER_COMMAND_MAX_MIN;                 /*COVERAGE_IGNORE*/
	        	    }
	        	} /*COVERAGE_IGNORE*/
	        	break;
	        default: /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_DECODE_TC_HEATER_COMMAND;     /*COVERAGE_IGNORE*/
	            ret = FALSE;                /*COVERAGE_IGNORE*/
	        } 
	    } /*COVERAGE_IGNORE*/
	}


    return ret && asn1SccTC_Heater_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Double_Equal(const asn1SccT_Double* pVal1, const asn1SccT_Double* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Double_Initialize(asn1SccT_Double* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.00000000000000000000E+000;
}

flag asn1SccT_Double_IsConstraintValid(const asn1SccT_Double* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1.69999999999999990000E+308 <= (*(pVal))) && ((*(pVal)) <= 1.69999999999999990000E+308));
    *pErrCode = ret ? 0 :  ERR_T_DOUBLE; 

	return ret;
}

flag asn1SccT_Double_Encode(const asn1SccT_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Double_Decode(asn1SccT_Double* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_DOUBLE;

	return ret  && asn1SccT_Double_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Double_ACN_Encode(const asn1SccT_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Double_ACN_Decode(asn1SccT_Double* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_DOUBLE;

    return ret && asn1SccT_Double_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccGPS_PVT_mode_Equal(const asn1SccGPS_PVT_mode* pVal1, const asn1SccGPS_PVT_mode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccGPS_PVT_Equal(const asn1SccGPS_PVT* pVal1, const asn1SccGPS_PVT* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccGPS_PVT_mode_Equal((&(pVal1->mode)), (&(pVal2->mode)));

    if (ret) {
        ret = (pVal1->date_and_time == pVal2->date_and_time);

        if (ret) {
            ret = (pVal1->ept == pVal2->ept);

            if (ret) {
                ret = (pVal1->latitude == pVal2->latitude);

                if (ret) {
                    ret = (pVal1->epy == pVal2->epy);

                    if (ret) {
                        ret = (pVal1->longitude == pVal2->longitude);

                        if (ret) {
                            ret = (pVal1->epx == pVal2->epx);

                            if (ret) {
                                ret = (pVal1->altitude == pVal2->altitude);

                                if (ret) {
                                    ret = (pVal1->epv == pVal2->epv);

                                    if (ret) {
                                        ret = (pVal1->course == pVal2->course);

                                        if (ret) {
                                            ret = (pVal1->epd == pVal2->epd);

                                            if (ret) {
                                                ret = (pVal1->speed == pVal2->speed);

                                                if (ret) {
                                                    ret = (pVal1->eps == pVal2->eps);

                                                    if (ret) {
                                                        ret = (pVal1->climb == pVal2->climb);

                                                        if (ret) {
                                                            ret = (pVal1->epc == pVal2->epc);

                                                        }

                                                    }

                                                }

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void asn1SccGPS_PVT_mode_Initialize(asn1SccGPS_PVT_mode* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1Sccnot_seen;
}
void asn1SccGPS_PVT_Initialize(asn1SccGPS_PVT* pVal)
{
	(void)pVal;



	/*set mode */
	asn1SccGPS_PVT_mode_Initialize((&(pVal->mode)));
	/*set date_and_time */
	asn1SccT_Double_Initialize((&(pVal->date_and_time)));
	/*set ept */
	asn1SccT_Double_Initialize((&(pVal->ept)));
	/*set latitude */
	asn1SccT_Double_Initialize((&(pVal->latitude)));
	/*set epy */
	asn1SccT_Double_Initialize((&(pVal->epy)));
	/*set longitude */
	asn1SccT_Double_Initialize((&(pVal->longitude)));
	/*set epx */
	asn1SccT_Double_Initialize((&(pVal->epx)));
	/*set altitude */
	asn1SccT_Double_Initialize((&(pVal->altitude)));
	/*set epv */
	asn1SccT_Double_Initialize((&(pVal->epv)));
	/*set course */
	asn1SccT_Double_Initialize((&(pVal->course)));
	/*set epd */
	asn1SccT_Double_Initialize((&(pVal->epd)));
	/*set speed */
	asn1SccT_Double_Initialize((&(pVal->speed)));
	/*set eps */
	asn1SccT_Double_Initialize((&(pVal->eps)));
	/*set climb */
	asn1SccT_Double_Initialize((&(pVal->climb)));
	/*set epc */
	asn1SccT_Double_Initialize((&(pVal->epc)));
}

flag asn1SccGPS_PVT_IsConstraintValid(const asn1SccGPS_PVT* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (((((((pVal->mode == asn1Sccnot_seen)) || ((pVal->mode == asn1Sccno_fix)))) || ((pVal->mode == asn1Scctwo_dims)))) || ((pVal->mode == asn1Sccthree_dims)));
    *pErrCode = ret ? 0 :  ERR_GPS_PVT_MODE; 
    if (ret) {
        ret = asn1SccT_Double_IsConstraintValid((&(pVal->date_and_time)), pErrCode);
        if (ret) {
            ret = asn1SccT_Double_IsConstraintValid((&(pVal->ept)), pErrCode);
            if (ret) {
                ret = asn1SccT_Double_IsConstraintValid((&(pVal->latitude)), pErrCode);
                if (ret) {
                    ret = asn1SccT_Double_IsConstraintValid((&(pVal->epy)), pErrCode);
                    if (ret) {
                        ret = asn1SccT_Double_IsConstraintValid((&(pVal->longitude)), pErrCode);
                        if (ret) {
                            ret = asn1SccT_Double_IsConstraintValid((&(pVal->epx)), pErrCode);
                            if (ret) {
                                ret = asn1SccT_Double_IsConstraintValid((&(pVal->altitude)), pErrCode);
                                if (ret) {
                                    ret = asn1SccT_Double_IsConstraintValid((&(pVal->epv)), pErrCode);
                                    if (ret) {
                                        ret = asn1SccT_Double_IsConstraintValid((&(pVal->course)), pErrCode);
                                        if (ret) {
                                            ret = asn1SccT_Double_IsConstraintValid((&(pVal->epd)), pErrCode);
                                            if (ret) {
                                                ret = asn1SccT_Double_IsConstraintValid((&(pVal->speed)), pErrCode);
                                                if (ret) {
                                                    ret = asn1SccT_Double_IsConstraintValid((&(pVal->eps)), pErrCode);
                                                    if (ret) {
                                                        ret = asn1SccT_Double_IsConstraintValid((&(pVal->climb)), pErrCode);
                                                        if (ret) {
                                                            ret = asn1SccT_Double_IsConstraintValid((&(pVal->epc)), pErrCode);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccGPS_PVT_Encode(const asn1SccGPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccGPS_PVT_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mode */
	    switch(pVal->mode) 
	    {
	        case asn1Sccnot_seen:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case asn1Sccno_fix:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case asn1Scctwo_dims:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case asn1Sccthree_dims:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_GPS_PVT_MODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	        /*Encode date_and_time */
	        ret = asn1SccT_Double_Encode((&(pVal->date_and_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode ept */
	            ret = asn1SccT_Double_Encode((&(pVal->ept)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode latitude */
	                ret = asn1SccT_Double_Encode((&(pVal->latitude)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode epy */
	                    ret = asn1SccT_Double_Encode((&(pVal->epy)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode longitude */
	                        ret = asn1SccT_Double_Encode((&(pVal->longitude)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode epx */
	                            ret = asn1SccT_Double_Encode((&(pVal->epx)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode altitude */
	                                ret = asn1SccT_Double_Encode((&(pVal->altitude)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode epv */
	                                    ret = asn1SccT_Double_Encode((&(pVal->epv)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode course */
	                                        ret = asn1SccT_Double_Encode((&(pVal->course)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode epd */
	                                            ret = asn1SccT_Double_Encode((&(pVal->epd)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode speed */
	                                                ret = asn1SccT_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode eps */
	                                                    ret = asn1SccT_Double_Encode((&(pVal->eps)), pBitStrm, pErrCode, FALSE);
	                                                    if (ret) {
	                                                        /*Encode climb */
	                                                        ret = asn1SccT_Double_Encode((&(pVal->climb)), pBitStrm, pErrCode, FALSE);
	                                                        if (ret) {
	                                                            /*Encode epc */
	                                                            ret = asn1SccT_Double_Encode((&(pVal->epc)), pBitStrm, pErrCode, FALSE);
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccGPS_PVT_Decode(asn1SccGPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mode */
	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_GPS_PVT_MODE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                pVal->mode = asn1Sccnot_seen;
	                break;
	            case 1: 
	                pVal->mode = asn1Sccno_fix;
	                break;
	            case 2: 
	                pVal->mode = asn1Scctwo_dims;
	                break;
	            case 3: 
	                pVal->mode = asn1Sccthree_dims;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_GPS_PVT_MODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        pVal->mode = asn1Sccnot_seen;             /*COVERAGE_IGNORE*/
	    }
	}
	if (ret) {
	    /*Decode date_and_time */
	    ret = asn1SccT_Double_Decode((&(pVal->date_and_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode ept */
	        ret = asn1SccT_Double_Decode((&(pVal->ept)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode latitude */
	            ret = asn1SccT_Double_Decode((&(pVal->latitude)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode epy */
	                ret = asn1SccT_Double_Decode((&(pVal->epy)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode longitude */
	                    ret = asn1SccT_Double_Decode((&(pVal->longitude)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode epx */
	                        ret = asn1SccT_Double_Decode((&(pVal->epx)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode altitude */
	                            ret = asn1SccT_Double_Decode((&(pVal->altitude)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode epv */
	                                ret = asn1SccT_Double_Decode((&(pVal->epv)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode course */
	                                    ret = asn1SccT_Double_Decode((&(pVal->course)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode epd */
	                                        ret = asn1SccT_Double_Decode((&(pVal->epd)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode speed */
	                                            ret = asn1SccT_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode eps */
	                                                ret = asn1SccT_Double_Decode((&(pVal->eps)), pBitStrm, pErrCode);
	                                                if (ret) {
	                                                    /*Decode climb */
	                                                    ret = asn1SccT_Double_Decode((&(pVal->climb)), pBitStrm, pErrCode);
	                                                    if (ret) {
	                                                        /*Decode epc */
	                                                        ret = asn1SccT_Double_Decode((&(pVal->epc)), pBitStrm, pErrCode);
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccGPS_PVT_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccGPS_PVT_ACN_Encode(const asn1SccGPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccGPS_PVT_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mode */
	    switch(pVal->mode) { 
	        case asn1Sccnot_seen:
	            uIntVal = 0;
	            break;
	        case asn1Sccno_fix:
	            uIntVal = 1;
	            break;
	        case asn1Scctwo_dims:
	            uIntVal = 2;
	            break;
	        case asn1Sccthree_dims:
	            uIntVal = 3;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_GPS_PVT_MODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 3);
	    }
	    if (ret) {
	        /*Encode date_and_time */
	        ret = asn1SccT_Double_ACN_Encode((&(pVal->date_and_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode ept */
	            ret = asn1SccT_Double_ACN_Encode((&(pVal->ept)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode latitude */
	                ret = asn1SccT_Double_ACN_Encode((&(pVal->latitude)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode epy */
	                    ret = asn1SccT_Double_ACN_Encode((&(pVal->epy)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode longitude */
	                        ret = asn1SccT_Double_ACN_Encode((&(pVal->longitude)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode epx */
	                            ret = asn1SccT_Double_ACN_Encode((&(pVal->epx)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode altitude */
	                                ret = asn1SccT_Double_ACN_Encode((&(pVal->altitude)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode epv */
	                                    ret = asn1SccT_Double_ACN_Encode((&(pVal->epv)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode course */
	                                        ret = asn1SccT_Double_ACN_Encode((&(pVal->course)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode epd */
	                                            ret = asn1SccT_Double_ACN_Encode((&(pVal->epd)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode speed */
	                                                ret = asn1SccT_Double_ACN_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode eps */
	                                                    ret = asn1SccT_Double_ACN_Encode((&(pVal->eps)), pBitStrm, pErrCode, FALSE);
	                                                    if (ret) {
	                                                        /*Encode climb */
	                                                        ret = asn1SccT_Double_ACN_Encode((&(pVal->climb)), pBitStrm, pErrCode, FALSE);
	                                                        if (ret) {
	                                                            /*Encode epc */
	                                                            ret = asn1SccT_Double_ACN_Encode((&(pVal->epc)), pBitStrm, pErrCode, FALSE);
	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccGPS_PVT_ACN_Decode(asn1SccGPS_PVT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	/*Decode mode */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 3);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_GPS_PVT_MODE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            pVal->mode = asn1Sccnot_seen;
	            break;
	        case 1:
	            pVal->mode = asn1Sccno_fix;
	            break;
	        case 2:
	            pVal->mode = asn1Scctwo_dims;
	            break;
	        case 3:
	            pVal->mode = asn1Sccthree_dims;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_GPS_PVT_MODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/
	if (ret) {
	    /*Decode date_and_time */
	    ret = asn1SccT_Double_ACN_Decode((&(pVal->date_and_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode ept */
	        ret = asn1SccT_Double_ACN_Decode((&(pVal->ept)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode latitude */
	            ret = asn1SccT_Double_ACN_Decode((&(pVal->latitude)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode epy */
	                ret = asn1SccT_Double_ACN_Decode((&(pVal->epy)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode longitude */
	                    ret = asn1SccT_Double_ACN_Decode((&(pVal->longitude)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode epx */
	                        ret = asn1SccT_Double_ACN_Decode((&(pVal->epx)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode altitude */
	                            ret = asn1SccT_Double_ACN_Decode((&(pVal->altitude)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode epv */
	                                ret = asn1SccT_Double_ACN_Decode((&(pVal->epv)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode course */
	                                    ret = asn1SccT_Double_ACN_Decode((&(pVal->course)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode epd */
	                                        ret = asn1SccT_Double_ACN_Decode((&(pVal->epd)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode speed */
	                                            ret = asn1SccT_Double_ACN_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode eps */
	                                                ret = asn1SccT_Double_ACN_Decode((&(pVal->eps)), pBitStrm, pErrCode);
	                                                if (ret) {
	                                                    /*Decode climb */
	                                                    ret = asn1SccT_Double_ACN_Decode((&(pVal->climb)), pBitStrm, pErrCode);
	                                                    if (ret) {
	                                                        /*Decode epc */
	                                                        ret = asn1SccT_Double_ACN_Decode((&(pVal->epc)), pBitStrm, pErrCode);
	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && asn1SccGPS_PVT_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccFile_Name_Equal(const asn1SccFile_Name* pVal1, const asn1SccFile_Name* pVal2)
{
	return memcmp(pVal1->arr, pVal2->arr, 81) ==0	;

}

void asn1SccFile_Name_Initialize(asn1SccFile_Name* pVal)
{
	(void)pVal;


	memset(pVal->arr, 0x0, 81);


}

flag asn1SccFile_Name_IsConstraintValid(const asn1SccFile_Name* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccFile_Name_Encode(const asn1SccFile_Name* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? asn1SccFile_Name_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)81) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccFile_Name_Decode(asn1SccFile_Name* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)81) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_FILE_NAME;
	}

	return ret  && asn1SccFile_Name_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccFile_Name_ACN_Encode(const asn1SccFile_Name* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? asn1SccFile_Name_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)81) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccFile_Name_ACN_Decode(asn1SccFile_Name* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)81) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_FILE_NAME;
	}

    return ret && asn1SccFile_Name_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccContent_Validity_Equal(const asn1SccContent_Validity* pVal1, const asn1SccContent_Validity* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccContent_Validity_Initialize(asn1SccContent_Validity* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1Sccvalid;
}

flag asn1SccContent_Validity_IsConstraintValid(const asn1SccContent_Validity* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == asn1Sccvalid)) || (((*(pVal)) == asn1Sccinvalid)));
    *pErrCode = ret ? 0 :  ERR_CONTENT_VALIDITY; 

	return ret;
}

flag asn1SccContent_Validity_Encode(const asn1SccContent_Validity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccContent_Validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccvalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case asn1Sccinvalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_CONTENT_VALIDITY; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccContent_Validity_Decode(asn1SccContent_Validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_CONTENT_VALIDITY;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccvalid;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccinvalid;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_CONTENT_VALIDITY;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccvalid;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccContent_Validity_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccContent_Validity_ACN_Encode(const asn1SccContent_Validity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccContent_Validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccvalid:
	            uIntVal = 0;
	            break;
	        case asn1Sccinvalid:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_CONTENT_VALIDITY;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccContent_Validity_ACN_Decode(asn1SccContent_Validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_CONTENT_VALIDITY;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1Sccvalid;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccinvalid;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_CONTENT_VALIDITY;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccContent_Validity_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccIMU_All_Data_Equal(const asn1SccIMU_All_Data* pVal1, const asn1SccIMU_All_Data* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccMGT_Raw_Data_Equal((&(pVal1->mgt_raw)), (&(pVal2->mgt_raw)));

    if (ret) {
        ret = asn1SccMGT_MilliGauss_Data_Equal((&(pVal1->mgt_mgauss)), (&(pVal2->mgt_mgauss)));

        if (ret) {
            ret = asn1SccACC_Raw_Data_Equal((&(pVal1->accel_raw)), (&(pVal2->accel_raw)));

            if (ret) {
                ret = asn1SccACC_MilliG_Data_Equal((&(pVal1->accel_mg)), (&(pVal2->accel_mg)));

                if (ret) {
                    ret = asn1SccGYRO_Raw_Data_Equal((&(pVal1->gyro_raw)), (&(pVal2->gyro_raw)));

                    if (ret) {
                        ret = asn1SccGYRO_MilliDPS_Data_Equal((&(pVal1->gyro_mdps)), (&(pVal2->gyro_mdps)));

                        if (ret) {
                            ret = (pVal1->temp_raw == pVal2->temp_raw);

                            if (ret) {
                                ret = (pVal1->temp_celsius == pVal2->temp_celsius);

                                if (ret) {
                                    ret = (pVal1->mgt_valid == pVal2->mgt_valid);

                                    if (ret) {
                                        ret = (pVal1->acc_valid == pVal2->acc_valid);

                                        if (ret) {
                                            ret = (pVal1->gyro_valid == pVal2->gyro_valid);

                                            if (ret) {
                                                ret = (pVal1->temp_valid == pVal2->temp_valid);

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void asn1SccIMU_All_Data_Initialize(asn1SccIMU_All_Data* pVal)
{
	(void)pVal;



	/*set mgt_raw */
	asn1SccMGT_Raw_Data_Initialize((&(pVal->mgt_raw)));
	/*set mgt_mgauss */
	asn1SccMGT_MilliGauss_Data_Initialize((&(pVal->mgt_mgauss)));
	/*set accel_raw */
	asn1SccACC_Raw_Data_Initialize((&(pVal->accel_raw)));
	/*set accel_mg */
	asn1SccACC_MilliG_Data_Initialize((&(pVal->accel_mg)));
	/*set gyro_raw */
	asn1SccGYRO_Raw_Data_Initialize((&(pVal->gyro_raw)));
	/*set gyro_mdps */
	asn1SccGYRO_MilliDPS_Data_Initialize((&(pVal->gyro_mdps)));
	/*set temp_raw */
	asn1SccT_Int16_Initialize((&(pVal->temp_raw)));
	/*set temp_celsius */
	asn1SccT_Float_Initialize((&(pVal->temp_celsius)));
	/*set mgt_valid */
	asn1SccContent_Validity_Initialize((&(pVal->mgt_valid)));
	/*set acc_valid */
	asn1SccContent_Validity_Initialize((&(pVal->acc_valid)));
	/*set gyro_valid */
	asn1SccContent_Validity_Initialize((&(pVal->gyro_valid)));
	/*set temp_valid */
	asn1SccContent_Validity_Initialize((&(pVal->temp_valid)));
}

flag asn1SccIMU_All_Data_IsConstraintValid(const asn1SccIMU_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccMGT_Raw_Data_IsConstraintValid((&(pVal->mgt_raw)), pErrCode);
    if (ret) {
        ret = asn1SccMGT_MilliGauss_Data_IsConstraintValid((&(pVal->mgt_mgauss)), pErrCode);
        if (ret) {
            ret = asn1SccACC_Raw_Data_IsConstraintValid((&(pVal->accel_raw)), pErrCode);
            if (ret) {
                ret = asn1SccACC_MilliG_Data_IsConstraintValid((&(pVal->accel_mg)), pErrCode);
                if (ret) {
                    ret = asn1SccGYRO_Raw_Data_IsConstraintValid((&(pVal->gyro_raw)), pErrCode);
                    if (ret) {
                        ret = asn1SccGYRO_MilliDPS_Data_IsConstraintValid((&(pVal->gyro_mdps)), pErrCode);
                        if (ret) {
                            ret = asn1SccT_Int16_IsConstraintValid((&(pVal->temp_raw)), pErrCode);
                            if (ret) {
                                ret = asn1SccT_Float_IsConstraintValid((&(pVal->temp_celsius)), pErrCode);
                                if (ret) {
                                    ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->mgt_valid)), pErrCode);
                                    if (ret) {
                                        ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->acc_valid)), pErrCode);
                                        if (ret) {
                                            ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->gyro_valid)), pErrCode);
                                            if (ret) {
                                                ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->temp_valid)), pErrCode);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccIMU_All_Data_Encode(const asn1SccIMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccIMU_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mgt_raw */
	    ret = asn1SccMGT_Raw_Data_Encode((&(pVal->mgt_raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode mgt_mgauss */
	        ret = asn1SccMGT_MilliGauss_Data_Encode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode accel_raw */
	            ret = asn1SccACC_Raw_Data_Encode((&(pVal->accel_raw)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode accel_mg */
	                ret = asn1SccACC_MilliG_Data_Encode((&(pVal->accel_mg)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gyro_raw */
	                    ret = asn1SccGYRO_Raw_Data_Encode((&(pVal->gyro_raw)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode gyro_mdps */
	                        ret = asn1SccGYRO_MilliDPS_Data_Encode((&(pVal->gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode temp_raw */
	                            ret = asn1SccT_Int16_Encode((&(pVal->temp_raw)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode temp_celsius */
	                                ret = asn1SccT_Float_Encode((&(pVal->temp_celsius)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode mgt_valid */
	                                    ret = asn1SccContent_Validity_Encode((&(pVal->mgt_valid)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode acc_valid */
	                                        ret = asn1SccContent_Validity_Encode((&(pVal->acc_valid)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode gyro_valid */
	                                            ret = asn1SccContent_Validity_Encode((&(pVal->gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode temp_valid */
	                                                ret = asn1SccContent_Validity_Encode((&(pVal->temp_valid)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccIMU_All_Data_Decode(asn1SccIMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mgt_raw */
	ret = asn1SccMGT_Raw_Data_Decode((&(pVal->mgt_raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode mgt_mgauss */
	    ret = asn1SccMGT_MilliGauss_Data_Decode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode accel_raw */
	        ret = asn1SccACC_Raw_Data_Decode((&(pVal->accel_raw)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode accel_mg */
	            ret = asn1SccACC_MilliG_Data_Decode((&(pVal->accel_mg)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gyro_raw */
	                ret = asn1SccGYRO_Raw_Data_Decode((&(pVal->gyro_raw)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode gyro_mdps */
	                    ret = asn1SccGYRO_MilliDPS_Data_Decode((&(pVal->gyro_mdps)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode temp_raw */
	                        ret = asn1SccT_Int16_Decode((&(pVal->temp_raw)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode temp_celsius */
	                            ret = asn1SccT_Float_Decode((&(pVal->temp_celsius)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode mgt_valid */
	                                ret = asn1SccContent_Validity_Decode((&(pVal->mgt_valid)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode acc_valid */
	                                    ret = asn1SccContent_Validity_Decode((&(pVal->acc_valid)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode gyro_valid */
	                                        ret = asn1SccContent_Validity_Decode((&(pVal->gyro_valid)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode temp_valid */
	                                            ret = asn1SccContent_Validity_Decode((&(pVal->temp_valid)), pBitStrm, pErrCode);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccIMU_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccIMU_All_Data_ACN_Encode(const asn1SccIMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccIMU_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode mgt_raw */
	    ret = asn1SccMGT_Raw_Data_ACN_Encode((&(pVal->mgt_raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode mgt_mgauss */
	        ret = asn1SccMGT_MilliGauss_Data_ACN_Encode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode accel_raw */
	            ret = asn1SccACC_Raw_Data_ACN_Encode((&(pVal->accel_raw)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode accel_mg */
	                ret = asn1SccACC_MilliG_Data_ACN_Encode((&(pVal->accel_mg)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gyro_raw */
	                    ret = asn1SccGYRO_Raw_Data_ACN_Encode((&(pVal->gyro_raw)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode gyro_mdps */
	                        ret = asn1SccGYRO_MilliDPS_Data_ACN_Encode((&(pVal->gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode temp_raw */
	                            ret = asn1SccT_Int16_ACN_Encode((&(pVal->temp_raw)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode temp_celsius */
	                                ret = asn1SccT_Float_ACN_Encode((&(pVal->temp_celsius)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode mgt_valid */
	                                    ret = asn1SccContent_Validity_ACN_Encode((&(pVal->mgt_valid)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode acc_valid */
	                                        ret = asn1SccContent_Validity_ACN_Encode((&(pVal->acc_valid)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode gyro_valid */
	                                            ret = asn1SccContent_Validity_ACN_Encode((&(pVal->gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode temp_valid */
	                                                ret = asn1SccContent_Validity_ACN_Encode((&(pVal->temp_valid)), pBitStrm, pErrCode, FALSE);
	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccIMU_All_Data_ACN_Decode(asn1SccIMU_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mgt_raw */
	ret = asn1SccMGT_Raw_Data_ACN_Decode((&(pVal->mgt_raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode mgt_mgauss */
	    ret = asn1SccMGT_MilliGauss_Data_ACN_Decode((&(pVal->mgt_mgauss)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode accel_raw */
	        ret = asn1SccACC_Raw_Data_ACN_Decode((&(pVal->accel_raw)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode accel_mg */
	            ret = asn1SccACC_MilliG_Data_ACN_Decode((&(pVal->accel_mg)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gyro_raw */
	                ret = asn1SccGYRO_Raw_Data_ACN_Decode((&(pVal->gyro_raw)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode gyro_mdps */
	                    ret = asn1SccGYRO_MilliDPS_Data_ACN_Decode((&(pVal->gyro_mdps)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode temp_raw */
	                        ret = asn1SccT_Int16_ACN_Decode((&(pVal->temp_raw)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode temp_celsius */
	                            ret = asn1SccT_Float_ACN_Decode((&(pVal->temp_celsius)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode mgt_valid */
	                                ret = asn1SccContent_Validity_ACN_Decode((&(pVal->mgt_valid)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode acc_valid */
	                                    ret = asn1SccContent_Validity_ACN_Decode((&(pVal->acc_valid)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode gyro_valid */
	                                        ret = asn1SccContent_Validity_ACN_Decode((&(pVal->gyro_valid)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode temp_valid */
	                                            ret = asn1SccContent_Validity_ACN_Decode((&(pVal->temp_valid)), pBitStrm, pErrCode);
	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && asn1SccIMU_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccTC74s_All_Data_elem_Equal(const asn1SccTC74s_All_Data_elem* pVal1, const asn1SccTC74s_All_Data_elem* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->temperature == pVal2->temperature);

    if (ret) {
        ret = (pVal1->validity == pVal2->validity);

    }

	return ret;

}

flag asn1SccTC74s_All_Data_Equal(const asn1SccTC74s_All_Data* pVal1, const asn1SccTC74s_All_Data* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = asn1SccTC74s_All_Data_elem_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

void asn1SccTC74s_All_Data_elem_Initialize(asn1SccTC74s_All_Data_elem* pVal)
{
	(void)pVal;



	/*set temperature */
	asn1SccT_Float_Initialize((&(pVal->temperature)));
	/*set validity */
	asn1SccContent_Validity_Initialize((&(pVal->validity)));
}
void asn1SccTC74s_All_Data_Initialize(asn1SccTC74s_All_Data* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 5) {
	    asn1SccTC74s_All_Data_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccTC74s_All_Data_IsConstraintValid(const asn1SccTC74s_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1].temperature)), pErrCode);
    	if (ret) {
    	    ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->arr[i1].validity)), pErrCode);
    	}
    }

	return ret;
}

flag asn1SccTC74s_All_Data_Encode(const asn1SccTC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? asn1SccTC74s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	/*Encode temperature */
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode validity */
	    	    ret = asn1SccContent_Validity_Encode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTC74s_All_Data_Decode(asn1SccTC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		/*Decode temperature */
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode);
		if (ret) {
		    /*Decode validity */
		    ret = asn1SccContent_Validity_Decode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode);
		}
	}

	return ret  && asn1SccTC74s_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccTC74s_All_Data_ACN_Encode(const asn1SccTC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? asn1SccTC74s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	/*Encode temperature */
	    	ret = asn1SccT_Float_ACN_Encode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode validity */
	    	    ret = asn1SccContent_Validity_ACN_Encode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode, FALSE);
	    	}

	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTC74s_All_Data_ACN_Decode(asn1SccTC74s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		/*Decode temperature */
		ret = asn1SccT_Float_ACN_Decode((&(pVal->arr[i1].temperature)), pBitStrm, pErrCode);
		if (ret) {
		    /*Decode validity */
		    ret = asn1SccContent_Validity_ACN_Decode((&(pVal->arr[i1].validity)), pBitStrm, pErrCode);
		}

	}

    return ret && asn1SccTC74s_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPT1000s_All_Data_validity_Equal(const asn1SccPT1000s_All_Data_validity* pVal1, const asn1SccPT1000s_All_Data_validity* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag asn1SccPT1000s_All_Data_Equal(const asn1SccPT1000s_All_Data* pVal1, const asn1SccPT1000s_All_Data* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPT1000s_Raw_Data_Equal((&(pVal1->raw)), (&(pVal2->raw)));

    if (ret) {
        ret = asn1SccPT1000s_Celsius_Data_Equal((&(pVal1->celsius)), (&(pVal2->celsius)));

        if (ret) {
            ret = asn1SccPT1000s_All_Data_validity_Equal((&(pVal1->validity)), (&(pVal2->validity)));

        }

    }

	return ret;

}

void asn1SccPT1000s_All_Data_validity_Initialize(asn1SccPT1000s_All_Data_validity* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 7) {
	    asn1SccContent_Validity_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void asn1SccPT1000s_All_Data_Initialize(asn1SccPT1000s_All_Data* pVal)
{
	(void)pVal;



	/*set raw */
	asn1SccPT1000s_Raw_Data_Initialize((&(pVal->raw)));
	/*set celsius */
	asn1SccPT1000s_Celsius_Data_Initialize((&(pVal->celsius)));
	/*set validity */
	asn1SccPT1000s_All_Data_validity_Initialize((&(pVal->validity)));
}

flag asn1SccPT1000s_All_Data_IsConstraintValid(const asn1SccPT1000s_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = asn1SccPT1000s_Raw_Data_IsConstraintValid((&(pVal->raw)), pErrCode);
    if (ret) {
        ret = asn1SccPT1000s_Celsius_Data_IsConstraintValid((&(pVal->celsius)), pErrCode);
        if (ret) {
            for(i1 = 0; ret && i1 < 7; i1++) 
            {
            	ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->validity.arr[i1])), pErrCode);
            }
        }
    }

	return ret;
}

flag asn1SccPT1000s_All_Data_Encode(const asn1SccPT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? asn1SccPT1000s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode raw */
	    ret = asn1SccPT1000s_Raw_Data_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode celsius */
	        ret = asn1SccPT1000s_Celsius_Data_Encode((&(pVal->celsius)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            	
	            for(i1=0; (i1 < (int)7) && ret; i1++) 
	            {
	            	ret = asn1SccContent_Validity_Encode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPT1000s_All_Data_Decode(asn1SccPT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode raw */
	ret = asn1SccPT1000s_Raw_Data_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode celsius */
	    ret = asn1SccPT1000s_Celsius_Data_Decode((&(pVal->celsius)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        	
	        for(i1=0; (i1 < (int)7) && ret; i1++) 
	        {
	        	ret = asn1SccContent_Validity_Decode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccPT1000s_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPT1000s_All_Data_ACN_Encode(const asn1SccPT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? asn1SccPT1000s_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode raw */
	    ret = asn1SccPT1000s_Raw_Data_ACN_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode celsius */
	        ret = asn1SccPT1000s_Celsius_Data_ACN_Encode((&(pVal->celsius)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            	
	            for(i1=0; (i1 < (int)7) && ret; i1++) 
	            {
	            	ret = asn1SccContent_Validity_ACN_Encode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPT1000s_All_Data_ACN_Decode(asn1SccPT1000s_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode raw */
	ret = asn1SccPT1000s_Raw_Data_ACN_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode celsius */
	    ret = asn1SccPT1000s_Celsius_Data_ACN_Decode((&(pVal->celsius)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        	
	        for(i1=0; (i1 < (int)7) && ret; i1++) 
	        {
	        	ret = asn1SccContent_Validity_ACN_Decode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode);
	        }
	    }

	}


    return ret && asn1SccPT1000s_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccHeater_Data_Equal(const asn1SccHeater_Data* pVal1, const asn1SccHeater_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->power_watts == pVal2->power_watts);

    if (ret) {
        ret = (pVal1->validity == pVal2->validity);

    }

	return ret;

}

void asn1SccHeater_Data_Initialize(asn1SccHeater_Data* pVal)
{
	(void)pVal;



	/*set power_watts */
	asn1SccT_Float_Initialize((&(pVal->power_watts)));
	/*set validity */
	asn1SccContent_Validity_Initialize((&(pVal->validity)));
}

flag asn1SccHeater_Data_IsConstraintValid(const asn1SccHeater_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_Float_IsConstraintValid((&(pVal->power_watts)), pErrCode);
    if (ret) {
        ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->validity)), pErrCode);
    }

	return ret;
}

flag asn1SccHeater_Data_Encode(const asn1SccHeater_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccHeater_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode power_watts */
	    ret = asn1SccT_Float_Encode((&(pVal->power_watts)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode validity */
	        ret = asn1SccContent_Validity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccHeater_Data_Decode(asn1SccHeater_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode power_watts */
	ret = asn1SccT_Float_Decode((&(pVal->power_watts)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode validity */
	    ret = asn1SccContent_Validity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccHeater_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccHeater_Data_ACN_Encode(const asn1SccHeater_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccHeater_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode power_watts */
	    ret = asn1SccT_Float_ACN_Encode((&(pVal->power_watts)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode validity */
	        ret = asn1SccContent_Validity_ACN_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccHeater_Data_ACN_Decode(asn1SccHeater_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode power_watts */
	ret = asn1SccT_Float_ACN_Decode((&(pVal->power_watts)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode validity */
	    ret = asn1SccContent_Validity_ACN_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	}


    return ret && asn1SccHeater_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPS_GUI_Equal(const asn1SccPS_GUI* pVal1, const asn1SccPS_GUI* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->pressure_mbar == pVal2->pressure_mbar);

    if (ret) {
        ret = (pVal1->temperature_celsius == pVal2->temperature_celsius);

        if (ret) {
            ret = (pVal1->validity == pVal2->validity);

        }

    }

	return ret;

}

void asn1SccPS_GUI_Initialize(asn1SccPS_GUI* pVal)
{
	(void)pVal;



	/*set pressure_mbar */
	asn1SccT_Double_Initialize((&(pVal->pressure_mbar)));
	/*set temperature_celsius */
	asn1SccT_Double_Initialize((&(pVal->temperature_celsius)));
	/*set validity */
	asn1SccContent_Validity_Initialize((&(pVal->validity)));
}

flag asn1SccPS_GUI_IsConstraintValid(const asn1SccPS_GUI* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_Double_IsConstraintValid((&(pVal->pressure_mbar)), pErrCode);
    if (ret) {
        ret = asn1SccT_Double_IsConstraintValid((&(pVal->temperature_celsius)), pErrCode);
        if (ret) {
            ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->validity)), pErrCode);
        }
    }

	return ret;
}

flag asn1SccPS_GUI_Encode(const asn1SccPS_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccPS_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure_mbar */
	    ret = asn1SccT_Double_Encode((&(pVal->pressure_mbar)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode temperature_celsius */
	        ret = asn1SccT_Double_Encode((&(pVal->temperature_celsius)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            ret = asn1SccContent_Validity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPS_GUI_Decode(asn1SccPS_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure_mbar */
	ret = asn1SccT_Double_Decode((&(pVal->pressure_mbar)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode temperature_celsius */
	    ret = asn1SccT_Double_Decode((&(pVal->temperature_celsius)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        ret = asn1SccContent_Validity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccPS_GUI_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPS_GUI_ACN_Encode(const asn1SccPS_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccPS_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure_mbar */
	    ret = asn1SccT_Double_ACN_Encode((&(pVal->pressure_mbar)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode temperature_celsius */
	        ret = asn1SccT_Double_ACN_Encode((&(pVal->temperature_celsius)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            ret = asn1SccContent_Validity_ACN_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPS_GUI_ACN_Decode(asn1SccPS_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure_mbar */
	ret = asn1SccT_Double_ACN_Decode((&(pVal->pressure_mbar)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode temperature_celsius */
	    ret = asn1SccT_Double_ACN_Decode((&(pVal->temperature_celsius)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        ret = asn1SccContent_Validity_ACN_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	    }

	}


    return ret && asn1SccPS_GUI_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccENV_GUI_anemometer_Equal(const asn1SccENV_GUI_anemometer* pVal1, const asn1SccENV_GUI_anemometer* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->global_counter == pVal2->global_counter);

    if (ret) {
        ret = (pVal1->temperature_celsius == pVal2->temperature_celsius);

        if (ret) {
            ret = (pVal1->temperature_validity == pVal2->temperature_validity);

        }

    }

	return ret;

}

flag asn1SccENV_GUI_Equal(const asn1SccENV_GUI* pVal1, const asn1SccENV_GUI* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPS_GUI_Equal((&(pVal1->pressure_sensor_1)), (&(pVal2->pressure_sensor_1)));

    if (ret) {
        ret = asn1SccPS_GUI_Equal((&(pVal1->pressure_sensor_2)), (&(pVal2->pressure_sensor_2)));

        if (ret) {
            ret = asn1SccENV_GUI_anemometer_Equal((&(pVal1->anemometer)), (&(pVal2->anemometer)));

            if (ret) {
                ret = asn1SccHeater_Data_Equal((&(pVal1->heater)), (&(pVal2->heater)));

            }

        }

    }

	return ret;

}

void asn1SccENV_GUI_anemometer_Initialize(asn1SccENV_GUI_anemometer* pVal)
{
	(void)pVal;



	/*set global_counter */
	asn1SccT_UInt64_Initialize((&(pVal->global_counter)));
	/*set temperature_celsius */
	asn1SccT_Float_Initialize((&(pVal->temperature_celsius)));
	/*set temperature_validity */
	asn1SccContent_Validity_Initialize((&(pVal->temperature_validity)));
}
void asn1SccENV_GUI_Initialize(asn1SccENV_GUI* pVal)
{
	(void)pVal;



	/*set pressure_sensor_1 */
	asn1SccPS_GUI_Initialize((&(pVal->pressure_sensor_1)));
	/*set pressure_sensor_2 */
	asn1SccPS_GUI_Initialize((&(pVal->pressure_sensor_2)));
	/*set anemometer */
	asn1SccENV_GUI_anemometer_Initialize((&(pVal->anemometer)));
	/*set heater */
	asn1SccHeater_Data_Initialize((&(pVal->heater)));
}

flag asn1SccENV_GUI_IsConstraintValid(const asn1SccENV_GUI* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPS_GUI_IsConstraintValid((&(pVal->pressure_sensor_1)), pErrCode);
    if (ret) {
        ret = asn1SccPS_GUI_IsConstraintValid((&(pVal->pressure_sensor_2)), pErrCode);
        if (ret) {
            ret = asn1SccT_UInt64_IsConstraintValid((&(pVal->anemometer.global_counter)), pErrCode);
            if (ret) {
                ret = asn1SccT_Float_IsConstraintValid((&(pVal->anemometer.temperature_celsius)), pErrCode);
                if (ret) {
                    ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->anemometer.temperature_validity)), pErrCode);
                }
            }
            if (ret) {
                ret = asn1SccHeater_Data_IsConstraintValid((&(pVal->heater)), pErrCode);
            }
        }
    }

	return ret;
}

flag asn1SccENV_GUI_Encode(const asn1SccENV_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccENV_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure_sensor_1 */
	    ret = asn1SccPS_GUI_Encode((&(pVal->pressure_sensor_1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pressure_sensor_2 */
	        ret = asn1SccPS_GUI_Encode((&(pVal->pressure_sensor_2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode anemometer */
	            /*Encode global_counter */
	            ret = asn1SccT_UInt64_Encode((&(pVal->anemometer.global_counter)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode temperature_celsius */
	                ret = asn1SccT_Float_Encode((&(pVal->anemometer.temperature_celsius)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode temperature_validity */
	                    ret = asn1SccContent_Validity_Encode((&(pVal->anemometer.temperature_validity)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	            if (ret) {
	                /*Encode heater */
	                ret = asn1SccHeater_Data_Encode((&(pVal->heater)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccENV_GUI_Decode(asn1SccENV_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure_sensor_1 */
	ret = asn1SccPS_GUI_Decode((&(pVal->pressure_sensor_1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pressure_sensor_2 */
	    ret = asn1SccPS_GUI_Decode((&(pVal->pressure_sensor_2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode anemometer */
	        /*Decode global_counter */
	        ret = asn1SccT_UInt64_Decode((&(pVal->anemometer.global_counter)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode temperature_celsius */
	            ret = asn1SccT_Float_Decode((&(pVal->anemometer.temperature_celsius)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode temperature_validity */
	                ret = asn1SccContent_Validity_Decode((&(pVal->anemometer.temperature_validity)), pBitStrm, pErrCode);
	            }
	        }
	        if (ret) {
	            /*Decode heater */
	            ret = asn1SccHeater_Data_Decode((&(pVal->heater)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccENV_GUI_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccENV_GUI_ACN_Encode(const asn1SccENV_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccENV_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure_sensor_1 */
	    ret = asn1SccPS_GUI_ACN_Encode((&(pVal->pressure_sensor_1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pressure_sensor_2 */
	        ret = asn1SccPS_GUI_ACN_Encode((&(pVal->pressure_sensor_2)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode anemometer */
	            /*Encode global_counter */
	            ret = asn1SccT_UInt64_ACN_Encode((&(pVal->anemometer.global_counter)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode temperature_celsius */
	                ret = asn1SccT_Float_ACN_Encode((&(pVal->anemometer.temperature_celsius)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode temperature_validity */
	                    ret = asn1SccContent_Validity_ACN_Encode((&(pVal->anemometer.temperature_validity)), pBitStrm, pErrCode, FALSE);
	                }

	            }

	            if (ret) {
	                /*Encode heater */
	                ret = asn1SccHeater_Data_ACN_Encode((&(pVal->heater)), pBitStrm, pErrCode, FALSE);
	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccENV_GUI_ACN_Decode(asn1SccENV_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure_sensor_1 */
	ret = asn1SccPS_GUI_ACN_Decode((&(pVal->pressure_sensor_1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pressure_sensor_2 */
	    ret = asn1SccPS_GUI_ACN_Decode((&(pVal->pressure_sensor_2)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode anemometer */
	        /*Decode global_counter */
	        ret = asn1SccT_UInt64_ACN_Decode((&(pVal->anemometer.global_counter)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode temperature_celsius */
	            ret = asn1SccT_Float_ACN_Decode((&(pVal->anemometer.temperature_celsius)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode temperature_validity */
	                ret = asn1SccContent_Validity_ACN_Decode((&(pVal->anemometer.temperature_validity)), pBitStrm, pErrCode);
	            }

	        }

	        if (ret) {
	            /*Decode heater */
	            ret = asn1SccHeater_Data_ACN_Decode((&(pVal->heater)), pBitStrm, pErrCode);
	        }

	    }

	}


    return ret && asn1SccENV_GUI_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccHeater_On_Off_Equal(const asn1SccHeater_On_Off* pVal1, const asn1SccHeater_On_Off* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccHeater_On_Off_Initialize(asn1SccHeater_On_Off* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1Sccon;
}

flag asn1SccHeater_On_Off_IsConstraintValid(const asn1SccHeater_On_Off* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == asn1Sccon)) || (((*(pVal)) == asn1Sccoff)));
    *pErrCode = ret ? 0 :  ERR_HEATER_ON_OFF; 

	return ret;
}

flag asn1SccHeater_On_Off_Encode(const asn1SccHeater_On_Off* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccHeater_On_Off_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccon:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case asn1Sccoff:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_HEATER_ON_OFF; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccHeater_On_Off_Decode(asn1SccHeater_On_Off* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_HEATER_ON_OFF;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccon;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccoff;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_HEATER_ON_OFF;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccon;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccHeater_On_Off_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccHeater_On_Off_ACN_Encode(const asn1SccHeater_On_Off* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccHeater_On_Off_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccon:
	            uIntVal = 0;
	            break;
	        case asn1Sccoff:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_HEATER_ON_OFF;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 1);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccHeater_On_Off_ACN_Decode(asn1SccHeater_On_Off* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 1);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_HEATER_ON_OFF;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1Sccon;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccoff;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_HEATER_ON_OFF;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccHeater_On_Off_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccHTL_State_Equal(const asn1SccHTL_State* pVal1, const asn1SccHTL_State* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccHTL_State_Initialize(asn1SccHTL_State* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1Scca1;
}

flag asn1SccHTL_State_IsConstraintValid(const asn1SccHTL_State* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((*(pVal)) == asn1Scca1)) || (((*(pVal)) == asn1Scca2)))) || (((*(pVal)) == asn1Sccf1)))) || (((*(pVal)) == asn1Sccf2)))) || (((*(pVal)) == asn1Sccf3)))) || (((*(pVal)) == asn1Sccerror)));
    *pErrCode = ret ? 0 :  ERR_HTL_STATE; 

	return ret;
}

flag asn1SccHTL_State_Encode(const asn1SccHTL_State* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccHTL_State_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Scca1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case asn1Scca2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case asn1Sccf1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case asn1Sccf2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case asn1Sccf3:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case asn1Sccerror:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_HTL_STATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccHTL_State_Decode(asn1SccHTL_State* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_HTL_STATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Scca1;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Scca2;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Sccf1;
	                break;
	            case 3: 
	                (*(pVal)) = asn1Sccf2;
	                break;
	            case 4: 
	                (*(pVal)) = asn1Sccf3;
	                break;
	            case 5: 
	                (*(pVal)) = asn1Sccerror;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_HTL_STATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Scca1;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccHTL_State_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccHTL_State_ACN_Encode(const asn1SccHTL_State* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccHTL_State_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Scca1:
	            uIntVal = 0;
	            break;
	        case asn1Scca2:
	            uIntVal = 1;
	            break;
	        case asn1Sccf1:
	            uIntVal = 2;
	            break;
	        case asn1Sccf2:
	            uIntVal = 3;
	            break;
	        case asn1Sccf3:
	            uIntVal = 4;
	            break;
	        case asn1Sccerror:
	            uIntVal = 5;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_HTL_STATE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 5);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccHTL_State_ACN_Decode(asn1SccHTL_State* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 5);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_HTL_STATE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1Scca1;
	            break;
	        case 1:
	            (*(pVal)) = asn1Scca2;
	            break;
	        case 2:
	            (*(pVal)) = asn1Sccf1;
	            break;
	        case 3:
	            (*(pVal)) = asn1Sccf2;
	            break;
	        case 4:
	            (*(pVal)) = asn1Sccf3;
	            break;
	        case 5:
	            (*(pVal)) = asn1Sccerror;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_HTL_STATE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccHTL_State_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccHTL_GUI_pt1000s_validity_Equal(const asn1SccHTL_GUI_pt1000s_validity* pVal1, const asn1SccHTL_GUI_pt1000s_validity* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 6; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag asn1SccHTL_GUI_pt1000s_Equal(const asn1SccHTL_GUI_pt1000s* pVal1, const asn1SccHTL_GUI_pt1000s* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->aire_abajo == pVal2->aire_abajo);

    if (ret) {
        ret = (pVal1->aire_arriba == pVal2->aire_arriba);

        if (ret) {
            ret = (pVal1->placa_abajo == pVal2->placa_abajo);

            if (ret) {
                ret = (pVal1->placa_arriba == pVal2->placa_arriba);

                if (ret) {
                    ret = (pVal1->infinito == pVal2->infinito);

                    if (ret) {
                        ret = (pVal1->exterior == pVal2->exterior);

                        if (ret) {
                            ret = asn1SccHTL_GUI_pt1000s_validity_Equal((&(pVal1->validity)), (&(pVal2->validity)));

                        }

                    }

                }

            }

        }

    }

	return ret;

}

flag asn1SccHTL_GUI_tc74s_validity_Equal(const asn1SccHTL_GUI_tc74s_validity* pVal1, const asn1SccHTL_GUI_tc74s_validity* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

flag asn1SccHTL_GUI_tc74s_Equal(const asn1SccHTL_GUI_tc74s* pVal1, const asn1SccHTL_GUI_tc74s* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->x_positive == pVal2->x_positive);

    if (ret) {
        ret = (pVal1->x_negative == pVal2->x_negative);

        if (ret) {
            ret = (pVal1->y_positive == pVal2->y_positive);

            if (ret) {
                ret = (pVal1->y_negative == pVal2->y_negative);

                if (ret) {
                    ret = (pVal1->z_techo == pVal2->z_techo);

                    if (ret) {
                        ret = asn1SccHTL_GUI_tc74s_validity_Equal((&(pVal1->validity)), (&(pVal2->validity)));

                    }

                }

            }

        }

    }

	return ret;

}

flag asn1SccHTL_GUI_Equal(const asn1SccHTL_GUI* pVal1, const asn1SccHTL_GUI* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->state == pVal2->state);

    if (ret) {
        ret = asn1SccHeater_Data_Equal((&(pVal1->heater)), (&(pVal2->heater)));

        if (ret) {
            ret = (pVal1->delta_T == pVal2->delta_T);

            if (ret) {
                ret = asn1SccHTL_GUI_pt1000s_Equal((&(pVal1->pt1000s)), (&(pVal2->pt1000s)));

                if (ret) {
                    ret = asn1SccHTL_GUI_tc74s_Equal((&(pVal1->tc74s)), (&(pVal2->tc74s)));

                }

            }

        }

    }

	return ret;

}

void asn1SccHTL_GUI_pt1000s_validity_Initialize(asn1SccHTL_GUI_pt1000s_validity* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 6) {
	    asn1SccContent_Validity_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void asn1SccHTL_GUI_pt1000s_Initialize(asn1SccHTL_GUI_pt1000s* pVal)
{
	(void)pVal;



	/*set aire_abajo */
	asn1SccT_Float_Initialize((&(pVal->aire_abajo)));
	/*set aire_arriba */
	asn1SccT_Float_Initialize((&(pVal->aire_arriba)));
	/*set placa_abajo */
	asn1SccT_Float_Initialize((&(pVal->placa_abajo)));
	/*set placa_arriba */
	asn1SccT_Float_Initialize((&(pVal->placa_arriba)));
	/*set infinito */
	asn1SccT_Float_Initialize((&(pVal->infinito)));
	/*set exterior */
	asn1SccT_Float_Initialize((&(pVal->exterior)));
	/*set validity */
	asn1SccHTL_GUI_pt1000s_validity_Initialize((&(pVal->validity)));
}
void asn1SccHTL_GUI_tc74s_validity_Initialize(asn1SccHTL_GUI_tc74s_validity* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 5) {
	    asn1SccContent_Validity_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}
void asn1SccHTL_GUI_tc74s_Initialize(asn1SccHTL_GUI_tc74s* pVal)
{
	(void)pVal;



	/*set x_positive */
	asn1SccT_Float_Initialize((&(pVal->x_positive)));
	/*set x_negative */
	asn1SccT_Float_Initialize((&(pVal->x_negative)));
	/*set y_positive */
	asn1SccT_Float_Initialize((&(pVal->y_positive)));
	/*set y_negative */
	asn1SccT_Float_Initialize((&(pVal->y_negative)));
	/*set z_techo */
	asn1SccT_Float_Initialize((&(pVal->z_techo)));
	/*set validity */
	asn1SccHTL_GUI_tc74s_validity_Initialize((&(pVal->validity)));
}
void asn1SccHTL_GUI_Initialize(asn1SccHTL_GUI* pVal)
{
	(void)pVal;



	/*set state */
	asn1SccHTL_State_Initialize((&(pVal->state)));
	/*set heater */
	asn1SccHeater_Data_Initialize((&(pVal->heater)));
	/*set delta_T */
	asn1SccT_Float_Initialize((&(pVal->delta_T)));
	/*set pt1000s */
	asn1SccHTL_GUI_pt1000s_Initialize((&(pVal->pt1000s)));
	/*set tc74s */
	asn1SccHTL_GUI_tc74s_Initialize((&(pVal->tc74s)));
}

flag asn1SccHTL_GUI_IsConstraintValid(const asn1SccHTL_GUI* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = asn1SccHTL_State_IsConstraintValid((&(pVal->state)), pErrCode);
    if (ret) {
        ret = asn1SccHeater_Data_IsConstraintValid((&(pVal->heater)), pErrCode);
        if (ret) {
            ret = asn1SccT_Float_IsConstraintValid((&(pVal->delta_T)), pErrCode);
            if (ret) {
                ret = asn1SccT_Float_IsConstraintValid((&(pVal->pt1000s.aire_abajo)), pErrCode);
                if (ret) {
                    ret = asn1SccT_Float_IsConstraintValid((&(pVal->pt1000s.aire_arriba)), pErrCode);
                    if (ret) {
                        ret = asn1SccT_Float_IsConstraintValid((&(pVal->pt1000s.placa_abajo)), pErrCode);
                        if (ret) {
                            ret = asn1SccT_Float_IsConstraintValid((&(pVal->pt1000s.placa_arriba)), pErrCode);
                            if (ret) {
                                ret = asn1SccT_Float_IsConstraintValid((&(pVal->pt1000s.infinito)), pErrCode);
                                if (ret) {
                                    ret = asn1SccT_Float_IsConstraintValid((&(pVal->pt1000s.exterior)), pErrCode);
                                    if (ret) {
                                        for(i1 = 0; ret && i1 < 6; i1++) 
                                        {
                                        	ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->pt1000s.validity.arr[i1])), pErrCode);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (ret) {
                    ret = asn1SccT_Float_IsConstraintValid((&(pVal->tc74s.x_positive)), pErrCode);
                    if (ret) {
                        ret = asn1SccT_Float_IsConstraintValid((&(pVal->tc74s.x_negative)), pErrCode);
                        if (ret) {
                            ret = asn1SccT_Float_IsConstraintValid((&(pVal->tc74s.y_positive)), pErrCode);
                            if (ret) {
                                ret = asn1SccT_Float_IsConstraintValid((&(pVal->tc74s.y_negative)), pErrCode);
                                if (ret) {
                                    ret = asn1SccT_Float_IsConstraintValid((&(pVal->tc74s.z_techo)), pErrCode);
                                    if (ret) {
                                        for(i1 = 0; ret && i1 < 5; i1++) 
                                        {
                                        	ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->tc74s.validity.arr[i1])), pErrCode);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccHTL_GUI_Encode(const asn1SccHTL_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? asn1SccHTL_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode state */
	    ret = asn1SccHTL_State_Encode((&(pVal->state)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heater */
	        ret = asn1SccHeater_Data_Encode((&(pVal->heater)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode delta_T */
	            ret = asn1SccT_Float_Encode((&(pVal->delta_T)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode pt1000s */
	                /*Encode aire_abajo */
	                ret = asn1SccT_Float_Encode((&(pVal->pt1000s.aire_abajo)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode aire_arriba */
	                    ret = asn1SccT_Float_Encode((&(pVal->pt1000s.aire_arriba)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode placa_abajo */
	                        ret = asn1SccT_Float_Encode((&(pVal->pt1000s.placa_abajo)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode placa_arriba */
	                            ret = asn1SccT_Float_Encode((&(pVal->pt1000s.placa_arriba)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode infinito */
	                                ret = asn1SccT_Float_Encode((&(pVal->pt1000s.infinito)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode exterior */
	                                    ret = asn1SccT_Float_Encode((&(pVal->pt1000s.exterior)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode validity */
	                                        	
	                                        for(i1=0; (i1 < (int)6) && ret; i1++) 
	                                        {
	                                        	ret = asn1SccContent_Validity_Encode((&(pVal->pt1000s.validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	                if (ret) {
	                    /*Encode tc74s */
	                    /*Encode x_positive */
	                    ret = asn1SccT_Float_Encode((&(pVal->tc74s.x_positive)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode x_negative */
	                        ret = asn1SccT_Float_Encode((&(pVal->tc74s.x_negative)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode y_positive */
	                            ret = asn1SccT_Float_Encode((&(pVal->tc74s.y_positive)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode y_negative */
	                                ret = asn1SccT_Float_Encode((&(pVal->tc74s.y_negative)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode z_techo */
	                                    ret = asn1SccT_Float_Encode((&(pVal->tc74s.z_techo)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode validity */
	                                        	
	                                        for(i1=0; (i1 < (int)5) && ret; i1++) 
	                                        {
	                                        	ret = asn1SccContent_Validity_Encode((&(pVal->tc74s.validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccHTL_GUI_Decode(asn1SccHTL_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode state */
	ret = asn1SccHTL_State_Decode((&(pVal->state)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heater */
	    ret = asn1SccHeater_Data_Decode((&(pVal->heater)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode delta_T */
	        ret = asn1SccT_Float_Decode((&(pVal->delta_T)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode pt1000s */
	            /*Decode aire_abajo */
	            ret = asn1SccT_Float_Decode((&(pVal->pt1000s.aire_abajo)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode aire_arriba */
	                ret = asn1SccT_Float_Decode((&(pVal->pt1000s.aire_arriba)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode placa_abajo */
	                    ret = asn1SccT_Float_Decode((&(pVal->pt1000s.placa_abajo)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode placa_arriba */
	                        ret = asn1SccT_Float_Decode((&(pVal->pt1000s.placa_arriba)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode infinito */
	                            ret = asn1SccT_Float_Decode((&(pVal->pt1000s.infinito)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode exterior */
	                                ret = asn1SccT_Float_Decode((&(pVal->pt1000s.exterior)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode validity */
	                                    	
	                                    for(i1=0; (i1 < (int)6) && ret; i1++) 
	                                    {
	                                    	ret = asn1SccContent_Validity_Decode((&(pVal->pt1000s.validity.arr[i1])), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            if (ret) {
	                /*Decode tc74s */
	                /*Decode x_positive */
	                ret = asn1SccT_Float_Decode((&(pVal->tc74s.x_positive)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode x_negative */
	                    ret = asn1SccT_Float_Decode((&(pVal->tc74s.x_negative)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode y_positive */
	                        ret = asn1SccT_Float_Decode((&(pVal->tc74s.y_positive)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode y_negative */
	                            ret = asn1SccT_Float_Decode((&(pVal->tc74s.y_negative)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode z_techo */
	                                ret = asn1SccT_Float_Decode((&(pVal->tc74s.z_techo)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode validity */
	                                    	
	                                    for(i1=0; (i1 < (int)5) && ret; i1++) 
	                                    {
	                                    	ret = asn1SccContent_Validity_Decode((&(pVal->tc74s.validity.arr[i1])), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccHTL_GUI_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccHTL_GUI_ACN_Encode(const asn1SccHTL_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? asn1SccHTL_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode state */
	    ret = asn1SccHTL_State_ACN_Encode((&(pVal->state)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heater */
	        ret = asn1SccHeater_Data_ACN_Encode((&(pVal->heater)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode delta_T */
	            ret = asn1SccT_Float_ACN_Encode((&(pVal->delta_T)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode pt1000s */
	                /*Encode aire_abajo */
	                ret = asn1SccT_Float_ACN_Encode((&(pVal->pt1000s.aire_abajo)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode aire_arriba */
	                    ret = asn1SccT_Float_ACN_Encode((&(pVal->pt1000s.aire_arriba)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode placa_abajo */
	                        ret = asn1SccT_Float_ACN_Encode((&(pVal->pt1000s.placa_abajo)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode placa_arriba */
	                            ret = asn1SccT_Float_ACN_Encode((&(pVal->pt1000s.placa_arriba)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode infinito */
	                                ret = asn1SccT_Float_ACN_Encode((&(pVal->pt1000s.infinito)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode exterior */
	                                    ret = asn1SccT_Float_ACN_Encode((&(pVal->pt1000s.exterior)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode validity */
	                                        	
	                                        for(i1=0; (i1 < (int)6) && ret; i1++) 
	                                        {
	                                        	ret = asn1SccContent_Validity_ACN_Encode((&(pVal->pt1000s.validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	                if (ret) {
	                    /*Encode tc74s */
	                    /*Encode x_positive */
	                    ret = asn1SccT_Float_ACN_Encode((&(pVal->tc74s.x_positive)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode x_negative */
	                        ret = asn1SccT_Float_ACN_Encode((&(pVal->tc74s.x_negative)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode y_positive */
	                            ret = asn1SccT_Float_ACN_Encode((&(pVal->tc74s.y_positive)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode y_negative */
	                                ret = asn1SccT_Float_ACN_Encode((&(pVal->tc74s.y_negative)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode z_techo */
	                                    ret = asn1SccT_Float_ACN_Encode((&(pVal->tc74s.z_techo)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode validity */
	                                        	
	                                        for(i1=0; (i1 < (int)5) && ret; i1++) 
	                                        {
	                                        	ret = asn1SccContent_Validity_ACN_Encode((&(pVal->tc74s.validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccHTL_GUI_ACN_Decode(asn1SccHTL_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

	/*Decode state */
	ret = asn1SccHTL_State_ACN_Decode((&(pVal->state)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heater */
	    ret = asn1SccHeater_Data_ACN_Decode((&(pVal->heater)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode delta_T */
	        ret = asn1SccT_Float_ACN_Decode((&(pVal->delta_T)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode pt1000s */
	            /*Decode aire_abajo */
	            ret = asn1SccT_Float_ACN_Decode((&(pVal->pt1000s.aire_abajo)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode aire_arriba */
	                ret = asn1SccT_Float_ACN_Decode((&(pVal->pt1000s.aire_arriba)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode placa_abajo */
	                    ret = asn1SccT_Float_ACN_Decode((&(pVal->pt1000s.placa_abajo)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode placa_arriba */
	                        ret = asn1SccT_Float_ACN_Decode((&(pVal->pt1000s.placa_arriba)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode infinito */
	                            ret = asn1SccT_Float_ACN_Decode((&(pVal->pt1000s.infinito)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode exterior */
	                                ret = asn1SccT_Float_ACN_Decode((&(pVal->pt1000s.exterior)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode validity */
	                                    	
	                                    for(i1=0; (i1 < (int)6) && ret; i1++) 
	                                    {
	                                    	ret = asn1SccContent_Validity_ACN_Decode((&(pVal->pt1000s.validity.arr[i1])), pBitStrm, pErrCode);
	                                    }
	                                }

	                            }

	                        }

	                    }

	                }

	            }

	            if (ret) {
	                /*Decode tc74s */
	                /*Decode x_positive */
	                ret = asn1SccT_Float_ACN_Decode((&(pVal->tc74s.x_positive)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode x_negative */
	                    ret = asn1SccT_Float_ACN_Decode((&(pVal->tc74s.x_negative)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode y_positive */
	                        ret = asn1SccT_Float_ACN_Decode((&(pVal->tc74s.y_positive)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode y_negative */
	                            ret = asn1SccT_Float_ACN_Decode((&(pVal->tc74s.y_negative)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode z_techo */
	                                ret = asn1SccT_Float_ACN_Decode((&(pVal->tc74s.z_techo)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode validity */
	                                    	
	                                    for(i1=0; (i1 < (int)5) && ret; i1++) 
	                                    {
	                                    	ret = asn1SccContent_Validity_ACN_Decode((&(pVal->tc74s.validity.arr[i1])), pBitStrm, pErrCode);
	                                    }
	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && asn1SccHTL_GUI_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccOBSW_DP_Filter_Equal(const asn1SccOBSW_DP_Filter* pVal1, const asn1SccOBSW_DP_Filter* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccOBSW_DP_Filter_Initialize(asn1SccOBSW_DP_Filter* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1Sccgps;
}

flag asn1SccOBSW_DP_Filter_IsConstraintValid(const asn1SccOBSW_DP_Filter* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((((((*(pVal)) == asn1Sccgps)) || (((*(pVal)) == asn1Sccimu)))) || (((*(pVal)) == asn1Scctc74s)))) || (((*(pVal)) == asn1Sccpt1000s)))) || (((*(pVal)) == asn1Sccps1)))) || (((*(pVal)) == asn1Sccps2)))) || (((*(pVal)) == asn1Sccheater1)))) || (((*(pVal)) == asn1Sccheater2)))) || (((*(pVal)) == asn1Sccanemometer)));
    *pErrCode = ret ? 0 :  ERR_OBSW_DP_FILTER; 

	return ret;
}

flag asn1SccOBSW_DP_Filter_Encode(const asn1SccOBSW_DP_Filter* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccOBSW_DP_Filter_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case asn1Sccgps:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 8);
	        	break;
	        case asn1Sccimu:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 8);
	        	break;
	        case asn1Scctc74s:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 8);
	        	break;
	        case asn1Sccpt1000s:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 8);
	        	break;
	        case asn1Sccps1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 8);
	        	break;
	        case asn1Sccps2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 8);
	        	break;
	        case asn1Sccheater1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 8);
	        	break;
	        case asn1Sccheater2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 8);
	        	break;
	        case asn1Sccanemometer:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 8);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_OBSW_DP_FILTER; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccOBSW_DP_Filter_Decode(asn1SccOBSW_DP_Filter* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 8);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_FILTER;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1Sccgps;
	                break;
	            case 1: 
	                (*(pVal)) = asn1Sccimu;
	                break;
	            case 2: 
	                (*(pVal)) = asn1Scctc74s;
	                break;
	            case 3: 
	                (*(pVal)) = asn1Sccpt1000s;
	                break;
	            case 4: 
	                (*(pVal)) = asn1Sccps1;
	                break;
	            case 5: 
	                (*(pVal)) = asn1Sccps2;
	                break;
	            case 6: 
	                (*(pVal)) = asn1Sccheater1;
	                break;
	            case 7: 
	                (*(pVal)) = asn1Sccheater2;
	                break;
	            case 8: 
	                (*(pVal)) = asn1Sccanemometer;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_OBSW_DP_FILTER;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1Sccgps;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccOBSW_DP_Filter_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccOBSW_DP_Filter_ACN_Encode(const asn1SccOBSW_DP_Filter* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
	ret = bCheckConstraints ? asn1SccOBSW_DP_Filter_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) { 
	        case asn1Sccgps:
	            uIntVal = 0;
	            break;
	        case asn1Sccimu:
	            uIntVal = 1;
	            break;
	        case asn1Scctc74s:
	            uIntVal = 2;
	            break;
	        case asn1Sccpt1000s:
	            uIntVal = 3;
	            break;
	        case asn1Sccps1:
	            uIntVal = 4;
	            break;
	        case asn1Sccps2:
	            uIntVal = 5;
	            break;
	        case asn1Sccheater1:
	            uIntVal = 6;
	            break;
	        case asn1Sccheater2:
	            uIntVal = 7;
	            break;
	        case asn1Sccanemometer:
	            uIntVal = 8;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_OBSW_DP_FILTER;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 8);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccOBSW_DP_Filter_ACN_Decode(asn1SccOBSW_DP_Filter* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 8);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_FILTER;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1Sccgps;
	            break;
	        case 1:
	            (*(pVal)) = asn1Sccimu;
	            break;
	        case 2:
	            (*(pVal)) = asn1Scctc74s;
	            break;
	        case 3:
	            (*(pVal)) = asn1Sccpt1000s;
	            break;
	        case 4:
	            (*(pVal)) = asn1Sccps1;
	            break;
	        case 5:
	            (*(pVal)) = asn1Sccps2;
	            break;
	        case 6:
	            (*(pVal)) = asn1Sccheater1;
	            break;
	        case 7:
	            (*(pVal)) = asn1Sccheater2;
	            break;
	        case 8:
	            (*(pVal)) = asn1Sccanemometer;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_OBSW_DP_FILTER;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccOBSW_DP_Filter_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int32_Equal(const asn1SccT_Int32* pVal1, const asn1SccT_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

flag asn1SccT_Int32_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int32_ACN_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_ACN_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccTC74s_I2CBuses_Equal(const asn1SccTC74s_I2CBuses* pVal1, const asn1SccTC74s_I2CBuses* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void asn1SccTC74s_I2CBuses_Initialize(asn1SccTC74s_I2CBuses* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 5) {
	    asn1SccT_Int32_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccTC74s_I2CBuses_IsConstraintValid(const asn1SccTC74s_I2CBuses* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 5; i1++) 
    {
    	ret = asn1SccT_Int32_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccTC74s_I2CBuses_Encode(const asn1SccTC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? asn1SccTC74s_I2CBuses_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	ret = asn1SccT_Int32_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTC74s_I2CBuses_Decode(asn1SccTC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		ret = asn1SccT_Int32_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccTC74s_I2CBuses_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccTC74s_I2CBuses_ACN_Encode(const asn1SccTC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? asn1SccTC74s_I2CBuses_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	ret = asn1SccT_Int32_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTC74s_I2CBuses_ACN_Decode(asn1SccTC74s_I2CBuses* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		ret = asn1SccT_Int32_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && asn1SccTC74s_I2CBuses_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPT1000s_Channels_Equal(const asn1SccPT1000s_Channels* pVal1, const asn1SccPT1000s_Channels* pVal2)
{
	flag ret=TRUE;
    int i1;

    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = (pVal1->arr[i1] == pVal2->arr[i1]);
    }

	return ret;

}

void asn1SccPT1000s_Channels_Initialize(asn1SccPT1000s_Channels* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 7) {
	    asn1SccT_Int32_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccPT1000s_Channels_IsConstraintValid(const asn1SccPT1000s_Channels* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 7; i1++) 
    {
    	ret = asn1SccT_Int32_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccPT1000s_Channels_Encode(const asn1SccPT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	ret = bCheckConstraints ? asn1SccPT1000s_Channels_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	ret = asn1SccT_Int32_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPT1000s_Channels_Decode(asn1SccPT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		ret = asn1SccT_Int32_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccPT1000s_Channels_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPT1000s_Channels_ACN_Encode(const asn1SccPT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
	ret = bCheckConstraints ? asn1SccPT1000s_Channels_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)7) && ret; i1++) 
	    {
	    	ret = asn1SccT_Int32_ACN_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPT1000s_Channels_ACN_Decode(asn1SccPT1000s_Channels* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)7) && ret; i1++) 
	{
		ret = asn1SccT_Int32_ACN_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

    return ret && asn1SccPT1000s_Channels_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPS_Processed_Data_Equal(const asn1SccPS_Processed_Data* pVal1, const asn1SccPS_Processed_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->pressure == pVal2->pressure);

    if (ret) {
        ret = (pVal1->temp == pVal2->temp);

    }

	return ret;

}

void asn1SccPS_Processed_Data_Initialize(asn1SccPS_Processed_Data* pVal)
{
	(void)pVal;



	/*set pressure */
	asn1SccT_Int32_Initialize((&(pVal->pressure)));
	/*set temp */
	asn1SccT_Int32_Initialize((&(pVal->temp)));
}

flag asn1SccPS_Processed_Data_IsConstraintValid(const asn1SccPS_Processed_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_Int32_IsConstraintValid((&(pVal->pressure)), pErrCode);
    if (ret) {
        ret = asn1SccT_Int32_IsConstraintValid((&(pVal->temp)), pErrCode);
    }

	return ret;
}

flag asn1SccPS_Processed_Data_Encode(const asn1SccPS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccPS_Processed_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure */
	    ret = asn1SccT_Int32_Encode((&(pVal->pressure)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode temp */
	        ret = asn1SccT_Int32_Encode((&(pVal->temp)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPS_Processed_Data_Decode(asn1SccPS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure */
	ret = asn1SccT_Int32_Decode((&(pVal->pressure)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode temp */
	    ret = asn1SccT_Int32_Decode((&(pVal->temp)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccPS_Processed_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPS_Processed_Data_ACN_Encode(const asn1SccPS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccPS_Processed_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pressure */
	    ret = asn1SccT_Int32_ACN_Encode((&(pVal->pressure)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode temp */
	        ret = asn1SccT_Int32_ACN_Encode((&(pVal->temp)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPS_Processed_Data_ACN_Decode(asn1SccPS_Processed_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pressure */
	ret = asn1SccT_Int32_ACN_Decode((&(pVal->pressure)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode temp */
	    ret = asn1SccT_Int32_ACN_Decode((&(pVal->temp)), pBitStrm, pErrCode);
	}


    return ret && asn1SccPS_Processed_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccTM_imu_Equal(const asn1SccTM_imu* pVal1, const asn1SccTM_imu* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccMGT_MilliGauss_Data_Equal((&(pVal1->mgt_mgauss)), (&(pVal2->mgt_mgauss)));

    if (ret) {
        ret = asn1SccACC_MilliG_Data_Equal((&(pVal1->accel_mg)), (&(pVal2->accel_mg)));

        if (ret) {
            ret = asn1SccGYRO_MilliDPS_Data_Equal((&(pVal1->gyro_mdps)), (&(pVal2->gyro_mdps)));

            if (ret) {
                ret = (pVal1->temp_celsius == pVal2->temp_celsius);

                if (ret) {
                    ret = (pVal1->mgt_valid == pVal2->mgt_valid);

                    if (ret) {
                        ret = (pVal1->acc_valid == pVal2->acc_valid);

                        if (ret) {
                            ret = (pVal1->gyro_valid == pVal2->gyro_valid);

                            if (ret) {
                                ret = (pVal1->temp_valid == pVal2->temp_valid);

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

flag asn1SccTM_Equal(const asn1SccTM* pVal1, const asn1SccTM* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->state_htl == pVal2->state_htl);

    if (ret) {
        ret = asn1SccHeater_Data_Equal((&(pVal1->heater1)), (&(pVal2->heater1)));

        if (ret) {
            ret = asn1SccHeater_Data_Equal((&(pVal1->heater2)), (&(pVal2->heater2)));

            if (ret) {
                ret = asn1SccTC74s_All_Data_Equal((&(pVal1->tc74s)), (&(pVal2->tc74s)));

                if (ret) {
                    ret = asn1SccPT1000s_All_Data_Equal((&(pVal1->pt1000s)), (&(pVal2->pt1000s)));

                    if (ret) {
                        ret = asn1SccGPS_PVT_Equal((&(pVal1->gps)), (&(pVal2->gps)));

                        if (ret) {
                            ret = asn1SccTM_imu_Equal((&(pVal1->imu)), (&(pVal2->imu)));

                            if (ret) {
                                ret = asn1SccPS_Processed_Data_Equal((&(pVal1->ps1)), (&(pVal2->ps1)));

                                if (ret) {
                                    ret = asn1SccPS_Processed_Data_Equal((&(pVal1->ps2)), (&(pVal2->ps2)));

                                    if (ret) {
                                        ret = (pVal1->ps1_validity == pVal2->ps1_validity);

                                        if (ret) {
                                            ret = (pVal1->ps2_validity == pVal2->ps2_validity);

                                            if (ret) {
                                                ret = (pVal1->anemometer == pVal2->anemometer);

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void asn1SccTM_imu_Initialize(asn1SccTM_imu* pVal)
{
	(void)pVal;



	/*set mgt_mgauss */
	asn1SccMGT_MilliGauss_Data_Initialize((&(pVal->mgt_mgauss)));
	/*set accel_mg */
	asn1SccACC_MilliG_Data_Initialize((&(pVal->accel_mg)));
	/*set gyro_mdps */
	asn1SccGYRO_MilliDPS_Data_Initialize((&(pVal->gyro_mdps)));
	/*set temp_celsius */
	asn1SccT_Float_Initialize((&(pVal->temp_celsius)));
	/*set mgt_valid */
	asn1SccContent_Validity_Initialize((&(pVal->mgt_valid)));
	/*set acc_valid */
	asn1SccContent_Validity_Initialize((&(pVal->acc_valid)));
	/*set gyro_valid */
	asn1SccContent_Validity_Initialize((&(pVal->gyro_valid)));
	/*set temp_valid */
	asn1SccContent_Validity_Initialize((&(pVal->temp_valid)));
}
void asn1SccTM_Initialize(asn1SccTM* pVal)
{
	(void)pVal;



	/*set state_htl */
	asn1SccHTL_State_Initialize((&(pVal->state_htl)));
	/*set heater1 */
	asn1SccHeater_Data_Initialize((&(pVal->heater1)));
	/*set heater2 */
	asn1SccHeater_Data_Initialize((&(pVal->heater2)));
	/*set tc74s */
	asn1SccTC74s_All_Data_Initialize((&(pVal->tc74s)));
	/*set pt1000s */
	asn1SccPT1000s_All_Data_Initialize((&(pVal->pt1000s)));
	/*set gps */
	asn1SccGPS_PVT_Initialize((&(pVal->gps)));
	/*set imu */
	asn1SccTM_imu_Initialize((&(pVal->imu)));
	/*set ps1 */
	asn1SccPS_Processed_Data_Initialize((&(pVal->ps1)));
	/*set ps2 */
	asn1SccPS_Processed_Data_Initialize((&(pVal->ps2)));
	/*set ps1_validity */
	asn1SccContent_Validity_Initialize((&(pVal->ps1_validity)));
	/*set ps2_validity */
	asn1SccContent_Validity_Initialize((&(pVal->ps2_validity)));
	/*set anemometer */
	asn1SccT_UInt64_Initialize((&(pVal->anemometer)));
}

flag asn1SccTM_IsConstraintValid(const asn1SccTM* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccHTL_State_IsConstraintValid((&(pVal->state_htl)), pErrCode);
    if (ret) {
        ret = asn1SccHeater_Data_IsConstraintValid((&(pVal->heater1)), pErrCode);
        if (ret) {
            ret = asn1SccHeater_Data_IsConstraintValid((&(pVal->heater2)), pErrCode);
            if (ret) {
                ret = asn1SccTC74s_All_Data_IsConstraintValid((&(pVal->tc74s)), pErrCode);
                if (ret) {
                    ret = asn1SccPT1000s_All_Data_IsConstraintValid((&(pVal->pt1000s)), pErrCode);
                    if (ret) {
                        ret = asn1SccGPS_PVT_IsConstraintValid((&(pVal->gps)), pErrCode);
                        if (ret) {
                            ret = asn1SccMGT_MilliGauss_Data_IsConstraintValid((&(pVal->imu.mgt_mgauss)), pErrCode);
                            if (ret) {
                                ret = asn1SccACC_MilliG_Data_IsConstraintValid((&(pVal->imu.accel_mg)), pErrCode);
                                if (ret) {
                                    ret = asn1SccGYRO_MilliDPS_Data_IsConstraintValid((&(pVal->imu.gyro_mdps)), pErrCode);
                                    if (ret) {
                                        ret = asn1SccT_Float_IsConstraintValid((&(pVal->imu.temp_celsius)), pErrCode);
                                        if (ret) {
                                            ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->imu.mgt_valid)), pErrCode);
                                            if (ret) {
                                                ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->imu.acc_valid)), pErrCode);
                                                if (ret) {
                                                    ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->imu.gyro_valid)), pErrCode);
                                                    if (ret) {
                                                        ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->imu.temp_valid)), pErrCode);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (ret) {
                                ret = asn1SccPS_Processed_Data_IsConstraintValid((&(pVal->ps1)), pErrCode);
                                if (ret) {
                                    ret = asn1SccPS_Processed_Data_IsConstraintValid((&(pVal->ps2)), pErrCode);
                                    if (ret) {
                                        ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->ps1_validity)), pErrCode);
                                        if (ret) {
                                            ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->ps2_validity)), pErrCode);
                                            if (ret) {
                                                ret = asn1SccT_UInt64_IsConstraintValid((&(pVal->anemometer)), pErrCode);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccTM_Encode(const asn1SccTM* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccTM_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode state_htl */
	    ret = asn1SccHTL_State_Encode((&(pVal->state_htl)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heater1 */
	        ret = asn1SccHeater_Data_Encode((&(pVal->heater1)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heater2 */
	            ret = asn1SccHeater_Data_Encode((&(pVal->heater2)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode tc74s */
	                ret = asn1SccTC74s_All_Data_Encode((&(pVal->tc74s)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode pt1000s */
	                    ret = asn1SccPT1000s_All_Data_Encode((&(pVal->pt1000s)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode gps */
	                        ret = asn1SccGPS_PVT_Encode((&(pVal->gps)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode imu */
	                            /*Encode mgt_mgauss */
	                            ret = asn1SccMGT_MilliGauss_Data_Encode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode accel_mg */
	                                ret = asn1SccACC_MilliG_Data_Encode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode gyro_mdps */
	                                    ret = asn1SccGYRO_MilliDPS_Data_Encode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode temp_celsius */
	                                        ret = asn1SccT_Float_Encode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode mgt_valid */
	                                            ret = asn1SccContent_Validity_Encode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode acc_valid */
	                                                ret = asn1SccContent_Validity_Encode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode gyro_valid */
	                                                    ret = asn1SccContent_Validity_Encode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                                    if (ret) {
	                                                        /*Encode temp_valid */
	                                                        ret = asn1SccContent_Validity_Encode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode, FALSE);
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                            if (ret) {
	                                /*Encode ps1 */
	                                ret = asn1SccPS_Processed_Data_Encode((&(pVal->ps1)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode ps2 */
	                                    ret = asn1SccPS_Processed_Data_Encode((&(pVal->ps2)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode ps1_validity */
	                                        ret = asn1SccContent_Validity_Encode((&(pVal->ps1_validity)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode ps2_validity */
	                                            ret = asn1SccContent_Validity_Encode((&(pVal->ps2_validity)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode anemometer */
	                                                ret = asn1SccT_UInt64_Encode((&(pVal->anemometer)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTM_Decode(asn1SccTM* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode state_htl */
	ret = asn1SccHTL_State_Decode((&(pVal->state_htl)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heater1 */
	    ret = asn1SccHeater_Data_Decode((&(pVal->heater1)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heater2 */
	        ret = asn1SccHeater_Data_Decode((&(pVal->heater2)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode tc74s */
	            ret = asn1SccTC74s_All_Data_Decode((&(pVal->tc74s)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode pt1000s */
	                ret = asn1SccPT1000s_All_Data_Decode((&(pVal->pt1000s)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode gps */
	                    ret = asn1SccGPS_PVT_Decode((&(pVal->gps)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode imu */
	                        /*Decode mgt_mgauss */
	                        ret = asn1SccMGT_MilliGauss_Data_Decode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode accel_mg */
	                            ret = asn1SccACC_MilliG_Data_Decode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode gyro_mdps */
	                                ret = asn1SccGYRO_MilliDPS_Data_Decode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode temp_celsius */
	                                    ret = asn1SccT_Float_Decode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode mgt_valid */
	                                        ret = asn1SccContent_Validity_Decode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode acc_valid */
	                                            ret = asn1SccContent_Validity_Decode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode gyro_valid */
	                                                ret = asn1SccContent_Validity_Decode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode);
	                                                if (ret) {
	                                                    /*Decode temp_valid */
	                                                    ret = asn1SccContent_Validity_Decode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                        if (ret) {
	                            /*Decode ps1 */
	                            ret = asn1SccPS_Processed_Data_Decode((&(pVal->ps1)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode ps2 */
	                                ret = asn1SccPS_Processed_Data_Decode((&(pVal->ps2)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode ps1_validity */
	                                    ret = asn1SccContent_Validity_Decode((&(pVal->ps1_validity)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode ps2_validity */
	                                        ret = asn1SccContent_Validity_Decode((&(pVal->ps2_validity)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode anemometer */
	                                            ret = asn1SccT_UInt64_Decode((&(pVal->anemometer)), pBitStrm, pErrCode);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccTM_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccTM_ACN_Encode(const asn1SccTM* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccTM_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode state_htl */
	    ret = asn1SccHTL_State_ACN_Encode((&(pVal->state_htl)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heater1 */
	        ret = asn1SccHeater_Data_ACN_Encode((&(pVal->heater1)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heater2 */
	            ret = asn1SccHeater_Data_ACN_Encode((&(pVal->heater2)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode tc74s */
	                ret = asn1SccTC74s_All_Data_ACN_Encode((&(pVal->tc74s)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode pt1000s */
	                    ret = asn1SccPT1000s_All_Data_ACN_Encode((&(pVal->pt1000s)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode gps */
	                        ret = asn1SccGPS_PVT_ACN_Encode((&(pVal->gps)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode imu */
	                            /*Encode mgt_mgauss */
	                            ret = asn1SccMGT_MilliGauss_Data_ACN_Encode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode accel_mg */
	                                ret = asn1SccACC_MilliG_Data_ACN_Encode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode gyro_mdps */
	                                    ret = asn1SccGYRO_MilliDPS_Data_ACN_Encode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode temp_celsius */
	                                        ret = asn1SccT_Float_ACN_Encode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode mgt_valid */
	                                            ret = asn1SccContent_Validity_ACN_Encode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode acc_valid */
	                                                ret = asn1SccContent_Validity_ACN_Encode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode gyro_valid */
	                                                    ret = asn1SccContent_Validity_ACN_Encode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                                    if (ret) {
	                                                        /*Encode temp_valid */
	                                                        ret = asn1SccContent_Validity_ACN_Encode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode, FALSE);
	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                            if (ret) {
	                                /*Encode ps1 */
	                                ret = asn1SccPS_Processed_Data_ACN_Encode((&(pVal->ps1)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode ps2 */
	                                    ret = asn1SccPS_Processed_Data_ACN_Encode((&(pVal->ps2)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode ps1_validity */
	                                        ret = asn1SccContent_Validity_ACN_Encode((&(pVal->ps1_validity)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode ps2_validity */
	                                            ret = asn1SccContent_Validity_ACN_Encode((&(pVal->ps2_validity)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode anemometer */
	                                                ret = asn1SccT_UInt64_ACN_Encode((&(pVal->anemometer)), pBitStrm, pErrCode, FALSE);
	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTM_ACN_Decode(asn1SccTM* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode state_htl */
	ret = asn1SccHTL_State_ACN_Decode((&(pVal->state_htl)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heater1 */
	    ret = asn1SccHeater_Data_ACN_Decode((&(pVal->heater1)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heater2 */
	        ret = asn1SccHeater_Data_ACN_Decode((&(pVal->heater2)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode tc74s */
	            ret = asn1SccTC74s_All_Data_ACN_Decode((&(pVal->tc74s)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode pt1000s */
	                ret = asn1SccPT1000s_All_Data_ACN_Decode((&(pVal->pt1000s)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode gps */
	                    ret = asn1SccGPS_PVT_ACN_Decode((&(pVal->gps)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode imu */
	                        /*Decode mgt_mgauss */
	                        ret = asn1SccMGT_MilliGauss_Data_ACN_Decode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode accel_mg */
	                            ret = asn1SccACC_MilliG_Data_ACN_Decode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode gyro_mdps */
	                                ret = asn1SccGYRO_MilliDPS_Data_ACN_Decode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode temp_celsius */
	                                    ret = asn1SccT_Float_ACN_Decode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode mgt_valid */
	                                        ret = asn1SccContent_Validity_ACN_Decode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode acc_valid */
	                                            ret = asn1SccContent_Validity_ACN_Decode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode gyro_valid */
	                                                ret = asn1SccContent_Validity_ACN_Decode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode);
	                                                if (ret) {
	                                                    /*Decode temp_valid */
	                                                    ret = asn1SccContent_Validity_ACN_Decode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode);
	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                        if (ret) {
	                            /*Decode ps1 */
	                            ret = asn1SccPS_Processed_Data_ACN_Decode((&(pVal->ps1)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode ps2 */
	                                ret = asn1SccPS_Processed_Data_ACN_Decode((&(pVal->ps2)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode ps1_validity */
	                                    ret = asn1SccContent_Validity_ACN_Decode((&(pVal->ps1_validity)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode ps2_validity */
	                                        ret = asn1SccContent_Validity_ACN_Decode((&(pVal->ps2_validity)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode anemometer */
	                                            ret = asn1SccT_UInt64_ACN_Decode((&(pVal->anemometer)), pBitStrm, pErrCode);
	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && asn1SccTM_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccDate_Time_Equal(const asn1SccDate_Time* pVal1, const asn1SccDate_Time* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->day == pVal2->day);

    if (ret) {
        ret = (pVal1->month == pVal2->month);

        if (ret) {
            ret = (pVal1->year == pVal2->year);

            if (ret) {
                ret = (pVal1->hour == pVal2->hour);

                if (ret) {
                    ret = (pVal1->minute == pVal2->minute);

                    if (ret) {
                        ret = (pVal1->second == pVal2->second);

                    }

                }

            }

        }

    }

	return ret;

}

void asn1SccDate_Time_Initialize(asn1SccDate_Time* pVal)
{
	(void)pVal;



	/*set day */
	asn1SccT_Int32_Initialize((&(pVal->day)));
	/*set month */
	asn1SccT_Int32_Initialize((&(pVal->month)));
	/*set year */
	asn1SccT_Int32_Initialize((&(pVal->year)));
	/*set hour */
	asn1SccT_Int32_Initialize((&(pVal->hour)));
	/*set minute */
	asn1SccT_Int32_Initialize((&(pVal->minute)));
	/*set second */
	asn1SccT_Int32_Initialize((&(pVal->second)));
}

flag asn1SccDate_Time_IsConstraintValid(const asn1SccDate_Time* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_Int32_IsConstraintValid((&(pVal->day)), pErrCode);
    if (ret) {
        ret = asn1SccT_Int32_IsConstraintValid((&(pVal->month)), pErrCode);
        if (ret) {
            ret = asn1SccT_Int32_IsConstraintValid((&(pVal->year)), pErrCode);
            if (ret) {
                ret = asn1SccT_Int32_IsConstraintValid((&(pVal->hour)), pErrCode);
                if (ret) {
                    ret = asn1SccT_Int32_IsConstraintValid((&(pVal->minute)), pErrCode);
                    if (ret) {
                        ret = asn1SccT_Int32_IsConstraintValid((&(pVal->second)), pErrCode);
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccDate_Time_Encode(const asn1SccDate_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccDate_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode day */
	    ret = asn1SccT_Int32_Encode((&(pVal->day)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode month */
	        ret = asn1SccT_Int32_Encode((&(pVal->month)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode year */
	            ret = asn1SccT_Int32_Encode((&(pVal->year)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode hour */
	                ret = asn1SccT_Int32_Encode((&(pVal->hour)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode minute */
	                    ret = asn1SccT_Int32_Encode((&(pVal->minute)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode second */
	                        ret = asn1SccT_Int32_Encode((&(pVal->second)), pBitStrm, pErrCode, FALSE);
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccDate_Time_Decode(asn1SccDate_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode day */
	ret = asn1SccT_Int32_Decode((&(pVal->day)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode month */
	    ret = asn1SccT_Int32_Decode((&(pVal->month)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode year */
	        ret = asn1SccT_Int32_Decode((&(pVal->year)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode hour */
	            ret = asn1SccT_Int32_Decode((&(pVal->hour)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode minute */
	                ret = asn1SccT_Int32_Decode((&(pVal->minute)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode second */
	                    ret = asn1SccT_Int32_Decode((&(pVal->second)), pBitStrm, pErrCode);
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccDate_Time_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccDate_Time_ACN_Encode(const asn1SccDate_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccDate_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode day */
	    ret = asn1SccT_Int32_ACN_Encode((&(pVal->day)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode month */
	        ret = asn1SccT_Int32_ACN_Encode((&(pVal->month)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode year */
	            ret = asn1SccT_Int32_ACN_Encode((&(pVal->year)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode hour */
	                ret = asn1SccT_Int32_ACN_Encode((&(pVal->hour)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode minute */
	                    ret = asn1SccT_Int32_ACN_Encode((&(pVal->minute)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode second */
	                        ret = asn1SccT_Int32_ACN_Encode((&(pVal->second)), pBitStrm, pErrCode, FALSE);
	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccDate_Time_ACN_Decode(asn1SccDate_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode day */
	ret = asn1SccT_Int32_ACN_Decode((&(pVal->day)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode month */
	    ret = asn1SccT_Int32_ACN_Decode((&(pVal->month)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode year */
	        ret = asn1SccT_Int32_ACN_Decode((&(pVal->year)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode hour */
	            ret = asn1SccT_Int32_ACN_Decode((&(pVal->hour)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode minute */
	                ret = asn1SccT_Int32_ACN_Decode((&(pVal->minute)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode second */
	                    ret = asn1SccT_Int32_ACN_Decode((&(pVal->second)), pBitStrm, pErrCode);
	                }

	            }

	        }

	    }

	}


    return ret && asn1SccDate_Time_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccATT_GUI_imu_Equal(const asn1SccATT_GUI_imu* pVal1, const asn1SccATT_GUI_imu* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccMGT_MilliGauss_Data_Equal((&(pVal1->mgt_mgauss)), (&(pVal2->mgt_mgauss)));

    if (ret) {
        ret = asn1SccACC_MilliG_Data_Equal((&(pVal1->accel_mg)), (&(pVal2->accel_mg)));

        if (ret) {
            ret = asn1SccGYRO_MilliDPS_Data_Equal((&(pVal1->gyro_mdps)), (&(pVal2->gyro_mdps)));

            if (ret) {
                ret = (pVal1->temp_celsius == pVal2->temp_celsius);

                if (ret) {
                    ret = (pVal1->mgt_valid == pVal2->mgt_valid);

                    if (ret) {
                        ret = (pVal1->acc_valid == pVal2->acc_valid);

                        if (ret) {
                            ret = (pVal1->gyro_valid == pVal2->gyro_valid);

                            if (ret) {
                                ret = (pVal1->temp_valid == pVal2->temp_valid);

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

flag asn1SccATT_GUI_Equal(const asn1SccATT_GUI* pVal1, const asn1SccATT_GUI* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccGPS_PVT_Equal((&(pVal1->gps)), (&(pVal2->gps)));

    if (ret) {
        ret = asn1SccDate_Time_Equal((&(pVal1->gps_date_time)), (&(pVal2->gps_date_time)));

        if (ret) {
            ret = asn1SccATT_GUI_imu_Equal((&(pVal1->imu)), (&(pVal2->imu)));

        }

    }

	return ret;

}

void asn1SccATT_GUI_imu_Initialize(asn1SccATT_GUI_imu* pVal)
{
	(void)pVal;



	/*set mgt_mgauss */
	asn1SccMGT_MilliGauss_Data_Initialize((&(pVal->mgt_mgauss)));
	/*set accel_mg */
	asn1SccACC_MilliG_Data_Initialize((&(pVal->accel_mg)));
	/*set gyro_mdps */
	asn1SccGYRO_MilliDPS_Data_Initialize((&(pVal->gyro_mdps)));
	/*set temp_celsius */
	asn1SccT_Float_Initialize((&(pVal->temp_celsius)));
	/*set mgt_valid */
	asn1SccContent_Validity_Initialize((&(pVal->mgt_valid)));
	/*set acc_valid */
	asn1SccContent_Validity_Initialize((&(pVal->acc_valid)));
	/*set gyro_valid */
	asn1SccContent_Validity_Initialize((&(pVal->gyro_valid)));
	/*set temp_valid */
	asn1SccContent_Validity_Initialize((&(pVal->temp_valid)));
}
void asn1SccATT_GUI_Initialize(asn1SccATT_GUI* pVal)
{
	(void)pVal;



	/*set gps */
	asn1SccGPS_PVT_Initialize((&(pVal->gps)));
	/*set gps_date_time */
	asn1SccDate_Time_Initialize((&(pVal->gps_date_time)));
	/*set imu */
	asn1SccATT_GUI_imu_Initialize((&(pVal->imu)));
}

flag asn1SccATT_GUI_IsConstraintValid(const asn1SccATT_GUI* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccGPS_PVT_IsConstraintValid((&(pVal->gps)), pErrCode);
    if (ret) {
        ret = asn1SccDate_Time_IsConstraintValid((&(pVal->gps_date_time)), pErrCode);
        if (ret) {
            ret = asn1SccMGT_MilliGauss_Data_IsConstraintValid((&(pVal->imu.mgt_mgauss)), pErrCode);
            if (ret) {
                ret = asn1SccACC_MilliG_Data_IsConstraintValid((&(pVal->imu.accel_mg)), pErrCode);
                if (ret) {
                    ret = asn1SccGYRO_MilliDPS_Data_IsConstraintValid((&(pVal->imu.gyro_mdps)), pErrCode);
                    if (ret) {
                        ret = asn1SccT_Float_IsConstraintValid((&(pVal->imu.temp_celsius)), pErrCode);
                        if (ret) {
                            ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->imu.mgt_valid)), pErrCode);
                            if (ret) {
                                ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->imu.acc_valid)), pErrCode);
                                if (ret) {
                                    ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->imu.gyro_valid)), pErrCode);
                                    if (ret) {
                                        ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->imu.temp_valid)), pErrCode);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccATT_GUI_Encode(const asn1SccATT_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccATT_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode gps */
	    ret = asn1SccGPS_PVT_Encode((&(pVal->gps)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode gps_date_time */
	        ret = asn1SccDate_Time_Encode((&(pVal->gps_date_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode imu */
	            /*Encode mgt_mgauss */
	            ret = asn1SccMGT_MilliGauss_Data_Encode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode accel_mg */
	                ret = asn1SccACC_MilliG_Data_Encode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gyro_mdps */
	                    ret = asn1SccGYRO_MilliDPS_Data_Encode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode temp_celsius */
	                        ret = asn1SccT_Float_Encode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode mgt_valid */
	                            ret = asn1SccContent_Validity_Encode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode acc_valid */
	                                ret = asn1SccContent_Validity_Encode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode gyro_valid */
	                                    ret = asn1SccContent_Validity_Encode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode temp_valid */
	                                        ret = asn1SccContent_Validity_Encode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode, FALSE);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccATT_GUI_Decode(asn1SccATT_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode gps */
	ret = asn1SccGPS_PVT_Decode((&(pVal->gps)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode gps_date_time */
	    ret = asn1SccDate_Time_Decode((&(pVal->gps_date_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode imu */
	        /*Decode mgt_mgauss */
	        ret = asn1SccMGT_MilliGauss_Data_Decode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode accel_mg */
	            ret = asn1SccACC_MilliG_Data_Decode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gyro_mdps */
	                ret = asn1SccGYRO_MilliDPS_Data_Decode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode temp_celsius */
	                    ret = asn1SccT_Float_Decode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode mgt_valid */
	                        ret = asn1SccContent_Validity_Decode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode acc_valid */
	                            ret = asn1SccContent_Validity_Decode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode gyro_valid */
	                                ret = asn1SccContent_Validity_Decode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode temp_valid */
	                                    ret = asn1SccContent_Validity_Decode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccATT_GUI_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccATT_GUI_ACN_Encode(const asn1SccATT_GUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccATT_GUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode gps */
	    ret = asn1SccGPS_PVT_ACN_Encode((&(pVal->gps)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode gps_date_time */
	        ret = asn1SccDate_Time_ACN_Encode((&(pVal->gps_date_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode imu */
	            /*Encode mgt_mgauss */
	            ret = asn1SccMGT_MilliGauss_Data_ACN_Encode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode accel_mg */
	                ret = asn1SccACC_MilliG_Data_ACN_Encode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode gyro_mdps */
	                    ret = asn1SccGYRO_MilliDPS_Data_ACN_Encode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode temp_celsius */
	                        ret = asn1SccT_Float_ACN_Encode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode mgt_valid */
	                            ret = asn1SccContent_Validity_ACN_Encode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode acc_valid */
	                                ret = asn1SccContent_Validity_ACN_Encode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode gyro_valid */
	                                    ret = asn1SccContent_Validity_ACN_Encode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode temp_valid */
	                                        ret = asn1SccContent_Validity_ACN_Encode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode, FALSE);
	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccATT_GUI_ACN_Decode(asn1SccATT_GUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode gps */
	ret = asn1SccGPS_PVT_ACN_Decode((&(pVal->gps)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode gps_date_time */
	    ret = asn1SccDate_Time_ACN_Decode((&(pVal->gps_date_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode imu */
	        /*Decode mgt_mgauss */
	        ret = asn1SccMGT_MilliGauss_Data_ACN_Decode((&(pVal->imu.mgt_mgauss)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode accel_mg */
	            ret = asn1SccACC_MilliG_Data_ACN_Decode((&(pVal->imu.accel_mg)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode gyro_mdps */
	                ret = asn1SccGYRO_MilliDPS_Data_ACN_Decode((&(pVal->imu.gyro_mdps)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode temp_celsius */
	                    ret = asn1SccT_Float_ACN_Decode((&(pVal->imu.temp_celsius)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode mgt_valid */
	                        ret = asn1SccContent_Validity_ACN_Decode((&(pVal->imu.mgt_valid)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode acc_valid */
	                            ret = asn1SccContent_Validity_ACN_Decode((&(pVal->imu.acc_valid)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode gyro_valid */
	                                ret = asn1SccContent_Validity_ACN_Decode((&(pVal->imu.gyro_valid)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode temp_valid */
	                                    ret = asn1SccContent_Validity_ACN_Decode((&(pVal->imu.temp_valid)), pBitStrm, pErrCode);
	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && asn1SccATT_GUI_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt32_Equal(const asn1SccT_UInt32* pVal1, const asn1SccT_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

flag asn1SccT_UInt32_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt32_ACN_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_ACN_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPS_Raw_Data_Equal(const asn1SccPS_Raw_Data* pVal1, const asn1SccPS_Raw_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->d1 == pVal2->d1);

    if (ret) {
        ret = (pVal1->d2 == pVal2->d2);

    }

	return ret;

}

void asn1SccPS_Raw_Data_Initialize(asn1SccPS_Raw_Data* pVal)
{
	(void)pVal;



	/*set d1 */
	asn1SccT_UInt32_Initialize((&(pVal->d1)));
	/*set d2 */
	asn1SccT_UInt32_Initialize((&(pVal->d2)));
}

flag asn1SccPS_Raw_Data_IsConstraintValid(const asn1SccPS_Raw_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt32_IsConstraintValid((&(pVal->d1)), pErrCode);
    if (ret) {
        ret = asn1SccT_UInt32_IsConstraintValid((&(pVal->d2)), pErrCode);
    }

	return ret;
}

flag asn1SccPS_Raw_Data_Encode(const asn1SccPS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccPS_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode d1 */
	    ret = asn1SccT_UInt32_Encode((&(pVal->d1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode d2 */
	        ret = asn1SccT_UInt32_Encode((&(pVal->d2)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPS_Raw_Data_Decode(asn1SccPS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode d1 */
	ret = asn1SccT_UInt32_Decode((&(pVal->d1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode d2 */
	    ret = asn1SccT_UInt32_Decode((&(pVal->d2)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccPS_Raw_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPS_Raw_Data_ACN_Encode(const asn1SccPS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccPS_Raw_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode d1 */
	    ret = asn1SccT_UInt32_ACN_Encode((&(pVal->d1)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode d2 */
	        ret = asn1SccT_UInt32_ACN_Encode((&(pVal->d2)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPS_Raw_Data_ACN_Decode(asn1SccPS_Raw_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode d1 */
	ret = asn1SccT_UInt32_ACN_Decode((&(pVal->d1)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode d2 */
	    ret = asn1SccT_UInt32_ACN_Decode((&(pVal->d2)), pBitStrm, pErrCode);
	}


    return ret && asn1SccPS_Raw_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPS_All_Data_Equal(const asn1SccPS_All_Data* pVal1, const asn1SccPS_All_Data* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPS_Calibration_Data_Equal((&(pVal1->calib)), (&(pVal2->calib)));

    if (ret) {
        ret = asn1SccPS_Raw_Data_Equal((&(pVal1->raw)), (&(pVal2->raw)));

        if (ret) {
            ret = asn1SccPS_Processed_Data_Equal((&(pVal1->processed)), (&(pVal2->processed)));

            if (ret) {
                ret = (pVal1->validity == pVal2->validity);

            }

        }

    }

	return ret;

}

void asn1SccPS_All_Data_Initialize(asn1SccPS_All_Data* pVal)
{
	(void)pVal;



	/*set calib */
	asn1SccPS_Calibration_Data_Initialize((&(pVal->calib)));
	/*set raw */
	asn1SccPS_Raw_Data_Initialize((&(pVal->raw)));
	/*set processed */
	asn1SccPS_Processed_Data_Initialize((&(pVal->processed)));
	/*set validity */
	asn1SccContent_Validity_Initialize((&(pVal->validity)));
}

flag asn1SccPS_All_Data_IsConstraintValid(const asn1SccPS_All_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPS_Calibration_Data_IsConstraintValid((&(pVal->calib)), pErrCode);
    if (ret) {
        ret = asn1SccPS_Raw_Data_IsConstraintValid((&(pVal->raw)), pErrCode);
        if (ret) {
            ret = asn1SccPS_Processed_Data_IsConstraintValid((&(pVal->processed)), pErrCode);
            if (ret) {
                ret = asn1SccContent_Validity_IsConstraintValid((&(pVal->validity)), pErrCode);
            }
        }
    }

	return ret;
}

flag asn1SccPS_All_Data_Encode(const asn1SccPS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccPS_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode calib */
	    ret = asn1SccPS_Calibration_Data_Encode((&(pVal->calib)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode raw */
	        ret = asn1SccPS_Raw_Data_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode processed */
	            ret = asn1SccPS_Processed_Data_Encode((&(pVal->processed)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode validity */
	                ret = asn1SccContent_Validity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPS_All_Data_Decode(asn1SccPS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode calib */
	ret = asn1SccPS_Calibration_Data_Decode((&(pVal->calib)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode raw */
	    ret = asn1SccPS_Raw_Data_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode processed */
	        ret = asn1SccPS_Processed_Data_Decode((&(pVal->processed)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode validity */
	            ret = asn1SccContent_Validity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && asn1SccPS_All_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPS_All_Data_ACN_Encode(const asn1SccPS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccPS_All_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode calib */
	    ret = asn1SccPS_Calibration_Data_ACN_Encode((&(pVal->calib)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode raw */
	        ret = asn1SccPS_Raw_Data_ACN_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode processed */
	            ret = asn1SccPS_Processed_Data_ACN_Encode((&(pVal->processed)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode validity */
	                ret = asn1SccContent_Validity_ACN_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPS_All_Data_ACN_Decode(asn1SccPS_All_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode calib */
	ret = asn1SccPS_Calibration_Data_ACN_Decode((&(pVal->calib)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode raw */
	    ret = asn1SccPS_Raw_Data_ACN_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode processed */
	        ret = asn1SccPS_Processed_Data_ACN_Decode((&(pVal->processed)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode validity */
	            ret = asn1SccContent_Validity_ACN_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	        }

	    }

	}


    return ret && asn1SccPS_All_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccOBSW_DP_Data_gps_Equal(const asn1SccOBSW_DP_Data_gps* pVal1, const asn1SccOBSW_DP_Data_gps* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccGPS_PVT_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_Data_imu_Equal(const asn1SccOBSW_DP_Data_imu* pVal1, const asn1SccOBSW_DP_Data_imu* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccIMU_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_Data_tc74s_Equal(const asn1SccOBSW_DP_Data_tc74s* pVal1, const asn1SccOBSW_DP_Data_tc74s* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccTC74s_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_Data_pt1000s_Equal(const asn1SccOBSW_DP_Data_pt1000s* pVal1, const asn1SccOBSW_DP_Data_pt1000s* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPT1000s_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_Data_ps1_Equal(const asn1SccOBSW_DP_Data_ps1* pVal1, const asn1SccOBSW_DP_Data_ps1* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPS_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_Data_ps2_Equal(const asn1SccOBSW_DP_Data_ps2* pVal1, const asn1SccOBSW_DP_Data_ps2* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPS_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_Data_heater1_Equal(const asn1SccOBSW_DP_Data_heater1* pVal1, const asn1SccOBSW_DP_Data_heater1* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccHeater_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_Data_heater2_Equal(const asn1SccOBSW_DP_Data_heater2* pVal1, const asn1SccOBSW_DP_Data_heater2* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccHeater_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_Data_anemometer_Equal(const asn1SccOBSW_DP_Data_anemometer* pVal1, const asn1SccOBSW_DP_Data_anemometer* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->data == pVal2->data);

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_Data_Equal(const asn1SccOBSW_DP_Data* pVal1, const asn1SccOBSW_DP_Data* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->exist.gps == pVal2->exist.gps);
    if (ret && pVal1->exist.gps) {
    	ret = asn1SccOBSW_DP_Data_gps_Equal((&(pVal1->gps)), (&(pVal2->gps)));
    }

    if (ret) {
        ret = (pVal1->exist.imu == pVal2->exist.imu);
        if (ret && pVal1->exist.imu) {
        	ret = asn1SccOBSW_DP_Data_imu_Equal((&(pVal1->imu)), (&(pVal2->imu)));
        }

        if (ret) {
            ret = (pVal1->exist.tc74s == pVal2->exist.tc74s);
            if (ret && pVal1->exist.tc74s) {
            	ret = asn1SccOBSW_DP_Data_tc74s_Equal((&(pVal1->tc74s)), (&(pVal2->tc74s)));
            }

            if (ret) {
                ret = (pVal1->exist.pt1000s == pVal2->exist.pt1000s);
                if (ret && pVal1->exist.pt1000s) {
                	ret = asn1SccOBSW_DP_Data_pt1000s_Equal((&(pVal1->pt1000s)), (&(pVal2->pt1000s)));
                }

                if (ret) {
                    ret = (pVal1->exist.ps1 == pVal2->exist.ps1);
                    if (ret && pVal1->exist.ps1) {
                    	ret = asn1SccOBSW_DP_Data_ps1_Equal((&(pVal1->ps1)), (&(pVal2->ps1)));
                    }

                    if (ret) {
                        ret = (pVal1->exist.ps2 == pVal2->exist.ps2);
                        if (ret && pVal1->exist.ps2) {
                        	ret = asn1SccOBSW_DP_Data_ps2_Equal((&(pVal1->ps2)), (&(pVal2->ps2)));
                        }

                        if (ret) {
                            ret = (pVal1->exist.heater1 == pVal2->exist.heater1);
                            if (ret && pVal1->exist.heater1) {
                            	ret = asn1SccOBSW_DP_Data_heater1_Equal((&(pVal1->heater1)), (&(pVal2->heater1)));
                            }

                            if (ret) {
                                ret = (pVal1->exist.heater2 == pVal2->exist.heater2);
                                if (ret && pVal1->exist.heater2) {
                                	ret = asn1SccOBSW_DP_Data_heater2_Equal((&(pVal1->heater2)), (&(pVal2->heater2)));
                                }

                                if (ret) {
                                    ret = (pVal1->exist.anemometer == pVal2->exist.anemometer);
                                    if (ret && pVal1->exist.anemometer) {
                                    	ret = asn1SccOBSW_DP_Data_anemometer_Equal((&(pVal1->anemometer)), (&(pVal2->anemometer)));
                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void asn1SccOBSW_DP_Data_gps_Initialize(asn1SccOBSW_DP_Data_gps* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccGPS_PVT_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_Data_imu_Initialize(asn1SccOBSW_DP_Data_imu* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccIMU_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_Data_tc74s_Initialize(asn1SccOBSW_DP_Data_tc74s* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccTC74s_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_Data_pt1000s_Initialize(asn1SccOBSW_DP_Data_pt1000s* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccPT1000s_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_Data_ps1_Initialize(asn1SccOBSW_DP_Data_ps1* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccPS_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_Data_ps2_Initialize(asn1SccOBSW_DP_Data_ps2* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccPS_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_Data_heater1_Initialize(asn1SccOBSW_DP_Data_heater1* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccHeater_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_Data_heater2_Initialize(asn1SccOBSW_DP_Data_heater2* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccHeater_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_Data_anemometer_Initialize(asn1SccOBSW_DP_Data_anemometer* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccT_UInt64_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_Data_Initialize(asn1SccOBSW_DP_Data* pVal)
{
	(void)pVal;



	/*set gps */
	pVal->exist.gps = 1;
	asn1SccOBSW_DP_Data_gps_Initialize((&(pVal->gps)));
	/*set imu */
	pVal->exist.imu = 1;
	asn1SccOBSW_DP_Data_imu_Initialize((&(pVal->imu)));
	/*set tc74s */
	pVal->exist.tc74s = 1;
	asn1SccOBSW_DP_Data_tc74s_Initialize((&(pVal->tc74s)));
	/*set pt1000s */
	pVal->exist.pt1000s = 1;
	asn1SccOBSW_DP_Data_pt1000s_Initialize((&(pVal->pt1000s)));
	/*set ps1 */
	pVal->exist.ps1 = 1;
	asn1SccOBSW_DP_Data_ps1_Initialize((&(pVal->ps1)));
	/*set ps2 */
	pVal->exist.ps2 = 1;
	asn1SccOBSW_DP_Data_ps2_Initialize((&(pVal->ps2)));
	/*set heater1 */
	pVal->exist.heater1 = 1;
	asn1SccOBSW_DP_Data_heater1_Initialize((&(pVal->heater1)));
	/*set heater2 */
	pVal->exist.heater2 = 1;
	asn1SccOBSW_DP_Data_heater2_Initialize((&(pVal->heater2)));
	/*set anemometer */
	pVal->exist.anemometer = 1;
	asn1SccOBSW_DP_Data_anemometer_Initialize((&(pVal->anemometer)));
}

flag asn1SccOBSW_DP_Data_IsConstraintValid(const asn1SccOBSW_DP_Data* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.gps) {
    	ret = asn1SccGPS_PVT_IsConstraintValid((&(pVal->gps.data)), pErrCode);
    	if (ret) {
    	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->gps.gps_time)), pErrCode);
    	    if (ret) {
    	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->gps.mission_time)), pErrCode);
    	    }
    	}
    }
    if (ret) {
        if (pVal->exist.imu) {
        	ret = asn1SccIMU_All_Data_IsConstraintValid((&(pVal->imu.data)), pErrCode);
        	if (ret) {
        	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->imu.gps_time)), pErrCode);
        	    if (ret) {
        	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->imu.mission_time)), pErrCode);
        	    }
        	}
        }
        if (ret) {
            if (pVal->exist.tc74s) {
            	ret = asn1SccTC74s_All_Data_IsConstraintValid((&(pVal->tc74s.data)), pErrCode);
            	if (ret) {
            	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->tc74s.gps_time)), pErrCode);
            	    if (ret) {
            	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->tc74s.mission_time)), pErrCode);
            	    }
            	}
            }
            if (ret) {
                if (pVal->exist.pt1000s) {
                	ret = asn1SccPT1000s_All_Data_IsConstraintValid((&(pVal->pt1000s.data)), pErrCode);
                	if (ret) {
                	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->pt1000s.gps_time)), pErrCode);
                	    if (ret) {
                	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->pt1000s.mission_time)), pErrCode);
                	    }
                	}
                }
                if (ret) {
                    if (pVal->exist.ps1) {
                    	ret = asn1SccPS_All_Data_IsConstraintValid((&(pVal->ps1.data)), pErrCode);
                    	if (ret) {
                    	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->ps1.gps_time)), pErrCode);
                    	    if (ret) {
                    	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->ps1.mission_time)), pErrCode);
                    	    }
                    	}
                    }
                    if (ret) {
                        if (pVal->exist.ps2) {
                        	ret = asn1SccPS_All_Data_IsConstraintValid((&(pVal->ps2.data)), pErrCode);
                        	if (ret) {
                        	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->ps2.gps_time)), pErrCode);
                        	    if (ret) {
                        	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->ps2.mission_time)), pErrCode);
                        	    }
                        	}
                        }
                        if (ret) {
                            if (pVal->exist.heater1) {
                            	ret = asn1SccHeater_Data_IsConstraintValid((&(pVal->heater1.data)), pErrCode);
                            	if (ret) {
                            	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->heater1.gps_time)), pErrCode);
                            	    if (ret) {
                            	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->heater1.mission_time)), pErrCode);
                            	    }
                            	}
                            }
                            if (ret) {
                                if (pVal->exist.heater2) {
                                	ret = asn1SccHeater_Data_IsConstraintValid((&(pVal->heater2.data)), pErrCode);
                                	if (ret) {
                                	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->heater2.gps_time)), pErrCode);
                                	    if (ret) {
                                	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->heater2.mission_time)), pErrCode);
                                	    }
                                	}
                                }
                                if (ret) {
                                    if (pVal->exist.anemometer) {
                                    	ret = asn1SccT_UInt64_IsConstraintValid((&(pVal->anemometer.data)), pErrCode);
                                    	if (ret) {
                                    	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->anemometer.gps_time)), pErrCode);
                                    	    if (ret) {
                                    	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->anemometer.mission_time)), pErrCode);
                                    	    }
                                    	}
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccOBSW_DP_Data_Encode(const asn1SccOBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccOBSW_DP_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.gps);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.imu);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.tc74s);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.pt1000s);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.ps1);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.ps2);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.heater1);
	                            if (ret) {
	                                BitStream_AppendBit(pBitStrm,pVal->exist.heater2);
	                                if (ret) {
	                                    BitStream_AppendBit(pBitStrm,pVal->exist.anemometer);
	                                    if (ret) {
	                                        /*Encode gps */
	                                        if (pVal->exist.gps) {
	                                        	/*Encode data */
	                                        	ret = asn1SccGPS_PVT_Encode((&(pVal->gps.data)), pBitStrm, pErrCode, FALSE);
	                                        	if (ret) {
	                                        	    /*Encode gps_time */
	                                        	    ret = asn1SccT_Double_Encode((&(pVal->gps.gps_time)), pBitStrm, pErrCode, FALSE);
	                                        	    if (ret) {
	                                        	        /*Encode mission_time */
	                                        	        ret = asn1SccT_Double_Encode((&(pVal->gps.mission_time)), pBitStrm, pErrCode, FALSE);
	                                        	    }
	                                        	}
	                                        }
	                                        if (ret) {
	                                            /*Encode imu */
	                                            if (pVal->exist.imu) {
	                                            	/*Encode data */
	                                            	ret = asn1SccIMU_All_Data_Encode((&(pVal->imu.data)), pBitStrm, pErrCode, FALSE);
	                                            	if (ret) {
	                                            	    /*Encode gps_time */
	                                            	    ret = asn1SccT_Double_Encode((&(pVal->imu.gps_time)), pBitStrm, pErrCode, FALSE);
	                                            	    if (ret) {
	                                            	        /*Encode mission_time */
	                                            	        ret = asn1SccT_Double_Encode((&(pVal->imu.mission_time)), pBitStrm, pErrCode, FALSE);
	                                            	    }
	                                            	}
	                                            }
	                                            if (ret) {
	                                                /*Encode tc74s */
	                                                if (pVal->exist.tc74s) {
	                                                	/*Encode data */
	                                                	ret = asn1SccTC74s_All_Data_Encode((&(pVal->tc74s.data)), pBitStrm, pErrCode, FALSE);
	                                                	if (ret) {
	                                                	    /*Encode gps_time */
	                                                	    ret = asn1SccT_Double_Encode((&(pVal->tc74s.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                	    if (ret) {
	                                                	        /*Encode mission_time */
	                                                	        ret = asn1SccT_Double_Encode((&(pVal->tc74s.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                	    }
	                                                	}
	                                                }
	                                                if (ret) {
	                                                    /*Encode pt1000s */
	                                                    if (pVal->exist.pt1000s) {
	                                                    	/*Encode data */
	                                                    	ret = asn1SccPT1000s_All_Data_Encode((&(pVal->pt1000s.data)), pBitStrm, pErrCode, FALSE);
	                                                    	if (ret) {
	                                                    	    /*Encode gps_time */
	                                                    	    ret = asn1SccT_Double_Encode((&(pVal->pt1000s.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                    	    if (ret) {
	                                                    	        /*Encode mission_time */
	                                                    	        ret = asn1SccT_Double_Encode((&(pVal->pt1000s.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                    	    }
	                                                    	}
	                                                    }
	                                                    if (ret) {
	                                                        /*Encode ps1 */
	                                                        if (pVal->exist.ps1) {
	                                                        	/*Encode data */
	                                                        	ret = asn1SccPS_All_Data_Encode((&(pVal->ps1.data)), pBitStrm, pErrCode, FALSE);
	                                                        	if (ret) {
	                                                        	    /*Encode gps_time */
	                                                        	    ret = asn1SccT_Double_Encode((&(pVal->ps1.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                        	    if (ret) {
	                                                        	        /*Encode mission_time */
	                                                        	        ret = asn1SccT_Double_Encode((&(pVal->ps1.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                        	    }
	                                                        	}
	                                                        }
	                                                        if (ret) {
	                                                            /*Encode ps2 */
	                                                            if (pVal->exist.ps2) {
	                                                            	/*Encode data */
	                                                            	ret = asn1SccPS_All_Data_Encode((&(pVal->ps2.data)), pBitStrm, pErrCode, FALSE);
	                                                            	if (ret) {
	                                                            	    /*Encode gps_time */
	                                                            	    ret = asn1SccT_Double_Encode((&(pVal->ps2.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                            	    if (ret) {
	                                                            	        /*Encode mission_time */
	                                                            	        ret = asn1SccT_Double_Encode((&(pVal->ps2.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                            	    }
	                                                            	}
	                                                            }
	                                                            if (ret) {
	                                                                /*Encode heater1 */
	                                                                if (pVal->exist.heater1) {
	                                                                	/*Encode data */
	                                                                	ret = asn1SccHeater_Data_Encode((&(pVal->heater1.data)), pBitStrm, pErrCode, FALSE);
	                                                                	if (ret) {
	                                                                	    /*Encode gps_time */
	                                                                	    ret = asn1SccT_Double_Encode((&(pVal->heater1.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                	    if (ret) {
	                                                                	        /*Encode mission_time */
	                                                                	        ret = asn1SccT_Double_Encode((&(pVal->heater1.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                	    }
	                                                                	}
	                                                                }
	                                                                if (ret) {
	                                                                    /*Encode heater2 */
	                                                                    if (pVal->exist.heater2) {
	                                                                    	/*Encode data */
	                                                                    	ret = asn1SccHeater_Data_Encode((&(pVal->heater2.data)), pBitStrm, pErrCode, FALSE);
	                                                                    	if (ret) {
	                                                                    	    /*Encode gps_time */
	                                                                    	    ret = asn1SccT_Double_Encode((&(pVal->heater2.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                    	    if (ret) {
	                                                                    	        /*Encode mission_time */
	                                                                    	        ret = asn1SccT_Double_Encode((&(pVal->heater2.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                    	    }
	                                                                    	}
	                                                                    }
	                                                                    if (ret) {
	                                                                        /*Encode anemometer */
	                                                                        if (pVal->exist.anemometer) {
	                                                                        	/*Encode data */
	                                                                        	ret = asn1SccT_UInt64_Encode((&(pVal->anemometer.data)), pBitStrm, pErrCode, FALSE);
	                                                                        	if (ret) {
	                                                                        	    /*Encode gps_time */
	                                                                        	    ret = asn1SccT_Double_Encode((&(pVal->anemometer.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                        	    if (ret) {
	                                                                        	        /*Encode mission_time */
	                                                                        	        ret = asn1SccT_Double_Encode((&(pVal->anemometer.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                        	    }
	                                                                        	}
	                                                                        }
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccOBSW_DP_Data_Decode(asn1SccOBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.gps = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.imu = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.tc74s = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.pt1000s = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.ps1 = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.ps2 = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.heater1 = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                        if (ret) {
	                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                            pVal->exist.heater2 = presenceBit == 0 ? 0 : 1;
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                            if (ret) {
	                                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                pVal->exist.anemometer = presenceBit == 0 ? 0 : 1;
	                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_DATA;
	                                if (ret) {
	                                    /*Decode gps */
	                                    if (pVal->exist.gps) {
	                                    	/*Decode data */
	                                    	ret = asn1SccGPS_PVT_Decode((&(pVal->gps.data)), pBitStrm, pErrCode);
	                                    	if (ret) {
	                                    	    /*Decode gps_time */
	                                    	    ret = asn1SccT_Double_Decode((&(pVal->gps.gps_time)), pBitStrm, pErrCode);
	                                    	    if (ret) {
	                                    	        /*Decode mission_time */
	                                    	        ret = asn1SccT_Double_Decode((&(pVal->gps.mission_time)), pBitStrm, pErrCode);
	                                    	    }
	                                    	}
	                                    }
	                                    if (ret) {
	                                        /*Decode imu */
	                                        if (pVal->exist.imu) {
	                                        	/*Decode data */
	                                        	ret = asn1SccIMU_All_Data_Decode((&(pVal->imu.data)), pBitStrm, pErrCode);
	                                        	if (ret) {
	                                        	    /*Decode gps_time */
	                                        	    ret = asn1SccT_Double_Decode((&(pVal->imu.gps_time)), pBitStrm, pErrCode);
	                                        	    if (ret) {
	                                        	        /*Decode mission_time */
	                                        	        ret = asn1SccT_Double_Decode((&(pVal->imu.mission_time)), pBitStrm, pErrCode);
	                                        	    }
	                                        	}
	                                        }
	                                        if (ret) {
	                                            /*Decode tc74s */
	                                            if (pVal->exist.tc74s) {
	                                            	/*Decode data */
	                                            	ret = asn1SccTC74s_All_Data_Decode((&(pVal->tc74s.data)), pBitStrm, pErrCode);
	                                            	if (ret) {
	                                            	    /*Decode gps_time */
	                                            	    ret = asn1SccT_Double_Decode((&(pVal->tc74s.gps_time)), pBitStrm, pErrCode);
	                                            	    if (ret) {
	                                            	        /*Decode mission_time */
	                                            	        ret = asn1SccT_Double_Decode((&(pVal->tc74s.mission_time)), pBitStrm, pErrCode);
	                                            	    }
	                                            	}
	                                            }
	                                            if (ret) {
	                                                /*Decode pt1000s */
	                                                if (pVal->exist.pt1000s) {
	                                                	/*Decode data */
	                                                	ret = asn1SccPT1000s_All_Data_Decode((&(pVal->pt1000s.data)), pBitStrm, pErrCode);
	                                                	if (ret) {
	                                                	    /*Decode gps_time */
	                                                	    ret = asn1SccT_Double_Decode((&(pVal->pt1000s.gps_time)), pBitStrm, pErrCode);
	                                                	    if (ret) {
	                                                	        /*Decode mission_time */
	                                                	        ret = asn1SccT_Double_Decode((&(pVal->pt1000s.mission_time)), pBitStrm, pErrCode);
	                                                	    }
	                                                	}
	                                                }
	                                                if (ret) {
	                                                    /*Decode ps1 */
	                                                    if (pVal->exist.ps1) {
	                                                    	/*Decode data */
	                                                    	ret = asn1SccPS_All_Data_Decode((&(pVal->ps1.data)), pBitStrm, pErrCode);
	                                                    	if (ret) {
	                                                    	    /*Decode gps_time */
	                                                    	    ret = asn1SccT_Double_Decode((&(pVal->ps1.gps_time)), pBitStrm, pErrCode);
	                                                    	    if (ret) {
	                                                    	        /*Decode mission_time */
	                                                    	        ret = asn1SccT_Double_Decode((&(pVal->ps1.mission_time)), pBitStrm, pErrCode);
	                                                    	    }
	                                                    	}
	                                                    }
	                                                    if (ret) {
	                                                        /*Decode ps2 */
	                                                        if (pVal->exist.ps2) {
	                                                        	/*Decode data */
	                                                        	ret = asn1SccPS_All_Data_Decode((&(pVal->ps2.data)), pBitStrm, pErrCode);
	                                                        	if (ret) {
	                                                        	    /*Decode gps_time */
	                                                        	    ret = asn1SccT_Double_Decode((&(pVal->ps2.gps_time)), pBitStrm, pErrCode);
	                                                        	    if (ret) {
	                                                        	        /*Decode mission_time */
	                                                        	        ret = asn1SccT_Double_Decode((&(pVal->ps2.mission_time)), pBitStrm, pErrCode);
	                                                        	    }
	                                                        	}
	                                                        }
	                                                        if (ret) {
	                                                            /*Decode heater1 */
	                                                            if (pVal->exist.heater1) {
	                                                            	/*Decode data */
	                                                            	ret = asn1SccHeater_Data_Decode((&(pVal->heater1.data)), pBitStrm, pErrCode);
	                                                            	if (ret) {
	                                                            	    /*Decode gps_time */
	                                                            	    ret = asn1SccT_Double_Decode((&(pVal->heater1.gps_time)), pBitStrm, pErrCode);
	                                                            	    if (ret) {
	                                                            	        /*Decode mission_time */
	                                                            	        ret = asn1SccT_Double_Decode((&(pVal->heater1.mission_time)), pBitStrm, pErrCode);
	                                                            	    }
	                                                            	}
	                                                            }
	                                                            if (ret) {
	                                                                /*Decode heater2 */
	                                                                if (pVal->exist.heater2) {
	                                                                	/*Decode data */
	                                                                	ret = asn1SccHeater_Data_Decode((&(pVal->heater2.data)), pBitStrm, pErrCode);
	                                                                	if (ret) {
	                                                                	    /*Decode gps_time */
	                                                                	    ret = asn1SccT_Double_Decode((&(pVal->heater2.gps_time)), pBitStrm, pErrCode);
	                                                                	    if (ret) {
	                                                                	        /*Decode mission_time */
	                                                                	        ret = asn1SccT_Double_Decode((&(pVal->heater2.mission_time)), pBitStrm, pErrCode);
	                                                                	    }
	                                                                	}
	                                                                }
	                                                                if (ret) {
	                                                                    /*Decode anemometer */
	                                                                    if (pVal->exist.anemometer) {
	                                                                    	/*Decode data */
	                                                                    	ret = asn1SccT_UInt64_Decode((&(pVal->anemometer.data)), pBitStrm, pErrCode);
	                                                                    	if (ret) {
	                                                                    	    /*Decode gps_time */
	                                                                    	    ret = asn1SccT_Double_Decode((&(pVal->anemometer.gps_time)), pBitStrm, pErrCode);
	                                                                    	    if (ret) {
	                                                                    	        /*Decode mission_time */
	                                                                    	        ret = asn1SccT_Double_Decode((&(pVal->anemometer.mission_time)), pBitStrm, pErrCode);
	                                                                    	    }
	                                                                    	}
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccOBSW_DP_Data_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccOBSW_DP_Data_ACN_Encode(const asn1SccOBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccOBSW_DP_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.gps);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.imu);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.tc74s);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.pt1000s);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.ps1);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.ps2);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.heater1);
	                            if (ret) {
	                                BitStream_AppendBit(pBitStrm,pVal->exist.heater2);
	                                if (ret) {
	                                    BitStream_AppendBit(pBitStrm,pVal->exist.anemometer);
	                                    if (ret) {
	                                        /*Encode gps */
	                                        if (pVal->exist.gps) {
	                                        	/*Encode data */
	                                        	ret = asn1SccGPS_PVT_ACN_Encode((&(pVal->gps.data)), pBitStrm, pErrCode, FALSE);
	                                        	if (ret) {
	                                        	    /*Encode gps_time */
	                                        	    ret = asn1SccT_Double_ACN_Encode((&(pVal->gps.gps_time)), pBitStrm, pErrCode, FALSE);
	                                        	    if (ret) {
	                                        	        /*Encode mission_time */
	                                        	        ret = asn1SccT_Double_ACN_Encode((&(pVal->gps.mission_time)), pBitStrm, pErrCode, FALSE);
	                                        	    }

	                                        	}

	                                        }
	                                        if (ret) {
	                                            /*Encode imu */
	                                            if (pVal->exist.imu) {
	                                            	/*Encode data */
	                                            	ret = asn1SccIMU_All_Data_ACN_Encode((&(pVal->imu.data)), pBitStrm, pErrCode, FALSE);
	                                            	if (ret) {
	                                            	    /*Encode gps_time */
	                                            	    ret = asn1SccT_Double_ACN_Encode((&(pVal->imu.gps_time)), pBitStrm, pErrCode, FALSE);
	                                            	    if (ret) {
	                                            	        /*Encode mission_time */
	                                            	        ret = asn1SccT_Double_ACN_Encode((&(pVal->imu.mission_time)), pBitStrm, pErrCode, FALSE);
	                                            	    }

	                                            	}

	                                            }
	                                            if (ret) {
	                                                /*Encode tc74s */
	                                                if (pVal->exist.tc74s) {
	                                                	/*Encode data */
	                                                	ret = asn1SccTC74s_All_Data_ACN_Encode((&(pVal->tc74s.data)), pBitStrm, pErrCode, FALSE);
	                                                	if (ret) {
	                                                	    /*Encode gps_time */
	                                                	    ret = asn1SccT_Double_ACN_Encode((&(pVal->tc74s.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                	    if (ret) {
	                                                	        /*Encode mission_time */
	                                                	        ret = asn1SccT_Double_ACN_Encode((&(pVal->tc74s.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                	    }

	                                                	}

	                                                }
	                                                if (ret) {
	                                                    /*Encode pt1000s */
	                                                    if (pVal->exist.pt1000s) {
	                                                    	/*Encode data */
	                                                    	ret = asn1SccPT1000s_All_Data_ACN_Encode((&(pVal->pt1000s.data)), pBitStrm, pErrCode, FALSE);
	                                                    	if (ret) {
	                                                    	    /*Encode gps_time */
	                                                    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->pt1000s.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                    	    if (ret) {
	                                                    	        /*Encode mission_time */
	                                                    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->pt1000s.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                    	    }

	                                                    	}

	                                                    }
	                                                    if (ret) {
	                                                        /*Encode ps1 */
	                                                        if (pVal->exist.ps1) {
	                                                        	/*Encode data */
	                                                        	ret = asn1SccPS_All_Data_ACN_Encode((&(pVal->ps1.data)), pBitStrm, pErrCode, FALSE);
	                                                        	if (ret) {
	                                                        	    /*Encode gps_time */
	                                                        	    ret = asn1SccT_Double_ACN_Encode((&(pVal->ps1.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                        	    if (ret) {
	                                                        	        /*Encode mission_time */
	                                                        	        ret = asn1SccT_Double_ACN_Encode((&(pVal->ps1.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                        	    }

	                                                        	}

	                                                        }
	                                                        if (ret) {
	                                                            /*Encode ps2 */
	                                                            if (pVal->exist.ps2) {
	                                                            	/*Encode data */
	                                                            	ret = asn1SccPS_All_Data_ACN_Encode((&(pVal->ps2.data)), pBitStrm, pErrCode, FALSE);
	                                                            	if (ret) {
	                                                            	    /*Encode gps_time */
	                                                            	    ret = asn1SccT_Double_ACN_Encode((&(pVal->ps2.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                            	    if (ret) {
	                                                            	        /*Encode mission_time */
	                                                            	        ret = asn1SccT_Double_ACN_Encode((&(pVal->ps2.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                            	    }

	                                                            	}

	                                                            }
	                                                            if (ret) {
	                                                                /*Encode heater1 */
	                                                                if (pVal->exist.heater1) {
	                                                                	/*Encode data */
	                                                                	ret = asn1SccHeater_Data_ACN_Encode((&(pVal->heater1.data)), pBitStrm, pErrCode, FALSE);
	                                                                	if (ret) {
	                                                                	    /*Encode gps_time */
	                                                                	    ret = asn1SccT_Double_ACN_Encode((&(pVal->heater1.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                	    if (ret) {
	                                                                	        /*Encode mission_time */
	                                                                	        ret = asn1SccT_Double_ACN_Encode((&(pVal->heater1.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                	    }

	                                                                	}

	                                                                }
	                                                                if (ret) {
	                                                                    /*Encode heater2 */
	                                                                    if (pVal->exist.heater2) {
	                                                                    	/*Encode data */
	                                                                    	ret = asn1SccHeater_Data_ACN_Encode((&(pVal->heater2.data)), pBitStrm, pErrCode, FALSE);
	                                                                    	if (ret) {
	                                                                    	    /*Encode gps_time */
	                                                                    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->heater2.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                    	    if (ret) {
	                                                                    	        /*Encode mission_time */
	                                                                    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->heater2.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                    	    }

	                                                                    	}

	                                                                    }
	                                                                    if (ret) {
	                                                                        /*Encode anemometer */
	                                                                        if (pVal->exist.anemometer) {
	                                                                        	/*Encode data */
	                                                                        	ret = asn1SccT_UInt64_ACN_Encode((&(pVal->anemometer.data)), pBitStrm, pErrCode, FALSE);
	                                                                        	if (ret) {
	                                                                        	    /*Encode gps_time */
	                                                                        	    ret = asn1SccT_Double_ACN_Encode((&(pVal->anemometer.gps_time)), pBitStrm, pErrCode, FALSE);
	                                                                        	    if (ret) {
	                                                                        	        /*Encode mission_time */
	                                                                        	        ret = asn1SccT_Double_ACN_Encode((&(pVal->anemometer.mission_time)), pBitStrm, pErrCode, FALSE);
	                                                                        	    }

	                                                                        	}

	                                                                        }
	                                                                    }

	                                                                }

	                                                            }

	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccOBSW_DP_Data_ACN_Decode(asn1SccOBSW_DP_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.gps = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.imu = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.tc74s = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.pt1000s = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.ps1 = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.ps2 = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.heater1 = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                        if (ret) {
	                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                            pVal->exist.heater2 = presenceBit == 0 ? 0 : 1;
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                            if (ret) {
	                                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                                pVal->exist.anemometer = presenceBit == 0 ? 0 : 1;
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_DATA;
	                                if (ret) {
	                                    /*Decode gps */
	                                    if (pVal->exist.gps) {
	                                    	/*Decode data */
	                                    	ret = asn1SccGPS_PVT_ACN_Decode((&(pVal->gps.data)), pBitStrm, pErrCode);
	                                    	if (ret) {
	                                    	    /*Decode gps_time */
	                                    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->gps.gps_time)), pBitStrm, pErrCode);
	                                    	    if (ret) {
	                                    	        /*Decode mission_time */
	                                    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->gps.mission_time)), pBitStrm, pErrCode);
	                                    	    }

	                                    	}

	                                    }
	                                    if (ret) {
	                                        /*Decode imu */
	                                        if (pVal->exist.imu) {
	                                        	/*Decode data */
	                                        	ret = asn1SccIMU_All_Data_ACN_Decode((&(pVal->imu.data)), pBitStrm, pErrCode);
	                                        	if (ret) {
	                                        	    /*Decode gps_time */
	                                        	    ret = asn1SccT_Double_ACN_Decode((&(pVal->imu.gps_time)), pBitStrm, pErrCode);
	                                        	    if (ret) {
	                                        	        /*Decode mission_time */
	                                        	        ret = asn1SccT_Double_ACN_Decode((&(pVal->imu.mission_time)), pBitStrm, pErrCode);
	                                        	    }

	                                        	}

	                                        }
	                                        if (ret) {
	                                            /*Decode tc74s */
	                                            if (pVal->exist.tc74s) {
	                                            	/*Decode data */
	                                            	ret = asn1SccTC74s_All_Data_ACN_Decode((&(pVal->tc74s.data)), pBitStrm, pErrCode);
	                                            	if (ret) {
	                                            	    /*Decode gps_time */
	                                            	    ret = asn1SccT_Double_ACN_Decode((&(pVal->tc74s.gps_time)), pBitStrm, pErrCode);
	                                            	    if (ret) {
	                                            	        /*Decode mission_time */
	                                            	        ret = asn1SccT_Double_ACN_Decode((&(pVal->tc74s.mission_time)), pBitStrm, pErrCode);
	                                            	    }

	                                            	}

	                                            }
	                                            if (ret) {
	                                                /*Decode pt1000s */
	                                                if (pVal->exist.pt1000s) {
	                                                	/*Decode data */
	                                                	ret = asn1SccPT1000s_All_Data_ACN_Decode((&(pVal->pt1000s.data)), pBitStrm, pErrCode);
	                                                	if (ret) {
	                                                	    /*Decode gps_time */
	                                                	    ret = asn1SccT_Double_ACN_Decode((&(pVal->pt1000s.gps_time)), pBitStrm, pErrCode);
	                                                	    if (ret) {
	                                                	        /*Decode mission_time */
	                                                	        ret = asn1SccT_Double_ACN_Decode((&(pVal->pt1000s.mission_time)), pBitStrm, pErrCode);
	                                                	    }

	                                                	}

	                                                }
	                                                if (ret) {
	                                                    /*Decode ps1 */
	                                                    if (pVal->exist.ps1) {
	                                                    	/*Decode data */
	                                                    	ret = asn1SccPS_All_Data_ACN_Decode((&(pVal->ps1.data)), pBitStrm, pErrCode);
	                                                    	if (ret) {
	                                                    	    /*Decode gps_time */
	                                                    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->ps1.gps_time)), pBitStrm, pErrCode);
	                                                    	    if (ret) {
	                                                    	        /*Decode mission_time */
	                                                    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->ps1.mission_time)), pBitStrm, pErrCode);
	                                                    	    }

	                                                    	}

	                                                    }
	                                                    if (ret) {
	                                                        /*Decode ps2 */
	                                                        if (pVal->exist.ps2) {
	                                                        	/*Decode data */
	                                                        	ret = asn1SccPS_All_Data_ACN_Decode((&(pVal->ps2.data)), pBitStrm, pErrCode);
	                                                        	if (ret) {
	                                                        	    /*Decode gps_time */
	                                                        	    ret = asn1SccT_Double_ACN_Decode((&(pVal->ps2.gps_time)), pBitStrm, pErrCode);
	                                                        	    if (ret) {
	                                                        	        /*Decode mission_time */
	                                                        	        ret = asn1SccT_Double_ACN_Decode((&(pVal->ps2.mission_time)), pBitStrm, pErrCode);
	                                                        	    }

	                                                        	}

	                                                        }
	                                                        if (ret) {
	                                                            /*Decode heater1 */
	                                                            if (pVal->exist.heater1) {
	                                                            	/*Decode data */
	                                                            	ret = asn1SccHeater_Data_ACN_Decode((&(pVal->heater1.data)), pBitStrm, pErrCode);
	                                                            	if (ret) {
	                                                            	    /*Decode gps_time */
	                                                            	    ret = asn1SccT_Double_ACN_Decode((&(pVal->heater1.gps_time)), pBitStrm, pErrCode);
	                                                            	    if (ret) {
	                                                            	        /*Decode mission_time */
	                                                            	        ret = asn1SccT_Double_ACN_Decode((&(pVal->heater1.mission_time)), pBitStrm, pErrCode);
	                                                            	    }

	                                                            	}

	                                                            }
	                                                            if (ret) {
	                                                                /*Decode heater2 */
	                                                                if (pVal->exist.heater2) {
	                                                                	/*Decode data */
	                                                                	ret = asn1SccHeater_Data_ACN_Decode((&(pVal->heater2.data)), pBitStrm, pErrCode);
	                                                                	if (ret) {
	                                                                	    /*Decode gps_time */
	                                                                	    ret = asn1SccT_Double_ACN_Decode((&(pVal->heater2.gps_time)), pBitStrm, pErrCode);
	                                                                	    if (ret) {
	                                                                	        /*Decode mission_time */
	                                                                	        ret = asn1SccT_Double_ACN_Decode((&(pVal->heater2.mission_time)), pBitStrm, pErrCode);
	                                                                	    }

	                                                                	}

	                                                                }
	                                                                if (ret) {
	                                                                    /*Decode anemometer */
	                                                                    if (pVal->exist.anemometer) {
	                                                                    	/*Decode data */
	                                                                    	ret = asn1SccT_UInt64_ACN_Decode((&(pVal->anemometer.data)), pBitStrm, pErrCode);
	                                                                    	if (ret) {
	                                                                    	    /*Decode gps_time */
	                                                                    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->anemometer.gps_time)), pBitStrm, pErrCode);
	                                                                    	    if (ret) {
	                                                                    	        /*Decode mission_time */
	                                                                    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->anemometer.mission_time)), pBitStrm, pErrCode);
	                                                                    	    }

	                                                                    	}

	                                                                    }
	                                                                }

	                                                            }

	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && asn1SccOBSW_DP_Data_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccOBSW_DP_SingleData_gps_Equal(const asn1SccOBSW_DP_SingleData_gps* pVal1, const asn1SccOBSW_DP_SingleData_gps* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccGPS_PVT_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_SingleData_imu_Equal(const asn1SccOBSW_DP_SingleData_imu* pVal1, const asn1SccOBSW_DP_SingleData_imu* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccIMU_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_SingleData_tc74s_Equal(const asn1SccOBSW_DP_SingleData_tc74s* pVal1, const asn1SccOBSW_DP_SingleData_tc74s* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccTC74s_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_SingleData_pt1000s_Equal(const asn1SccOBSW_DP_SingleData_pt1000s* pVal1, const asn1SccOBSW_DP_SingleData_pt1000s* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPT1000s_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_SingleData_ps1_Equal(const asn1SccOBSW_DP_SingleData_ps1* pVal1, const asn1SccOBSW_DP_SingleData_ps1* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPS_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_SingleData_ps2_Equal(const asn1SccOBSW_DP_SingleData_ps2* pVal1, const asn1SccOBSW_DP_SingleData_ps2* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPS_All_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_SingleData_heater1_Equal(const asn1SccOBSW_DP_SingleData_heater1* pVal1, const asn1SccOBSW_DP_SingleData_heater1* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccHeater_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_SingleData_heater2_Equal(const asn1SccOBSW_DP_SingleData_heater2* pVal1, const asn1SccOBSW_DP_SingleData_heater2* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccHeater_Data_Equal((&(pVal1->data)), (&(pVal2->data)));

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_SingleData_anemometer_Equal(const asn1SccOBSW_DP_SingleData_anemometer* pVal1, const asn1SccOBSW_DP_SingleData_anemometer* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->data == pVal2->data);

    if (ret) {
        ret = (pVal1->gps_time == pVal2->gps_time);

        if (ret) {
            ret = (pVal1->mission_time == pVal2->mission_time);

        }

    }

	return ret;

}

flag asn1SccOBSW_DP_SingleData_Equal(const asn1SccOBSW_DP_SingleData* pVal1, const asn1SccOBSW_DP_SingleData* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->kind == pVal2->kind);
    if (ret) {
    	switch(pVal1->kind) 
    	{
    	case gps_PRESENT:
    		ret = asn1SccOBSW_DP_SingleData_gps_Equal((&(pVal1->u.gps)), (&(pVal2->u.gps)));
    		break;
    	case imu_PRESENT:
    		ret = asn1SccOBSW_DP_SingleData_imu_Equal((&(pVal1->u.imu)), (&(pVal2->u.imu)));
    		break;
    	case tc74s_PRESENT:
    		ret = asn1SccOBSW_DP_SingleData_tc74s_Equal((&(pVal1->u.tc74s)), (&(pVal2->u.tc74s)));
    		break;
    	case pt1000s_PRESENT:
    		ret = asn1SccOBSW_DP_SingleData_pt1000s_Equal((&(pVal1->u.pt1000s)), (&(pVal2->u.pt1000s)));
    		break;
    	case ps1_PRESENT:
    		ret = asn1SccOBSW_DP_SingleData_ps1_Equal((&(pVal1->u.ps1)), (&(pVal2->u.ps1)));
    		break;
    	case ps2_PRESENT:
    		ret = asn1SccOBSW_DP_SingleData_ps2_Equal((&(pVal1->u.ps2)), (&(pVal2->u.ps2)));
    		break;
    	case heater1_PRESENT:
    		ret = asn1SccOBSW_DP_SingleData_heater1_Equal((&(pVal1->u.heater1)), (&(pVal2->u.heater1)));
    		break;
    	case heater2_PRESENT:
    		ret = asn1SccOBSW_DP_SingleData_heater2_Equal((&(pVal1->u.heater2)), (&(pVal2->u.heater2)));
    		break;
    	case anemometer_PRESENT:
    		ret = asn1SccOBSW_DP_SingleData_anemometer_Equal((&(pVal1->u.anemometer)), (&(pVal2->u.anemometer)));
    		break;
    	default: /*COVERAGE_IGNORE*/
    		ret = FALSE;    /*COVERAGE_IGNORE*/
    	}
    } /*COVERAGE_IGNORE*/
	return ret;

}

void asn1SccOBSW_DP_SingleData_gps_Initialize(asn1SccOBSW_DP_SingleData_gps* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccGPS_PVT_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_SingleData_imu_Initialize(asn1SccOBSW_DP_SingleData_imu* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccIMU_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_SingleData_tc74s_Initialize(asn1SccOBSW_DP_SingleData_tc74s* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccTC74s_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_SingleData_pt1000s_Initialize(asn1SccOBSW_DP_SingleData_pt1000s* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccPT1000s_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_SingleData_ps1_Initialize(asn1SccOBSW_DP_SingleData_ps1* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccPS_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_SingleData_ps2_Initialize(asn1SccOBSW_DP_SingleData_ps2* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccPS_All_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_SingleData_heater1_Initialize(asn1SccOBSW_DP_SingleData_heater1* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccHeater_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_SingleData_heater2_Initialize(asn1SccOBSW_DP_SingleData_heater2* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccHeater_Data_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_SingleData_anemometer_Initialize(asn1SccOBSW_DP_SingleData_anemometer* pVal)
{
	(void)pVal;



	/*set data */
	asn1SccT_UInt64_Initialize((&(pVal->data)));
	/*set gps_time */
	asn1SccT_Double_Initialize((&(pVal->gps_time)));
	/*set mission_time */
	asn1SccT_Double_Initialize((&(pVal->mission_time)));
}
void asn1SccOBSW_DP_SingleData_Initialize(asn1SccOBSW_DP_SingleData* pVal)
{
	(void)pVal;


	/*set gps*/
	pVal->kind = gps_PRESENT;
	asn1SccOBSW_DP_SingleData_gps_Initialize((&(pVal->u.gps)));
}

flag asn1SccOBSW_DP_SingleData_IsConstraintValid(const asn1SccOBSW_DP_SingleData* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->kind == gps_PRESENT) {
    	ret = asn1SccGPS_PVT_IsConstraintValid((&(pVal->u.gps.data)), pErrCode);
    	if (ret) {
    	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.gps.gps_time)), pErrCode);
    	    if (ret) {
    	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.gps.mission_time)), pErrCode);
    	    }
    	}
    }
    if (ret) {
        if (pVal->kind == imu_PRESENT) {
        	ret = asn1SccIMU_All_Data_IsConstraintValid((&(pVal->u.imu.data)), pErrCode);
        	if (ret) {
        	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.imu.gps_time)), pErrCode);
        	    if (ret) {
        	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.imu.mission_time)), pErrCode);
        	    }
        	}
        }
        if (ret) {
            if (pVal->kind == tc74s_PRESENT) {
            	ret = asn1SccTC74s_All_Data_IsConstraintValid((&(pVal->u.tc74s.data)), pErrCode);
            	if (ret) {
            	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.tc74s.gps_time)), pErrCode);
            	    if (ret) {
            	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.tc74s.mission_time)), pErrCode);
            	    }
            	}
            }
            if (ret) {
                if (pVal->kind == pt1000s_PRESENT) {
                	ret = asn1SccPT1000s_All_Data_IsConstraintValid((&(pVal->u.pt1000s.data)), pErrCode);
                	if (ret) {
                	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.pt1000s.gps_time)), pErrCode);
                	    if (ret) {
                	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.pt1000s.mission_time)), pErrCode);
                	    }
                	}
                }
                if (ret) {
                    if (pVal->kind == ps1_PRESENT) {
                    	ret = asn1SccPS_All_Data_IsConstraintValid((&(pVal->u.ps1.data)), pErrCode);
                    	if (ret) {
                    	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.ps1.gps_time)), pErrCode);
                    	    if (ret) {
                    	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.ps1.mission_time)), pErrCode);
                    	    }
                    	}
                    }
                    if (ret) {
                        if (pVal->kind == ps2_PRESENT) {
                        	ret = asn1SccPS_All_Data_IsConstraintValid((&(pVal->u.ps2.data)), pErrCode);
                        	if (ret) {
                        	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.ps2.gps_time)), pErrCode);
                        	    if (ret) {
                        	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.ps2.mission_time)), pErrCode);
                        	    }
                        	}
                        }
                        if (ret) {
                            if (pVal->kind == heater1_PRESENT) {
                            	ret = asn1SccHeater_Data_IsConstraintValid((&(pVal->u.heater1.data)), pErrCode);
                            	if (ret) {
                            	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.heater1.gps_time)), pErrCode);
                            	    if (ret) {
                            	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.heater1.mission_time)), pErrCode);
                            	    }
                            	}
                            }
                            if (ret) {
                                if (pVal->kind == heater2_PRESENT) {
                                	ret = asn1SccHeater_Data_IsConstraintValid((&(pVal->u.heater2.data)), pErrCode);
                                	if (ret) {
                                	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.heater2.gps_time)), pErrCode);
                                	    if (ret) {
                                	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.heater2.mission_time)), pErrCode);
                                	    }
                                	}
                                }
                                if (ret) {
                                    if (pVal->kind == anemometer_PRESENT) {
                                    	ret = asn1SccT_UInt64_IsConstraintValid((&(pVal->u.anemometer.data)), pErrCode);
                                    	if (ret) {
                                    	    ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.anemometer.gps_time)), pErrCode);
                                    	    if (ret) {
                                    	        ret = asn1SccT_Double_IsConstraintValid((&(pVal->u.anemometer.mission_time)), pErrCode);
                                    	    }
                                    	}
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccOBSW_DP_SingleData_Encode(const asn1SccOBSW_DP_SingleData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccOBSW_DP_SingleData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case gps_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccGPS_PVT_Encode((&(pVal->u.gps.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_Encode((&(pVal->u.gps.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_Encode((&(pVal->u.gps.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }
	    	}
	    	break;
	    case imu_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccIMU_All_Data_Encode((&(pVal->u.imu.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_Encode((&(pVal->u.imu.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_Encode((&(pVal->u.imu.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }
	    	}
	    	break;
	    case tc74s_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccTC74s_All_Data_Encode((&(pVal->u.tc74s.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_Encode((&(pVal->u.tc74s.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_Encode((&(pVal->u.tc74s.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }
	    	}
	    	break;
	    case pt1000s_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccPT1000s_All_Data_Encode((&(pVal->u.pt1000s.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_Encode((&(pVal->u.pt1000s.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_Encode((&(pVal->u.pt1000s.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }
	    	}
	    	break;
	    case ps1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccPS_All_Data_Encode((&(pVal->u.ps1.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_Encode((&(pVal->u.ps1.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_Encode((&(pVal->u.ps1.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }
	    	}
	    	break;
	    case ps2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccPS_All_Data_Encode((&(pVal->u.ps2.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_Encode((&(pVal->u.ps2.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_Encode((&(pVal->u.ps2.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }
	    	}
	    	break;
	    case heater1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccHeater_Data_Encode((&(pVal->u.heater1.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_Encode((&(pVal->u.heater1.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_Encode((&(pVal->u.heater1.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }
	    	}
	    	break;
	    case heater2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccHeater_Data_Encode((&(pVal->u.heater2.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_Encode((&(pVal->u.heater2.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_Encode((&(pVal->u.heater2.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }
	    	}
	    	break;
	    case anemometer_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccT_UInt64_Encode((&(pVal->u.anemometer.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_Encode((&(pVal->u.anemometer.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_Encode((&(pVal->u.anemometer.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }
	    	}
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_OBSW_DP_SINGLEDATA;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccOBSW_DP_SingleData_Decode(asn1SccOBSW_DP_SingleData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint asn1SccOBSW_DP_SingleData_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &asn1SccOBSW_DP_SingleData_index_tmp, 0, 8);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_OBSW_DP_SINGLEDATA;
	if (ret) {
	    switch(asn1SccOBSW_DP_SingleData_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = gps_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccGPS_PVT_Decode((&(pVal->u.gps.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_Decode((&(pVal->u.gps.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_Decode((&(pVal->u.gps.mission_time)), pBitStrm, pErrCode);
	    	    }
	    	}
	    	break;
	    case 1:
	    	pVal->kind = imu_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccIMU_All_Data_Decode((&(pVal->u.imu.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_Decode((&(pVal->u.imu.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_Decode((&(pVal->u.imu.mission_time)), pBitStrm, pErrCode);
	    	    }
	    	}
	    	break;
	    case 2:
	    	pVal->kind = tc74s_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccTC74s_All_Data_Decode((&(pVal->u.tc74s.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_Decode((&(pVal->u.tc74s.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_Decode((&(pVal->u.tc74s.mission_time)), pBitStrm, pErrCode);
	    	    }
	    	}
	    	break;
	    case 3:
	    	pVal->kind = pt1000s_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccPT1000s_All_Data_Decode((&(pVal->u.pt1000s.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_Decode((&(pVal->u.pt1000s.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_Decode((&(pVal->u.pt1000s.mission_time)), pBitStrm, pErrCode);
	    	    }
	    	}
	    	break;
	    case 4:
	    	pVal->kind = ps1_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccPS_All_Data_Decode((&(pVal->u.ps1.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_Decode((&(pVal->u.ps1.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_Decode((&(pVal->u.ps1.mission_time)), pBitStrm, pErrCode);
	    	    }
	    	}
	    	break;
	    case 5:
	    	pVal->kind = ps2_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccPS_All_Data_Decode((&(pVal->u.ps2.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_Decode((&(pVal->u.ps2.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_Decode((&(pVal->u.ps2.mission_time)), pBitStrm, pErrCode);
	    	    }
	    	}
	    	break;
	    case 6:
	    	pVal->kind = heater1_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccHeater_Data_Decode((&(pVal->u.heater1.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_Decode((&(pVal->u.heater1.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_Decode((&(pVal->u.heater1.mission_time)), pBitStrm, pErrCode);
	    	    }
	    	}
	    	break;
	    case 7:
	    	pVal->kind = heater2_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccHeater_Data_Decode((&(pVal->u.heater2.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_Decode((&(pVal->u.heater2.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_Decode((&(pVal->u.heater2.mission_time)), pBitStrm, pErrCode);
	    	    }
	    	}
	    	break;
	    case 8:
	    	pVal->kind = anemometer_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccT_UInt64_Decode((&(pVal->u.anemometer.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_Decode((&(pVal->u.anemometer.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_Decode((&(pVal->u.anemometer.mission_time)), pBitStrm, pErrCode);
	    	    }
	    	}
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_OBSW_DP_SINGLEDATA;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && asn1SccOBSW_DP_SingleData_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccOBSW_DP_SingleData_ACN_Encode(const asn1SccOBSW_DP_SingleData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccOBSW_DP_SingleData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case gps_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccGPS_PVT_ACN_Encode((&(pVal->u.gps.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->u.gps.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->u.gps.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }

	    	}

	    	break;
	    case imu_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccIMU_All_Data_ACN_Encode((&(pVal->u.imu.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->u.imu.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->u.imu.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }

	    	}

	    	break;
	    case tc74s_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccTC74s_All_Data_ACN_Encode((&(pVal->u.tc74s.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->u.tc74s.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->u.tc74s.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }

	    	}

	    	break;
	    case pt1000s_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccPT1000s_All_Data_ACN_Encode((&(pVal->u.pt1000s.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->u.pt1000s.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->u.pt1000s.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }

	    	}

	    	break;
	    case ps1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccPS_All_Data_ACN_Encode((&(pVal->u.ps1.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->u.ps1.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->u.ps1.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }

	    	}

	    	break;
	    case ps2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccPS_All_Data_ACN_Encode((&(pVal->u.ps2.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->u.ps2.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->u.ps2.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }

	    	}

	    	break;
	    case heater1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccHeater_Data_ACN_Encode((&(pVal->u.heater1.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->u.heater1.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->u.heater1.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }

	    	}

	    	break;
	    case heater2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccHeater_Data_ACN_Encode((&(pVal->u.heater2.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->u.heater2.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->u.heater2.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }

	    	}

	    	break;
	    case anemometer_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 8);
	    	/*Encode data */
	    	ret = asn1SccT_UInt64_ACN_Encode((&(pVal->u.anemometer.data)), pBitStrm, pErrCode, FALSE);
	    	if (ret) {
	    	    /*Encode gps_time */
	    	    ret = asn1SccT_Double_ACN_Encode((&(pVal->u.anemometer.gps_time)), pBitStrm, pErrCode, FALSE);
	    	    if (ret) {
	    	        /*Encode mission_time */
	    	        ret = asn1SccT_Double_ACN_Encode((&(pVal->u.anemometer.mission_time)), pBitStrm, pErrCode, FALSE);
	    	    }

	    	}

	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_ENCODE_OBSW_DP_SINGLEDATA;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    } /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccOBSW_DP_SingleData_ACN_Decode(asn1SccOBSW_DP_SingleData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccSint TASEC_LAB_B2SPACE_DATAVIEW_OBSW_DP_SingleData_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &TASEC_LAB_B2SPACE_DATAVIEW_OBSW_DP_SingleData_index_tmp, 0, 8);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_OBSW_DP_SINGLEDATA;
	if (ret) {
	    switch(TASEC_LAB_B2SPACE_DATAVIEW_OBSW_DP_SingleData_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = gps_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccGPS_PVT_ACN_Decode((&(pVal->u.gps.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->u.gps.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->u.gps.mission_time)), pBitStrm, pErrCode);
	    	    }

	    	}

	    	break;
	    case 1:
	    	pVal->kind = imu_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccIMU_All_Data_ACN_Decode((&(pVal->u.imu.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->u.imu.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->u.imu.mission_time)), pBitStrm, pErrCode);
	    	    }

	    	}

	    	break;
	    case 2:
	    	pVal->kind = tc74s_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccTC74s_All_Data_ACN_Decode((&(pVal->u.tc74s.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->u.tc74s.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->u.tc74s.mission_time)), pBitStrm, pErrCode);
	    	    }

	    	}

	    	break;
	    case 3:
	    	pVal->kind = pt1000s_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccPT1000s_All_Data_ACN_Decode((&(pVal->u.pt1000s.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->u.pt1000s.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->u.pt1000s.mission_time)), pBitStrm, pErrCode);
	    	    }

	    	}

	    	break;
	    case 4:
	    	pVal->kind = ps1_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccPS_All_Data_ACN_Decode((&(pVal->u.ps1.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->u.ps1.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->u.ps1.mission_time)), pBitStrm, pErrCode);
	    	    }

	    	}

	    	break;
	    case 5:
	    	pVal->kind = ps2_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccPS_All_Data_ACN_Decode((&(pVal->u.ps2.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->u.ps2.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->u.ps2.mission_time)), pBitStrm, pErrCode);
	    	    }

	    	}

	    	break;
	    case 6:
	    	pVal->kind = heater1_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccHeater_Data_ACN_Decode((&(pVal->u.heater1.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->u.heater1.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->u.heater1.mission_time)), pBitStrm, pErrCode);
	    	    }

	    	}

	    	break;
	    case 7:
	    	pVal->kind = heater2_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccHeater_Data_ACN_Decode((&(pVal->u.heater2.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->u.heater2.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->u.heater2.mission_time)), pBitStrm, pErrCode);
	    	    }

	    	}

	    	break;
	    case 8:
	    	pVal->kind = anemometer_PRESENT;
	    	/*Decode data */
	    	ret = asn1SccT_UInt64_ACN_Decode((&(pVal->u.anemometer.data)), pBitStrm, pErrCode);
	    	if (ret) {
	    	    /*Decode gps_time */
	    	    ret = asn1SccT_Double_ACN_Decode((&(pVal->u.anemometer.gps_time)), pBitStrm, pErrCode);
	    	    if (ret) {
	    	        /*Decode mission_time */
	    	        ret = asn1SccT_Double_ACN_Decode((&(pVal->u.anemometer.mission_time)), pBitStrm, pErrCode);
	    	    }

	    	}

	    	break;
	    default: /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_OBSW_DP_SINGLEDATA;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    } 
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccOBSW_DP_SingleData_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccHTL_Config_Equal(const asn1SccHTL_Config* pVal1, const asn1SccHTL_Config* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->exist.press_5km == pVal2->exist.press_5km);
    if (ret && pVal1->exist.press_5km) {
    	ret = (pVal1->press_5km == pVal2->press_5km);
    }

    if (ret) {
        ret = (pVal1->exist.press_10km == pVal2->exist.press_10km);
        if (ret && pVal1->exist.press_10km) {
        	ret = (pVal1->press_10km == pVal2->press_10km);
        }

        if (ret) {
            ret = (pVal1->exist.press_18km == pVal2->exist.press_18km);
            if (ret && pVal1->exist.press_18km) {
            	ret = (pVal1->press_18km == pVal2->press_18km);
            }

            if (ret) {
                ret = (pVal1->exist.a1_duration_emergency_secs == pVal2->exist.a1_duration_emergency_secs);
                if (ret && pVal1->exist.a1_duration_emergency_secs) {
                	ret = (pVal1->a1_duration_emergency_secs == pVal2->a1_duration_emergency_secs);
                }

                if (ret) {
                    ret = (pVal1->exist.a1_duration_max_secs == pVal2->exist.a1_duration_max_secs);
                    if (ret && pVal1->exist.a1_duration_max_secs) {
                    	ret = (pVal1->a1_duration_max_secs == pVal2->a1_duration_max_secs);
                    }

                    if (ret) {
                        ret = (pVal1->exist.a2_duration_max_secs == pVal2->exist.a2_duration_max_secs);
                        if (ret && pVal1->exist.a2_duration_max_secs) {
                        	ret = (pVal1->a2_duration_max_secs == pVal2->a2_duration_max_secs);
                        }

                        if (ret) {
                            ret = (pVal1->exist.f1_duration_secs == pVal2->exist.f1_duration_secs);
                            if (ret && pVal1->exist.f1_duration_secs) {
                            	ret = (pVal1->f1_duration_secs == pVal2->f1_duration_secs);
                            }

                            if (ret) {
                                ret = (pVal1->exist.f2_duration_secs == pVal2->exist.f2_duration_secs);
                                if (ret && pVal1->exist.f2_duration_secs) {
                                	ret = (pVal1->f2_duration_secs == pVal2->f2_duration_secs);
                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void asn1SccHTL_Config_Initialize(asn1SccHTL_Config* pVal)
{
	(void)pVal;



	/*set press_5km */
	pVal->exist.press_5km = 1;
	asn1SccT_Float_Initialize((&(pVal->press_5km)));
	/*set press_10km */
	pVal->exist.press_10km = 1;
	asn1SccT_Float_Initialize((&(pVal->press_10km)));
	/*set press_18km */
	pVal->exist.press_18km = 1;
	asn1SccT_Float_Initialize((&(pVal->press_18km)));
	/*set a1_duration_emergency_secs */
	pVal->exist.a1_duration_emergency_secs = 1;
	asn1SccT_Double_Initialize((&(pVal->a1_duration_emergency_secs)));
	/*set a1_duration_max_secs */
	pVal->exist.a1_duration_max_secs = 1;
	asn1SccT_Double_Initialize((&(pVal->a1_duration_max_secs)));
	/*set a2_duration_max_secs */
	pVal->exist.a2_duration_max_secs = 1;
	asn1SccT_Double_Initialize((&(pVal->a2_duration_max_secs)));
	/*set f1_duration_secs */
	pVal->exist.f1_duration_secs = 1;
	asn1SccT_UInt32_Initialize((&(pVal->f1_duration_secs)));
	/*set f2_duration_secs */
	pVal->exist.f2_duration_secs = 1;
	asn1SccT_UInt32_Initialize((&(pVal->f2_duration_secs)));
}

flag asn1SccHTL_Config_IsConstraintValid(const asn1SccHTL_Config* pVal, int* pErrCode)
{
    flag ret = TRUE;
    if (pVal->exist.press_5km) {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->press_5km)), pErrCode);
    }
    if (ret) {
        if (pVal->exist.press_10km) {
        	ret = asn1SccT_Float_IsConstraintValid((&(pVal->press_10km)), pErrCode);
        }
        if (ret) {
            if (pVal->exist.press_18km) {
            	ret = asn1SccT_Float_IsConstraintValid((&(pVal->press_18km)), pErrCode);
            }
            if (ret) {
                if (pVal->exist.a1_duration_emergency_secs) {
                	ret = asn1SccT_Double_IsConstraintValid((&(pVal->a1_duration_emergency_secs)), pErrCode);
                }
                if (ret) {
                    if (pVal->exist.a1_duration_max_secs) {
                    	ret = asn1SccT_Double_IsConstraintValid((&(pVal->a1_duration_max_secs)), pErrCode);
                    }
                    if (ret) {
                        if (pVal->exist.a2_duration_max_secs) {
                        	ret = asn1SccT_Double_IsConstraintValid((&(pVal->a2_duration_max_secs)), pErrCode);
                        }
                        if (ret) {
                            if (pVal->exist.f1_duration_secs) {
                            	ret = asn1SccT_UInt32_IsConstraintValid((&(pVal->f1_duration_secs)), pErrCode);
                            }
                            if (ret) {
                                if (pVal->exist.f2_duration_secs) {
                                	ret = asn1SccT_UInt32_IsConstraintValid((&(pVal->f2_duration_secs)), pErrCode);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccHTL_Config_Encode(const asn1SccHTL_Config* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccHTL_Config_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.press_5km);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.press_10km);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.press_18km);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.a1_duration_emergency_secs);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.a1_duration_max_secs);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.a2_duration_max_secs);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.f1_duration_secs);
	                            if (ret) {
	                                BitStream_AppendBit(pBitStrm,pVal->exist.f2_duration_secs);
	                                if (ret) {
	                                    /*Encode press_5km */
	                                    if (pVal->exist.press_5km) {
	                                    	ret = asn1SccT_Float_Encode((&(pVal->press_5km)), pBitStrm, pErrCode, FALSE);
	                                    }
	                                    if (ret) {
	                                        /*Encode press_10km */
	                                        if (pVal->exist.press_10km) {
	                                        	ret = asn1SccT_Float_Encode((&(pVal->press_10km)), pBitStrm, pErrCode, FALSE);
	                                        }
	                                        if (ret) {
	                                            /*Encode press_18km */
	                                            if (pVal->exist.press_18km) {
	                                            	ret = asn1SccT_Float_Encode((&(pVal->press_18km)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                            if (ret) {
	                                                /*Encode a1_duration_emergency_secs */
	                                                if (pVal->exist.a1_duration_emergency_secs) {
	                                                	ret = asn1SccT_Double_Encode((&(pVal->a1_duration_emergency_secs)), pBitStrm, pErrCode, FALSE);
	                                                }
	                                                if (ret) {
	                                                    /*Encode a1_duration_max_secs */
	                                                    if (pVal->exist.a1_duration_max_secs) {
	                                                    	ret = asn1SccT_Double_Encode((&(pVal->a1_duration_max_secs)), pBitStrm, pErrCode, FALSE);
	                                                    }
	                                                    if (ret) {
	                                                        /*Encode a2_duration_max_secs */
	                                                        if (pVal->exist.a2_duration_max_secs) {
	                                                        	ret = asn1SccT_Double_Encode((&(pVal->a2_duration_max_secs)), pBitStrm, pErrCode, FALSE);
	                                                        }
	                                                        if (ret) {
	                                                            /*Encode f1_duration_secs */
	                                                            if (pVal->exist.f1_duration_secs) {
	                                                            	ret = asn1SccT_UInt32_Encode((&(pVal->f1_duration_secs)), pBitStrm, pErrCode, FALSE);
	                                                            }
	                                                            if (ret) {
	                                                                /*Encode f2_duration_secs */
	                                                                if (pVal->exist.f2_duration_secs) {
	                                                                	ret = asn1SccT_UInt32_Encode((&(pVal->f2_duration_secs)), pBitStrm, pErrCode, FALSE);
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccHTL_Config_Decode(asn1SccHTL_Config* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.press_5km = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_HTL_CONFIG;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.press_10km = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_HTL_CONFIG;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.press_18km = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_HTL_CONFIG;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.a1_duration_emergency_secs = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_HTL_CONFIG;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.a1_duration_max_secs = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_HTL_CONFIG;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.a2_duration_max_secs = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_HTL_CONFIG;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.f1_duration_secs = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_HTL_CONFIG;
	                        if (ret) {
	                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                            pVal->exist.f2_duration_secs = presenceBit == 0 ? 0 : 1;
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_HTL_CONFIG;
	                            if (ret) {
	                                /*Decode press_5km */
	                                if (pVal->exist.press_5km) {
	                                	ret = asn1SccT_Float_Decode((&(pVal->press_5km)), pBitStrm, pErrCode);
	                                }
	                                if (ret) {
	                                    /*Decode press_10km */
	                                    if (pVal->exist.press_10km) {
	                                    	ret = asn1SccT_Float_Decode((&(pVal->press_10km)), pBitStrm, pErrCode);
	                                    }
	                                    if (ret) {
	                                        /*Decode press_18km */
	                                        if (pVal->exist.press_18km) {
	                                        	ret = asn1SccT_Float_Decode((&(pVal->press_18km)), pBitStrm, pErrCode);
	                                        }
	                                        if (ret) {
	                                            /*Decode a1_duration_emergency_secs */
	                                            if (pVal->exist.a1_duration_emergency_secs) {
	                                            	ret = asn1SccT_Double_Decode((&(pVal->a1_duration_emergency_secs)), pBitStrm, pErrCode);
	                                            }
	                                            if (ret) {
	                                                /*Decode a1_duration_max_secs */
	                                                if (pVal->exist.a1_duration_max_secs) {
	                                                	ret = asn1SccT_Double_Decode((&(pVal->a1_duration_max_secs)), pBitStrm, pErrCode);
	                                                }
	                                                if (ret) {
	                                                    /*Decode a2_duration_max_secs */
	                                                    if (pVal->exist.a2_duration_max_secs) {
	                                                    	ret = asn1SccT_Double_Decode((&(pVal->a2_duration_max_secs)), pBitStrm, pErrCode);
	                                                    }
	                                                    if (ret) {
	                                                        /*Decode f1_duration_secs */
	                                                        if (pVal->exist.f1_duration_secs) {
	                                                        	ret = asn1SccT_UInt32_Decode((&(pVal->f1_duration_secs)), pBitStrm, pErrCode);
	                                                        }
	                                                        if (ret) {
	                                                            /*Decode f2_duration_secs */
	                                                            if (pVal->exist.f2_duration_secs) {
	                                                            	ret = asn1SccT_UInt32_Decode((&(pVal->f2_duration_secs)), pBitStrm, pErrCode);
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccHTL_Config_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccHTL_Config_ACN_Encode(const asn1SccHTL_Config* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccHTL_Config_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,pVal->exist.press_5km);
	    if (ret) {
	        BitStream_AppendBit(pBitStrm,pVal->exist.press_10km);
	        if (ret) {
	            BitStream_AppendBit(pBitStrm,pVal->exist.press_18km);
	            if (ret) {
	                BitStream_AppendBit(pBitStrm,pVal->exist.a1_duration_emergency_secs);
	                if (ret) {
	                    BitStream_AppendBit(pBitStrm,pVal->exist.a1_duration_max_secs);
	                    if (ret) {
	                        BitStream_AppendBit(pBitStrm,pVal->exist.a2_duration_max_secs);
	                        if (ret) {
	                            BitStream_AppendBit(pBitStrm,pVal->exist.f1_duration_secs);
	                            if (ret) {
	                                BitStream_AppendBit(pBitStrm,pVal->exist.f2_duration_secs);
	                                if (ret) {
	                                    /*Encode press_5km */
	                                    if (pVal->exist.press_5km) {
	                                    	ret = asn1SccT_Float_ACN_Encode((&(pVal->press_5km)), pBitStrm, pErrCode, FALSE);
	                                    }
	                                    if (ret) {
	                                        /*Encode press_10km */
	                                        if (pVal->exist.press_10km) {
	                                        	ret = asn1SccT_Float_ACN_Encode((&(pVal->press_10km)), pBitStrm, pErrCode, FALSE);
	                                        }
	                                        if (ret) {
	                                            /*Encode press_18km */
	                                            if (pVal->exist.press_18km) {
	                                            	ret = asn1SccT_Float_ACN_Encode((&(pVal->press_18km)), pBitStrm, pErrCode, FALSE);
	                                            }
	                                            if (ret) {
	                                                /*Encode a1_duration_emergency_secs */
	                                                if (pVal->exist.a1_duration_emergency_secs) {
	                                                	ret = asn1SccT_Double_ACN_Encode((&(pVal->a1_duration_emergency_secs)), pBitStrm, pErrCode, FALSE);
	                                                }
	                                                if (ret) {
	                                                    /*Encode a1_duration_max_secs */
	                                                    if (pVal->exist.a1_duration_max_secs) {
	                                                    	ret = asn1SccT_Double_ACN_Encode((&(pVal->a1_duration_max_secs)), pBitStrm, pErrCode, FALSE);
	                                                    }
	                                                    if (ret) {
	                                                        /*Encode a2_duration_max_secs */
	                                                        if (pVal->exist.a2_duration_max_secs) {
	                                                        	ret = asn1SccT_Double_ACN_Encode((&(pVal->a2_duration_max_secs)), pBitStrm, pErrCode, FALSE);
	                                                        }
	                                                        if (ret) {
	                                                            /*Encode f1_duration_secs */
	                                                            if (pVal->exist.f1_duration_secs) {
	                                                            	ret = asn1SccT_UInt32_ACN_Encode((&(pVal->f1_duration_secs)), pBitStrm, pErrCode, FALSE);
	                                                            }
	                                                            if (ret) {
	                                                                /*Encode f2_duration_secs */
	                                                                if (pVal->exist.f2_duration_secs) {
	                                                                	ret = asn1SccT_UInt32_ACN_Encode((&(pVal->f2_duration_secs)), pBitStrm, pErrCode, FALSE);
	                                                                }
	                                                            }

	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccHTL_Config_ACN_Decode(asn1SccHTL_Config* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	flag presenceBit;

	ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	pVal->exist.press_5km = presenceBit == 0 ? 0 : 1;
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_HTL_CONFIG;
	if (ret) {
	    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	    pVal->exist.press_10km = presenceBit == 0 ? 0 : 1;
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_HTL_CONFIG;
	    if (ret) {
	        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	        pVal->exist.press_18km = presenceBit == 0 ? 0 : 1;
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_HTL_CONFIG;
	        if (ret) {
	            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	            pVal->exist.a1_duration_emergency_secs = presenceBit == 0 ? 0 : 1;
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_HTL_CONFIG;
	            if (ret) {
	                ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                pVal->exist.a1_duration_max_secs = presenceBit == 0 ? 0 : 1;
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_HTL_CONFIG;
	                if (ret) {
	                    ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                    pVal->exist.a2_duration_max_secs = presenceBit == 0 ? 0 : 1;
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_HTL_CONFIG;
	                    if (ret) {
	                        ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                        pVal->exist.f1_duration_secs = presenceBit == 0 ? 0 : 1;
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_HTL_CONFIG;
	                        if (ret) {
	                            ret = BitStream_ReadBit(pBitStrm, &presenceBit);
	                            pVal->exist.f2_duration_secs = presenceBit == 0 ? 0 : 1;
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_HTL_CONFIG;
	                            if (ret) {
	                                /*Decode press_5km */
	                                if (pVal->exist.press_5km) {
	                                	ret = asn1SccT_Float_ACN_Decode((&(pVal->press_5km)), pBitStrm, pErrCode);
	                                }
	                                if (ret) {
	                                    /*Decode press_10km */
	                                    if (pVal->exist.press_10km) {
	                                    	ret = asn1SccT_Float_ACN_Decode((&(pVal->press_10km)), pBitStrm, pErrCode);
	                                    }
	                                    if (ret) {
	                                        /*Decode press_18km */
	                                        if (pVal->exist.press_18km) {
	                                        	ret = asn1SccT_Float_ACN_Decode((&(pVal->press_18km)), pBitStrm, pErrCode);
	                                        }
	                                        if (ret) {
	                                            /*Decode a1_duration_emergency_secs */
	                                            if (pVal->exist.a1_duration_emergency_secs) {
	                                            	ret = asn1SccT_Double_ACN_Decode((&(pVal->a1_duration_emergency_secs)), pBitStrm, pErrCode);
	                                            }
	                                            if (ret) {
	                                                /*Decode a1_duration_max_secs */
	                                                if (pVal->exist.a1_duration_max_secs) {
	                                                	ret = asn1SccT_Double_ACN_Decode((&(pVal->a1_duration_max_secs)), pBitStrm, pErrCode);
	                                                }
	                                                if (ret) {
	                                                    /*Decode a2_duration_max_secs */
	                                                    if (pVal->exist.a2_duration_max_secs) {
	                                                    	ret = asn1SccT_Double_ACN_Decode((&(pVal->a2_duration_max_secs)), pBitStrm, pErrCode);
	                                                    }
	                                                    if (ret) {
	                                                        /*Decode f1_duration_secs */
	                                                        if (pVal->exist.f1_duration_secs) {
	                                                        	ret = asn1SccT_UInt32_ACN_Decode((&(pVal->f1_duration_secs)), pBitStrm, pErrCode);
	                                                        }
	                                                        if (ret) {
	                                                            /*Decode f2_duration_secs */
	                                                            if (pVal->exist.f2_duration_secs) {
	                                                            	ret = asn1SccT_UInt32_ACN_Decode((&(pVal->f2_duration_secs)), pBitStrm, pErrCode);
	                                                            }
	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && asn1SccHTL_Config_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccTC_Equal(const asn1SccTC* pVal1, const asn1SccTC* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccTC_Heater_Equal((&(pVal1->heater_of_HTL)), (&(pVal2->heater_of_HTL)));

    if (ret) {
        ret = asn1SccHTL_Config_Equal((&(pVal1->config_of_HTL)), (&(pVal2->config_of_HTL)));

    }

	return ret;

}

void asn1SccTC_Initialize(asn1SccTC* pVal)
{
	(void)pVal;



	/*set heater_of_HTL */
	asn1SccTC_Heater_Initialize((&(pVal->heater_of_HTL)));
	/*set config_of_HTL */
	asn1SccHTL_Config_Initialize((&(pVal->config_of_HTL)));
}

flag asn1SccTC_IsConstraintValid(const asn1SccTC* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccTC_Heater_IsConstraintValid((&(pVal->heater_of_HTL)), pErrCode);
    if (ret) {
        ret = asn1SccHTL_Config_IsConstraintValid((&(pVal->config_of_HTL)), pErrCode);
    }

	return ret;
}

flag asn1SccTC_Encode(const asn1SccTC* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccTC_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heater_of_HTL */
	    ret = asn1SccTC_Heater_Encode((&(pVal->heater_of_HTL)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode config_of_HTL */
	        ret = asn1SccHTL_Config_Encode((&(pVal->config_of_HTL)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTC_Decode(asn1SccTC* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode heater_of_HTL */
	ret = asn1SccTC_Heater_Decode((&(pVal->heater_of_HTL)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode config_of_HTL */
	    ret = asn1SccHTL_Config_Decode((&(pVal->config_of_HTL)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccTC_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccTC_ACN_Encode(const asn1SccTC* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccTC_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode heater_of_HTL */
	    ret = asn1SccTC_Heater_ACN_Encode((&(pVal->heater_of_HTL)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode config_of_HTL */
	        ret = asn1SccHTL_Config_ACN_Encode((&(pVal->config_of_HTL)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccTC_ACN_Decode(asn1SccTC* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode heater_of_HTL */
	ret = asn1SccTC_Heater_ACN_Decode((&(pVal->heater_of_HTL)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode config_of_HTL */
	    ret = asn1SccHTL_Config_ACN_Decode((&(pVal->config_of_HTL)), pBitStrm, pErrCode);
	}


    return ret && asn1SccTC_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int8_Equal(const asn1SccT_Int8* pVal1, const asn1SccT_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

flag asn1SccT_Int8_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int8_ACN_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_ACN_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt8_Equal(const asn1SccT_UInt8* pVal1, const asn1SccT_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

flag asn1SccT_UInt8_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt8_ACN_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_ACN_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccSPI_ID_Equal(const asn1SccSPI_ID* pVal1, const asn1SccSPI_ID* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->bus == pVal2->bus);

    if (ret) {
        ret = (pVal1->cs == pVal2->cs);

    }

	return ret;

}

void asn1SccSPI_ID_Initialize(asn1SccSPI_ID* pVal)
{
	(void)pVal;



	/*set bus */
	asn1SccT_UInt8_Initialize((&(pVal->bus)));
	/*set cs */
	asn1SccT_UInt8_Initialize((&(pVal->cs)));
}

flag asn1SccSPI_ID_IsConstraintValid(const asn1SccSPI_ID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt8_IsConstraintValid((&(pVal->bus)), pErrCode);
    if (ret) {
        ret = asn1SccT_UInt8_IsConstraintValid((&(pVal->cs)), pErrCode);
    }

	return ret;
}

flag asn1SccSPI_ID_Encode(const asn1SccSPI_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccSPI_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = asn1SccT_UInt8_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode cs */
	        ret = asn1SccT_UInt8_Encode((&(pVal->cs)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccSPI_ID_Decode(asn1SccSPI_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = asn1SccT_UInt8_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode cs */
	    ret = asn1SccT_UInt8_Decode((&(pVal->cs)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccSPI_ID_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccSPI_ID_ACN_Encode(const asn1SccSPI_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccSPI_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = asn1SccT_UInt8_ACN_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode cs */
	        ret = asn1SccT_UInt8_ACN_Encode((&(pVal->cs)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccSPI_ID_ACN_Decode(asn1SccSPI_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = asn1SccT_UInt8_ACN_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode cs */
	    ret = asn1SccT_UInt8_ACN_Decode((&(pVal->cs)), pBitStrm, pErrCode);
	}


    return ret && asn1SccSPI_ID_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccI2C_ID_Equal(const asn1SccI2C_ID* pVal1, const asn1SccI2C_ID* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->bus == pVal2->bus);

    if (ret) {
        ret = (pVal1->address == pVal2->address);

    }

	return ret;

}

void asn1SccI2C_ID_Initialize(asn1SccI2C_ID* pVal)
{
	(void)pVal;



	/*set bus */
	asn1SccT_UInt8_Initialize((&(pVal->bus)));
	/*set address */
	asn1SccT_UInt8_Initialize((&(pVal->address)));
}

flag asn1SccI2C_ID_IsConstraintValid(const asn1SccI2C_ID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccT_UInt8_IsConstraintValid((&(pVal->bus)), pErrCode);
    if (ret) {
        ret = asn1SccT_UInt8_IsConstraintValid((&(pVal->address)), pErrCode);
    }

	return ret;
}

flag asn1SccI2C_ID_Encode(const asn1SccI2C_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccI2C_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = asn1SccT_UInt8_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode address */
	        ret = asn1SccT_UInt8_Encode((&(pVal->address)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccI2C_ID_Decode(asn1SccI2C_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = asn1SccT_UInt8_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode address */
	    ret = asn1SccT_UInt8_Decode((&(pVal->address)), pBitStrm, pErrCode);
	}

	return ret  && asn1SccI2C_ID_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccI2C_ID_ACN_Encode(const asn1SccI2C_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccI2C_ID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode bus */
	    ret = asn1SccT_UInt8_ACN_Encode((&(pVal->bus)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode address */
	        ret = asn1SccT_UInt8_ACN_Encode((&(pVal->address)), pBitStrm, pErrCode, FALSE);
	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccI2C_ID_ACN_Decode(asn1SccI2C_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode bus */
	ret = asn1SccT_UInt8_ACN_Decode((&(pVal->bus)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode address */
	    ret = asn1SccT_UInt8_ACN_Decode((&(pVal->address)), pBitStrm, pErrCode);
	}


    return ret && asn1SccI2C_ID_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Boolean_Equal(const asn1SccT_Boolean* pVal1, const asn1SccT_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_Boolean_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Boolean_ACN_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_ACN_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Null_Record_Equal(const asn1SccT_Null_Record* pVal1, const asn1SccT_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

void asn1SccT_Null_Record_Initialize(asn1SccT_Null_Record* pVal)
{
	(void)pVal;


}

flag asn1SccT_Null_Record_IsConstraintValid(const asn1SccT_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_Null_Record_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Null_Record_ACN_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_ACN_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

