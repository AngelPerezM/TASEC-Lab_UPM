pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");

pragma Warnings (Off, "no entities of ""TASTE_BasicTypes"" are referenced");
pragma Warnings (Off, "use clause for package ""TASTE_BasicTypes"" has no effect");
pragma Warnings (Off, "unit ""TASTE_BasicTypes"" is not referenced");
with TASTE_BasicTypes;
pragma Warnings (On, "no entities of ""TASTE_BasicTypes"" are referenced");
pragma Warnings (On, "use clause for package ""TASTE_BasicTypes"" has no effect");
pragma Warnings (On, "unit ""TASTE_BasicTypes"" is not referenced");

pragma Warnings (On, "redundant with clause in body");

pragma Warnings (Off, "use clause for type");
pragma Warnings (Off, "is already use-visible through previous use_type_clause at");
use type TASTE_BasicTypes.asn1SccT_UInt8;
use type TASTE_BasicTypes.asn1SccT_UInt32;
use type TASTE_BasicTypes.asn1SccT_Int32;
pragma Warnings (On, "use clause for type");
pragma Warnings (On, "is already use-visible through previous use_type_clause at");
package body TASEC_LAB_B2SPACE_DATAVIEW with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccSPI_ID_Equal (val1, val2 :  asn1SccSPI_ID) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.bus = val2.bus);

    if ret then
        ret := (val1.cs = val2.cs);

    end if;
	return ret;

end asn1SccSPI_ID_Equal;

function asn1SccSPI_ID_Init return asn1SccSPI_ID
is
    val: asn1SccSPI_ID;
begin

    --set bus 
    val.bus := TASTE_BasicTypes.asn1SccT_UInt8_Init;
    --set cs 
    val.cs := TASTE_BasicTypes.asn1SccT_UInt8_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSPI_ID_Init;

function asn1SccSPI_ID_IsConstraintValid(val : asn1SccSPI_ID) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := TASTE_BasicTypes.asn1SccT_UInt8_IsConstraintValid(val.bus);
    if ret.Success then
        ret := TASTE_BasicTypes.asn1SccT_UInt8_IsConstraintValid(val.cs);
    end if;
    return ret;
end asn1SccSPI_ID_IsConstraintValid;



function asn1SccI2C_ID_Equal (val1, val2 :  asn1SccI2C_ID) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.bus = val2.bus);

    if ret then
        ret := (val1.address = val2.address);

    end if;
	return ret;

end asn1SccI2C_ID_Equal;

function asn1SccI2C_ID_Init return asn1SccI2C_ID
is
    val: asn1SccI2C_ID;
begin

    --set bus 
    val.bus := TASTE_BasicTypes.asn1SccT_UInt8_Init;
    --set address 
    val.address := TASTE_BasicTypes.asn1SccT_UInt8_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccI2C_ID_Init;

function asn1SccI2C_ID_IsConstraintValid(val : asn1SccI2C_ID) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := TASTE_BasicTypes.asn1SccT_UInt8_IsConstraintValid(val.bus);
    if ret.Success then
        ret := TASTE_BasicTypes.asn1SccT_UInt8_IsConstraintValid(val.address);
    end if;
    return ret;
end asn1SccI2C_ID_IsConstraintValid;



function asn1SccPS_Raw_Data_Equal (val1, val2 :  asn1SccPS_Raw_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.d1 = val2.d1);

    if ret then
        ret := (val1.d2 = val2.d2);

    end if;
	return ret;

end asn1SccPS_Raw_Data_Equal;

function asn1SccPS_Raw_Data_Init return asn1SccPS_Raw_Data
is
    val: asn1SccPS_Raw_Data;
begin

    --set d1 
    val.d1 := TASTE_BasicTypes.asn1SccT_UInt32_Init;
    --set d2 
    val.d2 := TASTE_BasicTypes.asn1SccT_UInt32_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPS_Raw_Data_Init;

function asn1SccPS_Raw_Data_IsConstraintValid(val : asn1SccPS_Raw_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := TASTE_BasicTypes.asn1SccT_UInt32_IsConstraintValid(val.d1);
    if ret.Success then
        ret := TASTE_BasicTypes.asn1SccT_UInt32_IsConstraintValid(val.d2);
    end if;
    return ret;
end asn1SccPS_Raw_Data_IsConstraintValid;



function asn1SccTC74s_I2CBuses_Equal (val1, val2 :  asn1SccTC74s_I2CBuses) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 5 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccTC74s_I2CBuses_Equal;

function asn1SccTC74s_I2CBuses_Init return asn1SccTC74s_I2CBuses
is
    val: asn1SccTC74s_I2CBuses;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 5 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=5);
        val.Data(i1) := TASTE_BasicTypes.asn1SccT_Int32_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC74s_I2CBuses_Init;

function asn1SccTC74s_I2CBuses_IsConstraintValid(val : asn1SccTC74s_I2CBuses) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    i1 := val.Data'First;
    while ret.Success and i1 <= 5 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 5);
        ret := TASTE_BasicTypes.asn1SccT_Int32_IsConstraintValid(val.Data(i1));
        i1 := i1+1;
    end loop;
    return ret;
end asn1SccTC74s_I2CBuses_IsConstraintValid;



function asn1SccPT1000s_Channels_Equal (val1, val2 :  asn1SccPT1000s_Channels) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 7 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccPT1000s_Channels_Equal;

function asn1SccPT1000s_Channels_Init return asn1SccPT1000s_Channels
is
    val: asn1SccPT1000s_Channels;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 7 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=7);
        val.Data(i1) := TASTE_BasicTypes.asn1SccT_Int32_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPT1000s_Channels_Init;

function asn1SccPT1000s_Channels_IsConstraintValid(val : asn1SccPT1000s_Channels) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    i1 := val.Data'First;
    while ret.Success and i1 <= 7 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 7);
        ret := TASTE_BasicTypes.asn1SccT_Int32_IsConstraintValid(val.Data(i1));
        i1 := i1+1;
    end loop;
    return ret;
end asn1SccPT1000s_Channels_IsConstraintValid;



function asn1SccPS_Processed_Data_Equal (val1, val2 :  asn1SccPS_Processed_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.pressure = val2.pressure);

    if ret then
        ret := (val1.temp = val2.temp);

    end if;
	return ret;

end asn1SccPS_Processed_Data_Equal;

function asn1SccPS_Processed_Data_Init return asn1SccPS_Processed_Data
is
    val: asn1SccPS_Processed_Data;
begin

    --set pressure 
    val.pressure := TASTE_BasicTypes.asn1SccT_Int32_Init;
    --set temp 
    val.temp := TASTE_BasicTypes.asn1SccT_Int32_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPS_Processed_Data_Init;

function asn1SccPS_Processed_Data_IsConstraintValid(val : asn1SccPS_Processed_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := TASTE_BasicTypes.asn1SccT_Int32_IsConstraintValid(val.pressure);
    if ret.Success then
        ret := TASTE_BasicTypes.asn1SccT_Int32_IsConstraintValid(val.temp);
    end if;
    return ret;
end asn1SccPS_Processed_Data_IsConstraintValid;



function asn1SccDate_Time_Equal (val1, val2 :  asn1SccDate_Time) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.day = val2.day);

    if ret then
        ret := (val1.month = val2.month);

        if ret then
            ret := (val1.year = val2.year);

            if ret then
                ret := (val1.hour = val2.hour);

                if ret then
                    ret := (val1.minute = val2.minute);

                    if ret then
                        ret := (val1.second = val2.second);

                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccDate_Time_Equal;

function asn1SccDate_Time_Init return asn1SccDate_Time
is
    val: asn1SccDate_Time;
begin

    --set day 
    val.day := TASTE_BasicTypes.asn1SccT_Int32_Init;
    --set month 
    val.month := TASTE_BasicTypes.asn1SccT_Int32_Init;
    --set year 
    val.year := TASTE_BasicTypes.asn1SccT_Int32_Init;
    --set hour 
    val.hour := TASTE_BasicTypes.asn1SccT_Int32_Init;
    --set minute 
    val.minute := TASTE_BasicTypes.asn1SccT_Int32_Init;
    --set second 
    val.second := TASTE_BasicTypes.asn1SccT_Int32_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccDate_Time_Init;

function asn1SccDate_Time_IsConstraintValid(val : asn1SccDate_Time) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := TASTE_BasicTypes.asn1SccT_Int32_IsConstraintValid(val.day);
    if ret.Success then
        ret := TASTE_BasicTypes.asn1SccT_Int32_IsConstraintValid(val.month);
        if ret.Success then
            ret := TASTE_BasicTypes.asn1SccT_Int32_IsConstraintValid(val.year);
            if ret.Success then
                ret := TASTE_BasicTypes.asn1SccT_Int32_IsConstraintValid(val.hour);
                if ret.Success then
                    ret := TASTE_BasicTypes.asn1SccT_Int32_IsConstraintValid(val.minute);
                    if ret.Success then
                        ret := TASTE_BasicTypes.asn1SccT_Int32_IsConstraintValid(val.second);
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccDate_Time_IsConstraintValid;



function asn1SccT_Int16_Equal (val1, val2 :  asn1SccT_Int16) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_Int16_Equal;

function asn1SccT_Int16_Init return asn1SccT_Int16
is
    val: asn1SccT_Int16;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Int16_Init;

function asn1SccT_Int16_IsConstraintValid(val : asn1SccT_Int16) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := ((-32768 <= val) AND (val <= 32767));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_INT16);
    return ret;
end asn1SccT_Int16_IsConstraintValid;



function asn1SccMGT_Raw_Data_Equal (val1, val2 :  asn1SccMGT_Raw_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.x_axis = val2.x_axis);

    if ret then
        ret := (val1.y_axis = val2.y_axis);

        if ret then
            ret := (val1.z_axis = val2.z_axis);

        end if;
    end if;
	return ret;

end asn1SccMGT_Raw_Data_Equal;

function asn1SccMGT_Raw_Data_Init return asn1SccMGT_Raw_Data
is
    val: asn1SccMGT_Raw_Data;
begin

    --set x_axis 
    val.x_axis := asn1SccT_Int16_Init;
    --set y_axis 
    val.y_axis := asn1SccT_Int16_Init;
    --set z_axis 
    val.z_axis := asn1SccT_Int16_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMGT_Raw_Data_Init;

function asn1SccMGT_Raw_Data_IsConstraintValid(val : asn1SccMGT_Raw_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccT_Int16_IsConstraintValid(val.x_axis);
    if ret.Success then
        ret := asn1SccT_Int16_IsConstraintValid(val.y_axis);
        if ret.Success then
            ret := asn1SccT_Int16_IsConstraintValid(val.z_axis);
        end if;
    end if;
    return ret;
end asn1SccMGT_Raw_Data_IsConstraintValid;



function asn1SccACC_Raw_Data_Equal (val1, val2 :  asn1SccACC_Raw_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.x_axis = val2.x_axis);

    if ret then
        ret := (val1.y_axis = val2.y_axis);

        if ret then
            ret := (val1.z_axis = val2.z_axis);

        end if;
    end if;
	return ret;

end asn1SccACC_Raw_Data_Equal;

function asn1SccACC_Raw_Data_Init return asn1SccACC_Raw_Data
is
    val: asn1SccACC_Raw_Data;
begin

    --set x_axis 
    val.x_axis := asn1SccT_Int16_Init;
    --set y_axis 
    val.y_axis := asn1SccT_Int16_Init;
    --set z_axis 
    val.z_axis := asn1SccT_Int16_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccACC_Raw_Data_Init;

function asn1SccACC_Raw_Data_IsConstraintValid(val : asn1SccACC_Raw_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccT_Int16_IsConstraintValid(val.x_axis);
    if ret.Success then
        ret := asn1SccT_Int16_IsConstraintValid(val.y_axis);
        if ret.Success then
            ret := asn1SccT_Int16_IsConstraintValid(val.z_axis);
        end if;
    end if;
    return ret;
end asn1SccACC_Raw_Data_IsConstraintValid;



function asn1SccGYRO_Raw_Data_Equal (val1, val2 :  asn1SccGYRO_Raw_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.x_axis = val2.x_axis);

    if ret then
        ret := (val1.y_axis = val2.y_axis);

        if ret then
            ret := (val1.z_axis = val2.z_axis);

        end if;
    end if;
	return ret;

end asn1SccGYRO_Raw_Data_Equal;

function asn1SccGYRO_Raw_Data_Init return asn1SccGYRO_Raw_Data
is
    val: asn1SccGYRO_Raw_Data;
begin

    --set x_axis 
    val.x_axis := asn1SccT_Int16_Init;
    --set y_axis 
    val.y_axis := asn1SccT_Int16_Init;
    --set z_axis 
    val.z_axis := asn1SccT_Int16_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccGYRO_Raw_Data_Init;

function asn1SccGYRO_Raw_Data_IsConstraintValid(val : asn1SccGYRO_Raw_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccT_Int16_IsConstraintValid(val.x_axis);
    if ret.Success then
        ret := asn1SccT_Int16_IsConstraintValid(val.y_axis);
        if ret.Success then
            ret := asn1SccT_Int16_IsConstraintValid(val.z_axis);
        end if;
    end if;
    return ret;
end asn1SccGYRO_Raw_Data_IsConstraintValid;



function asn1SccT_UInt16_Equal (val1, val2 :  asn1SccT_UInt16) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_UInt16_Equal;

function asn1SccT_UInt16_Init return asn1SccT_UInt16
is
    val: asn1SccT_UInt16;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UInt16_Init;

function asn1SccT_UInt16_IsConstraintValid(val : asn1SccT_UInt16) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 65535);
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_UINT16);
    return ret;
end asn1SccT_UInt16_IsConstraintValid;



function asn1SccT_UInt64_Equal (val1, val2 :  asn1SccT_UInt64) return Boolean
is

begin
	return val1 = val2;

end asn1SccT_UInt64_Equal;

function asn1SccT_UInt64_Init return asn1SccT_UInt64
is
    val: asn1SccT_UInt64;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_UInt64_Init;

function asn1SccT_UInt64_IsConstraintValid(val : asn1SccT_UInt64) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end asn1SccT_UInt64_IsConstraintValid;



function asn1SccT_Float_Equal (val1, val2 :  asn1SccT_Float) return Boolean
is

begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end asn1SccT_Float_Equal;

function asn1SccT_Float_Init return asn1SccT_Float
is
    val: asn1SccT_Float;
begin
    val := 0.00000000000000000000E+000;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Float_Init;

function asn1SccT_Float_IsConstraintValid(val : asn1SccT_Float) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := ((-3.40000000000000000000E+038 <= val) AND (val <= 3.40000000000000000000E+038));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_FLOAT);
    return ret;
end asn1SccT_Float_IsConstraintValid;



function asn1SccMGT_MilliGauss_Data_Equal (val1, val2 :  asn1SccMGT_MilliGauss_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.x_axis, val2.x_axis));

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.y_axis, val2.y_axis));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.z_axis, val2.z_axis));

        end if;
    end if;
	return ret;

end asn1SccMGT_MilliGauss_Data_Equal;

function asn1SccMGT_MilliGauss_Data_Init return asn1SccMGT_MilliGauss_Data
is
    val: asn1SccMGT_MilliGauss_Data;
begin

    --set x_axis 
    val.x_axis := asn1SccT_Float_Init;
    --set y_axis 
    val.y_axis := asn1SccT_Float_Init;
    --set z_axis 
    val.z_axis := asn1SccT_Float_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccMGT_MilliGauss_Data_Init;

function asn1SccMGT_MilliGauss_Data_IsConstraintValid(val : asn1SccMGT_MilliGauss_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccT_Float_IsConstraintValid(val.x_axis);
    if ret.Success then
        ret := asn1SccT_Float_IsConstraintValid(val.y_axis);
        if ret.Success then
            ret := asn1SccT_Float_IsConstraintValid(val.z_axis);
        end if;
    end if;
    return ret;
end asn1SccMGT_MilliGauss_Data_IsConstraintValid;



function asn1SccACC_MilliG_Data_Equal (val1, val2 :  asn1SccACC_MilliG_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.x_axis, val2.x_axis));

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.y_axis, val2.y_axis));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.z_axis, val2.z_axis));

        end if;
    end if;
	return ret;

end asn1SccACC_MilliG_Data_Equal;

function asn1SccACC_MilliG_Data_Init return asn1SccACC_MilliG_Data
is
    val: asn1SccACC_MilliG_Data;
begin

    --set x_axis 
    val.x_axis := asn1SccT_Float_Init;
    --set y_axis 
    val.y_axis := asn1SccT_Float_Init;
    --set z_axis 
    val.z_axis := asn1SccT_Float_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccACC_MilliG_Data_Init;

function asn1SccACC_MilliG_Data_IsConstraintValid(val : asn1SccACC_MilliG_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccT_Float_IsConstraintValid(val.x_axis);
    if ret.Success then
        ret := asn1SccT_Float_IsConstraintValid(val.y_axis);
        if ret.Success then
            ret := asn1SccT_Float_IsConstraintValid(val.z_axis);
        end if;
    end if;
    return ret;
end asn1SccACC_MilliG_Data_IsConstraintValid;



function asn1SccGYRO_MilliDPS_Data_Equal (val1, val2 :  asn1SccGYRO_MilliDPS_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.x_axis, val2.x_axis));

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.y_axis, val2.y_axis));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.z_axis, val2.z_axis));

        end if;
    end if;
	return ret;

end asn1SccGYRO_MilliDPS_Data_Equal;

function asn1SccGYRO_MilliDPS_Data_Init return asn1SccGYRO_MilliDPS_Data
is
    val: asn1SccGYRO_MilliDPS_Data;
begin

    --set x_axis 
    val.x_axis := asn1SccT_Float_Init;
    --set y_axis 
    val.y_axis := asn1SccT_Float_Init;
    --set z_axis 
    val.z_axis := asn1SccT_Float_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccGYRO_MilliDPS_Data_Init;

function asn1SccGYRO_MilliDPS_Data_IsConstraintValid(val : asn1SccGYRO_MilliDPS_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccT_Float_IsConstraintValid(val.x_axis);
    if ret.Success then
        ret := asn1SccT_Float_IsConstraintValid(val.y_axis);
        if ret.Success then
            ret := asn1SccT_Float_IsConstraintValid(val.z_axis);
        end if;
    end if;
    return ret;
end asn1SccGYRO_MilliDPS_Data_IsConstraintValid;



function asn1SccPT1000s_Raw_Data_elem_Equal (val1, val2 :  asn1SccPT1000s_Raw_Data_elem) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.vcc_volts, val2.vcc_volts));

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.pt1000, val2.pt1000));

    end if;
	return ret;

end asn1SccPT1000s_Raw_Data_elem_Equal;

function asn1SccPT1000s_Raw_Data_Equal (val1, val2 :  asn1SccPT1000s_Raw_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 7 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := asn1SccPT1000s_Raw_Data_elem_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccPT1000s_Raw_Data_Equal;

function asn1SccPT1000s_Raw_Data_elem_Init return asn1SccPT1000s_Raw_Data_elem
is
    val: asn1SccPT1000s_Raw_Data_elem;
begin

    --set vcc_volts 
    val.vcc_volts := asn1SccT_Float_Init;
    --set pt1000 
    val.pt1000 := asn1SccT_Float_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPT1000s_Raw_Data_elem_Init;
function asn1SccPT1000s_Raw_Data_Init return asn1SccPT1000s_Raw_Data
is
    val: asn1SccPT1000s_Raw_Data;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 7 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=7);
        val.Data(i1) := asn1SccPT1000s_Raw_Data_elem_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPT1000s_Raw_Data_Init;

function asn1SccPT1000s_Raw_Data_IsConstraintValid(val : asn1SccPT1000s_Raw_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    i1 := val.Data'First;
    while ret.Success and i1 <= 7 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 7);
        ret := asn1SccT_Float_IsConstraintValid(val.Data(i1).vcc_volts);
        if ret.Success then
            ret := asn1SccT_Float_IsConstraintValid(val.Data(i1).pt1000);
        end if;
        i1 := i1+1;
    end loop;
    return ret;
end asn1SccPT1000s_Raw_Data_IsConstraintValid;



function asn1SccPT1000s_Celsius_Data_Equal (val1, val2 :  asn1SccPT1000s_Celsius_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 7 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (adaasn1rtl.Asn1Real_Equal(val1.Data(i1), val2.Data(i1)));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccPT1000s_Celsius_Data_Equal;

function asn1SccPT1000s_Celsius_Data_Init return asn1SccPT1000s_Celsius_Data
is
    val: asn1SccPT1000s_Celsius_Data;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 7 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=7);
        val.Data(i1) := asn1SccT_Float_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPT1000s_Celsius_Data_Init;

function asn1SccPT1000s_Celsius_Data_IsConstraintValid(val : asn1SccPT1000s_Celsius_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    i1 := val.Data'First;
    while ret.Success and i1 <= 7 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 7);
        ret := asn1SccT_Float_IsConstraintValid(val.Data(i1));
        i1 := i1+1;
    end loop;
    return ret;
end asn1SccPT1000s_Celsius_Data_IsConstraintValid;



function asn1SccPS_Calibration_Data_Equal (val1, val2 :  asn1SccPS_Calibration_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.c1 = val2.c1);

    if ret then
        ret := (val1.c2 = val2.c2);

        if ret then
            ret := (val1.c3 = val2.c3);

            if ret then
                ret := (val1.c4 = val2.c4);

                if ret then
                    ret := (val1.c5 = val2.c5);

                    if ret then
                        ret := (val1.c6 = val2.c6);

                        if ret then
                            ret := (adaasn1rtl.Asn1Real_Equal(val1.sens_t1, val2.sens_t1));

                            if ret then
                                ret := (adaasn1rtl.Asn1Real_Equal(val1.off_t1, val2.off_t1));

                                if ret then
                                    ret := (adaasn1rtl.Asn1Real_Equal(val1.tcs, val2.tcs));

                                    if ret then
                                        ret := (adaasn1rtl.Asn1Real_Equal(val1.tco, val2.tco));

                                        if ret then
                                            ret := (adaasn1rtl.Asn1Real_Equal(val1.tref, val2.tref));

                                            if ret then
                                                ret := (adaasn1rtl.Asn1Real_Equal(val1.temp_sens, val2.temp_sens));

                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccPS_Calibration_Data_Equal;

function asn1SccPS_Calibration_Data_Init return asn1SccPS_Calibration_Data
is
    val: asn1SccPS_Calibration_Data;
begin

    --set c1 
    val.c1 := asn1SccT_UInt16_Init;
    --set c2 
    val.c2 := asn1SccT_UInt16_Init;
    --set c3 
    val.c3 := asn1SccT_UInt16_Init;
    --set c4 
    val.c4 := asn1SccT_UInt16_Init;
    --set c5 
    val.c5 := asn1SccT_UInt16_Init;
    --set c6 
    val.c6 := asn1SccT_UInt16_Init;
    --set sens_t1 
    val.sens_t1 := asn1SccT_Float_Init;
    --set off_t1 
    val.off_t1 := asn1SccT_Float_Init;
    --set tcs 
    val.tcs := asn1SccT_Float_Init;
    --set tco 
    val.tco := asn1SccT_Float_Init;
    --set tref 
    val.tref := asn1SccT_Float_Init;
    --set temp_sens 
    val.temp_sens := asn1SccT_Float_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPS_Calibration_Data_Init;

function asn1SccPS_Calibration_Data_IsConstraintValid(val : asn1SccPS_Calibration_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccT_UInt16_IsConstraintValid(val.c1);
    if ret.Success then
        ret := asn1SccT_UInt16_IsConstraintValid(val.c2);
        if ret.Success then
            ret := asn1SccT_UInt16_IsConstraintValid(val.c3);
            if ret.Success then
                ret := asn1SccT_UInt16_IsConstraintValid(val.c4);
                if ret.Success then
                    ret := asn1SccT_UInt16_IsConstraintValid(val.c5);
                    if ret.Success then
                        ret := asn1SccT_UInt16_IsConstraintValid(val.c6);
                        if ret.Success then
                            ret := asn1SccT_Float_IsConstraintValid(val.sens_t1);
                            if ret.Success then
                                ret := asn1SccT_Float_IsConstraintValid(val.off_t1);
                                if ret.Success then
                                    ret := asn1SccT_Float_IsConstraintValid(val.tcs);
                                    if ret.Success then
                                        ret := asn1SccT_Float_IsConstraintValid(val.tco);
                                        if ret.Success then
                                            ret := asn1SccT_Float_IsConstraintValid(val.tref);
                                            if ret.Success then
                                                ret := asn1SccT_Float_IsConstraintValid(val.temp_sens);
                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccPS_Calibration_Data_IsConstraintValid;



function asn1SccTC_Heater_heater_Equal (val1, val2 :  asn1SccTC_Heater_heater) return Boolean
is

begin
	return val1 = val2;

end asn1SccTC_Heater_heater_Equal;

function asn1SccTC_Heater_command_max_min_Equal (val1, val2 :  asn1SccTC_Heater_command_max_min) return Boolean
is

begin
	return val1 = val2;

end asn1SccTC_Heater_command_max_min_Equal;

function asn1SccTC_Heater_command_Equal (val1, val2 :  asn1SccTC_Heater_command) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when power_manual_PRESENT =>
                ret := (adaasn1rtl.Asn1Real_Equal(val1.power_manual, val2.power_manual));
            when max_min_PRESENT =>
                ret := asn1SccTC_Heater_command_max_min_Equal(val1.max_min, val2.max_min);
        end case;
    end if;
	return ret;

end asn1SccTC_Heater_command_Equal;

function asn1SccTC_Heater_Equal (val1, val2 :  asn1SccTC_Heater) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccTC_Heater_heater_Equal(val1.heater, val2.heater);

    if ret then
        ret := asn1SccTC_Heater_command_Equal(val1.command, val2.command);

    end if;
	return ret;

end asn1SccTC_Heater_Equal;

function asn1SccTC_Heater_heater_Init return asn1SccTC_Heater_heater
is
    val: asn1SccTC_Heater_heater;
begin
    val := asn1Sccheater_HTL;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_Heater_heater_Init;
function asn1SccTC_Heater_command_max_min_Init return asn1SccTC_Heater_command_max_min
is
    val: asn1SccTC_Heater_command_max_min;
begin
    val := asn1Sccmax;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_Heater_command_max_min_Init;
function asn1SccTC_Heater_command_Init return asn1SccTC_Heater_command
is
    val: asn1SccTC_Heater_command;
begin
    --set power_manual 
    declare
        power_manual_tmp:asn1SccT_Float;
    begin
        power_manual_tmp := asn1SccT_Float_Init;
    	pragma Warnings (Off, "object ""power_manual_tmp"" is always False at this point");
        val := asn1SccTC_Heater_command'(kind => power_manual_PRESENT, power_manual => power_manual_tmp);
    	pragma Warnings (On, "object ""power_manual_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_Heater_command_Init;
function asn1SccTC_Heater_Init return asn1SccTC_Heater
is
    val: asn1SccTC_Heater;
begin

    --set heater 
    val.heater := asn1SccTC_Heater_heater_Init;
    --set command 
    val.command := asn1SccTC_Heater_command_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_Heater_Init;

function asn1SccTC_Heater_IsConstraintValid(val : asn1SccTC_Heater) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val.heater = asn1Sccheater_HTL)) OR ((val.heater = asn1Sccheater_anemo)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_TC_HEATER_HEATER);
    if ret.Success then
        if val.command.kind = power_manual_PRESENT then
        	ret := asn1SccT_Float_IsConstraintValid(val.command.power_manual);
        end if;
        if ret.Success then
            if val.command.kind = max_min_PRESENT then
            	ret.Success := (((val.command.max_min = asn1Sccmax)) OR ((val.command.max_min = asn1Sccmin)));
            	ret.ErrorCode := (if ret.Success then 0 else ERR_TC_HEATER_COMMAND_MAX_MIN);
            end if;
        end if;
    end if;
    return ret;
end asn1SccTC_Heater_IsConstraintValid;



function asn1SccT_Double_Equal (val1, val2 :  asn1SccT_Double) return Boolean
is

begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end asn1SccT_Double_Equal;

function asn1SccT_Double_Init return asn1SccT_Double
is
    val: asn1SccT_Double;
begin
    val := 0.00000000000000000000E+000;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccT_Double_Init;

function asn1SccT_Double_IsConstraintValid(val : asn1SccT_Double) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := ((-1.69999999999999990000E+308 <= val) AND (val <= 1.69999999999999990000E+308));
    ret.ErrorCode := (if ret.Success then 0 else ERR_T_DOUBLE);
    return ret;
end asn1SccT_Double_IsConstraintValid;



function asn1SccGPS_PVT_mode_Equal (val1, val2 :  asn1SccGPS_PVT_mode) return Boolean
is

begin
	return val1 = val2;

end asn1SccGPS_PVT_mode_Equal;

function asn1SccGPS_PVT_Equal (val1, val2 :  asn1SccGPS_PVT) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccGPS_PVT_mode_Equal(val1.mode, val2.mode);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.date_and_time, val2.date_and_time));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.ept, val2.ept));

            if ret then
                ret := (adaasn1rtl.Asn1Real_Equal(val1.latitude, val2.latitude));

                if ret then
                    ret := (adaasn1rtl.Asn1Real_Equal(val1.epy, val2.epy));

                    if ret then
                        ret := (adaasn1rtl.Asn1Real_Equal(val1.longitude, val2.longitude));

                        if ret then
                            ret := (adaasn1rtl.Asn1Real_Equal(val1.epx, val2.epx));

                            if ret then
                                ret := (adaasn1rtl.Asn1Real_Equal(val1.altitude, val2.altitude));

                                if ret then
                                    ret := (adaasn1rtl.Asn1Real_Equal(val1.epv, val2.epv));

                                    if ret then
                                        ret := (adaasn1rtl.Asn1Real_Equal(val1.course, val2.course));

                                        if ret then
                                            ret := (adaasn1rtl.Asn1Real_Equal(val1.epd, val2.epd));

                                            if ret then
                                                ret := (adaasn1rtl.Asn1Real_Equal(val1.speed, val2.speed));

                                                if ret then
                                                    ret := (adaasn1rtl.Asn1Real_Equal(val1.eps, val2.eps));

                                                    if ret then
                                                        ret := (adaasn1rtl.Asn1Real_Equal(val1.climb, val2.climb));

                                                        if ret then
                                                            ret := (adaasn1rtl.Asn1Real_Equal(val1.epc, val2.epc));

                                                        end if;
                                                    end if;
                                                end if;
                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccGPS_PVT_Equal;

function asn1SccGPS_PVT_mode_Init return asn1SccGPS_PVT_mode
is
    val: asn1SccGPS_PVT_mode;
begin
    val := asn1Sccnot_seen;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccGPS_PVT_mode_Init;
function asn1SccGPS_PVT_Init return asn1SccGPS_PVT
is
    val: asn1SccGPS_PVT;
begin

    --set mode 
    val.mode := asn1SccGPS_PVT_mode_Init;
    --set date_and_time 
    val.date_and_time := asn1SccT_Double_Init;
    --set ept 
    val.ept := asn1SccT_Double_Init;
    --set latitude 
    val.latitude := asn1SccT_Double_Init;
    --set epy 
    val.epy := asn1SccT_Double_Init;
    --set longitude 
    val.longitude := asn1SccT_Double_Init;
    --set epx 
    val.epx := asn1SccT_Double_Init;
    --set altitude 
    val.altitude := asn1SccT_Double_Init;
    --set epv 
    val.epv := asn1SccT_Double_Init;
    --set course 
    val.course := asn1SccT_Double_Init;
    --set epd 
    val.epd := asn1SccT_Double_Init;
    --set speed 
    val.speed := asn1SccT_Double_Init;
    --set eps 
    val.eps := asn1SccT_Double_Init;
    --set climb 
    val.climb := asn1SccT_Double_Init;
    --set epc 
    val.epc := asn1SccT_Double_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccGPS_PVT_Init;

function asn1SccGPS_PVT_IsConstraintValid(val : asn1SccGPS_PVT) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((((val.mode = asn1Sccnot_seen)) OR ((val.mode = asn1Sccno_fix)))) OR ((val.mode = asn1Scctwo_dims)))) OR ((val.mode = asn1Sccthree_dims)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_GPS_PVT_MODE);
    if ret.Success then
        ret := asn1SccT_Double_IsConstraintValid(val.date_and_time);
        if ret.Success then
            ret := asn1SccT_Double_IsConstraintValid(val.ept);
            if ret.Success then
                ret := asn1SccT_Double_IsConstraintValid(val.latitude);
                if ret.Success then
                    ret := asn1SccT_Double_IsConstraintValid(val.epy);
                    if ret.Success then
                        ret := asn1SccT_Double_IsConstraintValid(val.longitude);
                        if ret.Success then
                            ret := asn1SccT_Double_IsConstraintValid(val.epx);
                            if ret.Success then
                                ret := asn1SccT_Double_IsConstraintValid(val.altitude);
                                if ret.Success then
                                    ret := asn1SccT_Double_IsConstraintValid(val.epv);
                                    if ret.Success then
                                        ret := asn1SccT_Double_IsConstraintValid(val.course);
                                        if ret.Success then
                                            ret := asn1SccT_Double_IsConstraintValid(val.epd);
                                            if ret.Success then
                                                ret := asn1SccT_Double_IsConstraintValid(val.speed);
                                                if ret.Success then
                                                    ret := asn1SccT_Double_IsConstraintValid(val.eps);
                                                    if ret.Success then
                                                        ret := asn1SccT_Double_IsConstraintValid(val.climb);
                                                        if ret.Success then
                                                            ret := asn1SccT_Double_IsConstraintValid(val.epc);
                                                        end if;
                                                    end if;
                                                end if;
                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccGPS_PVT_IsConstraintValid;



function asn1SccFile_Name_Equal (val1, val2 :  asn1SccFile_Name) return Boolean
is

begin
	return val1.Data = val2.Data;

end asn1SccFile_Name_Equal;

function asn1SccFile_Name_Init return asn1SccFile_Name
is
    val: asn1SccFile_Name;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 81 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=81);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccFile_Name_Init;

function asn1SccFile_Name_IsConstraintValid(val : asn1SccFile_Name) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end asn1SccFile_Name_IsConstraintValid;



function asn1SccContent_Validity_Equal (val1, val2 :  asn1SccContent_Validity) return Boolean
is

begin
	return val1 = val2;

end asn1SccContent_Validity_Equal;

function asn1SccContent_Validity_Init return asn1SccContent_Validity
is
    val: asn1SccContent_Validity;
begin
    val := asn1Sccvalid;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccContent_Validity_Init;

function asn1SccContent_Validity_IsConstraintValid(val : asn1SccContent_Validity) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccvalid)) OR ((val = asn1Sccinvalid)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_CONTENT_VALIDITY);
    return ret;
end asn1SccContent_Validity_IsConstraintValid;



function asn1SccIMU_All_Data_Equal (val1, val2 :  asn1SccIMU_All_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccMGT_Raw_Data_Equal(val1.mgt_raw, val2.mgt_raw);

    if ret then
        ret := asn1SccMGT_MilliGauss_Data_Equal(val1.mgt_mgauss, val2.mgt_mgauss);

        if ret then
            ret := asn1SccACC_Raw_Data_Equal(val1.accel_raw, val2.accel_raw);

            if ret then
                ret := asn1SccACC_MilliG_Data_Equal(val1.accel_mg, val2.accel_mg);

                if ret then
                    ret := asn1SccGYRO_Raw_Data_Equal(val1.gyro_raw, val2.gyro_raw);

                    if ret then
                        ret := asn1SccGYRO_MilliDPS_Data_Equal(val1.gyro_mdps, val2.gyro_mdps);

                        if ret then
                            ret := (val1.temp_raw = val2.temp_raw);

                            if ret then
                                ret := (adaasn1rtl.Asn1Real_Equal(val1.temp_celsius, val2.temp_celsius));

                                if ret then
                                    ret := (val1.mgt_valid = val2.mgt_valid);

                                    if ret then
                                        ret := (val1.acc_valid = val2.acc_valid);

                                        if ret then
                                            ret := (val1.gyro_valid = val2.gyro_valid);

                                            if ret then
                                                ret := (val1.temp_valid = val2.temp_valid);

                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccIMU_All_Data_Equal;

function asn1SccIMU_All_Data_Init return asn1SccIMU_All_Data
is
    val: asn1SccIMU_All_Data;
begin

    --set mgt_raw 
    val.mgt_raw := asn1SccMGT_Raw_Data_Init;
    --set mgt_mgauss 
    val.mgt_mgauss := asn1SccMGT_MilliGauss_Data_Init;
    --set accel_raw 
    val.accel_raw := asn1SccACC_Raw_Data_Init;
    --set accel_mg 
    val.accel_mg := asn1SccACC_MilliG_Data_Init;
    --set gyro_raw 
    val.gyro_raw := asn1SccGYRO_Raw_Data_Init;
    --set gyro_mdps 
    val.gyro_mdps := asn1SccGYRO_MilliDPS_Data_Init;
    --set temp_raw 
    val.temp_raw := asn1SccT_Int16_Init;
    --set temp_celsius 
    val.temp_celsius := asn1SccT_Float_Init;
    --set mgt_valid 
    val.mgt_valid := asn1SccContent_Validity_Init;
    --set acc_valid 
    val.acc_valid := asn1SccContent_Validity_Init;
    --set gyro_valid 
    val.gyro_valid := asn1SccContent_Validity_Init;
    --set temp_valid 
    val.temp_valid := asn1SccContent_Validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccIMU_All_Data_Init;

function asn1SccIMU_All_Data_IsConstraintValid(val : asn1SccIMU_All_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccMGT_Raw_Data_IsConstraintValid(val.mgt_raw);
    if ret.Success then
        ret := asn1SccMGT_MilliGauss_Data_IsConstraintValid(val.mgt_mgauss);
        if ret.Success then
            ret := asn1SccACC_Raw_Data_IsConstraintValid(val.accel_raw);
            if ret.Success then
                ret := asn1SccACC_MilliG_Data_IsConstraintValid(val.accel_mg);
                if ret.Success then
                    ret := asn1SccGYRO_Raw_Data_IsConstraintValid(val.gyro_raw);
                    if ret.Success then
                        ret := asn1SccGYRO_MilliDPS_Data_IsConstraintValid(val.gyro_mdps);
                        if ret.Success then
                            ret := asn1SccT_Int16_IsConstraintValid(val.temp_raw);
                            if ret.Success then
                                ret := asn1SccT_Float_IsConstraintValid(val.temp_celsius);
                                if ret.Success then
                                    ret := asn1SccContent_Validity_IsConstraintValid(val.mgt_valid);
                                    if ret.Success then
                                        ret := asn1SccContent_Validity_IsConstraintValid(val.acc_valid);
                                        if ret.Success then
                                            ret := asn1SccContent_Validity_IsConstraintValid(val.gyro_valid);
                                            if ret.Success then
                                                ret := asn1SccContent_Validity_IsConstraintValid(val.temp_valid);
                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccIMU_All_Data_IsConstraintValid;



function asn1SccTC74s_All_Data_elem_Equal (val1, val2 :  asn1SccTC74s_All_Data_elem) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.temperature, val2.temperature));

    if ret then
        ret := (val1.validity = val2.validity);

    end if;
	return ret;

end asn1SccTC74s_All_Data_elem_Equal;

function asn1SccTC74s_All_Data_Equal (val1, val2 :  asn1SccTC74s_All_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 5 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := asn1SccTC74s_All_Data_elem_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccTC74s_All_Data_Equal;

function asn1SccTC74s_All_Data_elem_Init return asn1SccTC74s_All_Data_elem
is
    val: asn1SccTC74s_All_Data_elem;
begin

    --set temperature 
    val.temperature := asn1SccT_Float_Init;
    --set validity 
    val.validity := asn1SccContent_Validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC74s_All_Data_elem_Init;
function asn1SccTC74s_All_Data_Init return asn1SccTC74s_All_Data
is
    val: asn1SccTC74s_All_Data;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 5 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=5);
        val.Data(i1) := asn1SccTC74s_All_Data_elem_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC74s_All_Data_Init;

function asn1SccTC74s_All_Data_IsConstraintValid(val : asn1SccTC74s_All_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    i1 := val.Data'First;
    while ret.Success and i1 <= 5 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 5);
        ret := asn1SccT_Float_IsConstraintValid(val.Data(i1).temperature);
        if ret.Success then
            ret := asn1SccContent_Validity_IsConstraintValid(val.Data(i1).validity);
        end if;
        i1 := i1+1;
    end loop;
    return ret;
end asn1SccTC74s_All_Data_IsConstraintValid;



function asn1SccPT1000s_All_Data_validity_Equal (val1, val2 :  asn1SccPT1000s_All_Data_validity) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 7 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccPT1000s_All_Data_validity_Equal;

function asn1SccPT1000s_All_Data_Equal (val1, val2 :  asn1SccPT1000s_All_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccPT1000s_Raw_Data_Equal(val1.raw, val2.raw);

    if ret then
        ret := asn1SccPT1000s_Celsius_Data_Equal(val1.celsius, val2.celsius);

        if ret then
            ret := asn1SccPT1000s_All_Data_validity_Equal(val1.validity, val2.validity);

        end if;
    end if;
	return ret;

end asn1SccPT1000s_All_Data_Equal;

function asn1SccPT1000s_All_Data_validity_Init return asn1SccPT1000s_All_Data_validity
is
    val: asn1SccPT1000s_All_Data_validity;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 7 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=7);
        val.Data(i1) := asn1SccContent_Validity_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPT1000s_All_Data_validity_Init;
function asn1SccPT1000s_All_Data_Init return asn1SccPT1000s_All_Data
is
    val: asn1SccPT1000s_All_Data;
begin

    --set raw 
    val.raw := asn1SccPT1000s_Raw_Data_Init;
    --set celsius 
    val.celsius := asn1SccPT1000s_Celsius_Data_Init;
    --set validity 
    val.validity := asn1SccPT1000s_All_Data_validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPT1000s_All_Data_Init;

function asn1SccPT1000s_All_Data_IsConstraintValid(val : asn1SccPT1000s_All_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    ret := asn1SccPT1000s_Raw_Data_IsConstraintValid(val.raw);
    if ret.Success then
        ret := asn1SccPT1000s_Celsius_Data_IsConstraintValid(val.celsius);
        if ret.Success then
            i1 := val.validity.Data'First;
            while ret.Success and i1 <= 7 loop
                pragma Loop_Invariant (i1 >= val.validity.Data'First and i1 <= 7);
                ret := asn1SccContent_Validity_IsConstraintValid(val.validity.Data(i1));
                i1 := i1+1;
            end loop;
        end if;
    end if;
    return ret;
end asn1SccPT1000s_All_Data_IsConstraintValid;



function asn1SccPS_All_Data_Equal (val1, val2 :  asn1SccPS_All_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.Exist.calib = val2.Exist.calib;
    if ret and then val1.Exist.calib = 1 then
        ret := asn1SccPS_Calibration_Data_Equal(val1.calib, val2.calib);
    end if;

    if ret then
        ret := asn1SccPS_Raw_Data_Equal(val1.raw, val2.raw);

        if ret then
            ret := asn1SccPS_Processed_Data_Equal(val1.processed, val2.processed);

            if ret then
                ret := (val1.validity = val2.validity);

            end if;
        end if;
    end if;
	return ret;

end asn1SccPS_All_Data_Equal;

function asn1SccPS_All_Data_Init return asn1SccPS_All_Data
is
    val: asn1SccPS_All_Data;
begin

    --set calib 
    val.exist.calib := 1;
    val.calib := asn1SccPS_Calibration_Data_Init;
    --set raw 
    val.raw := asn1SccPS_Raw_Data_Init;
    --set processed 
    val.processed := asn1SccPS_Processed_Data_Init;
    --set validity 
    val.validity := asn1SccContent_Validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPS_All_Data_Init;

function asn1SccPS_All_Data_IsConstraintValid(val : asn1SccPS_All_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    if val.Exist.calib = 1 then
        ret := asn1SccPS_Calibration_Data_IsConstraintValid(val.calib);
    end if;
    if ret.Success then
        ret := asn1SccPS_Raw_Data_IsConstraintValid(val.raw);
        if ret.Success then
            ret := asn1SccPS_Processed_Data_IsConstraintValid(val.processed);
            if ret.Success then
                ret := asn1SccContent_Validity_IsConstraintValid(val.validity);
            end if;
        end if;
    end if;
    return ret;
end asn1SccPS_All_Data_IsConstraintValid;



function asn1SccHeater_Data_Equal (val1, val2 :  asn1SccHeater_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.power_watts, val2.power_watts));

    if ret then
        ret := (val1.validity = val2.validity);

    end if;
	return ret;

end asn1SccHeater_Data_Equal;

function asn1SccHeater_Data_Init return asn1SccHeater_Data
is
    val: asn1SccHeater_Data;
begin

    --set power_watts 
    val.power_watts := asn1SccT_Float_Init;
    --set validity 
    val.validity := asn1SccContent_Validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHeater_Data_Init;

function asn1SccHeater_Data_IsConstraintValid(val : asn1SccHeater_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccT_Float_IsConstraintValid(val.power_watts);
    if ret.Success then
        ret := asn1SccContent_Validity_IsConstraintValid(val.validity);
    end if;
    return ret;
end asn1SccHeater_Data_IsConstraintValid;



function asn1SccOBSW_DP_Data_gps_Equal (val1, val2 :  asn1SccOBSW_DP_Data_gps) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccGPS_PVT_Equal(val1.data, val2.data);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.gps_time, val2.gps_time));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.mission_time, val2.mission_time));

        end if;
    end if;
	return ret;

end asn1SccOBSW_DP_Data_gps_Equal;

function asn1SccOBSW_DP_Data_imu_Equal (val1, val2 :  asn1SccOBSW_DP_Data_imu) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccIMU_All_Data_Equal(val1.data, val2.data);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.gps_time, val2.gps_time));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.mission_time, val2.mission_time));

        end if;
    end if;
	return ret;

end asn1SccOBSW_DP_Data_imu_Equal;

function asn1SccOBSW_DP_Data_tc74s_Equal (val1, val2 :  asn1SccOBSW_DP_Data_tc74s) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccTC74s_All_Data_Equal(val1.data, val2.data);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.gps_time, val2.gps_time));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.mission_time, val2.mission_time));

        end if;
    end if;
	return ret;

end asn1SccOBSW_DP_Data_tc74s_Equal;

function asn1SccOBSW_DP_Data_pt1000s_Equal (val1, val2 :  asn1SccOBSW_DP_Data_pt1000s) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccPT1000s_All_Data_Equal(val1.data, val2.data);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.gps_time, val2.gps_time));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.mission_time, val2.mission_time));

        end if;
    end if;
	return ret;

end asn1SccOBSW_DP_Data_pt1000s_Equal;

function asn1SccOBSW_DP_Data_ps1_Equal (val1, val2 :  asn1SccOBSW_DP_Data_ps1) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccPS_All_Data_Equal(val1.data, val2.data);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.gps_time, val2.gps_time));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.mission_time, val2.mission_time));

        end if;
    end if;
	return ret;

end asn1SccOBSW_DP_Data_ps1_Equal;

function asn1SccOBSW_DP_Data_ps2_Equal (val1, val2 :  asn1SccOBSW_DP_Data_ps2) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccPS_All_Data_Equal(val1.data, val2.data);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.gps_time, val2.gps_time));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.mission_time, val2.mission_time));

        end if;
    end if;
	return ret;

end asn1SccOBSW_DP_Data_ps2_Equal;

function asn1SccOBSW_DP_Data_heater1_Equal (val1, val2 :  asn1SccOBSW_DP_Data_heater1) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccHeater_Data_Equal(val1.data, val2.data);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.gps_time, val2.gps_time));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.mission_time, val2.mission_time));

        end if;
    end if;
	return ret;

end asn1SccOBSW_DP_Data_heater1_Equal;

function asn1SccOBSW_DP_Data_heater2_Equal (val1, val2 :  asn1SccOBSW_DP_Data_heater2) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccHeater_Data_Equal(val1.data, val2.data);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.gps_time, val2.gps_time));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.mission_time, val2.mission_time));

        end if;
    end if;
	return ret;

end asn1SccOBSW_DP_Data_heater2_Equal;

function asn1SccOBSW_DP_Data_anemometer_Equal (val1, val2 :  asn1SccOBSW_DP_Data_anemometer) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.data = val2.data);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.gps_time, val2.gps_time));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.mission_time, val2.mission_time));

        end if;
    end if;
	return ret;

end asn1SccOBSW_DP_Data_anemometer_Equal;

function asn1SccOBSW_DP_Data_Equal (val1, val2 :  asn1SccOBSW_DP_Data) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := val1.Exist.gps = val2.Exist.gps;
    if ret and then val1.Exist.gps = 1 then
        ret := asn1SccOBSW_DP_Data_gps_Equal(val1.gps, val2.gps);
    end if;

    if ret then
        ret := val1.Exist.imu = val2.Exist.imu;
        if ret and then val1.Exist.imu = 1 then
            ret := asn1SccOBSW_DP_Data_imu_Equal(val1.imu, val2.imu);
        end if;

        if ret then
            ret := val1.Exist.tc74s = val2.Exist.tc74s;
            if ret and then val1.Exist.tc74s = 1 then
                ret := asn1SccOBSW_DP_Data_tc74s_Equal(val1.tc74s, val2.tc74s);
            end if;

            if ret then
                ret := val1.Exist.pt1000s = val2.Exist.pt1000s;
                if ret and then val1.Exist.pt1000s = 1 then
                    ret := asn1SccOBSW_DP_Data_pt1000s_Equal(val1.pt1000s, val2.pt1000s);
                end if;

                if ret then
                    ret := val1.Exist.ps1 = val2.Exist.ps1;
                    if ret and then val1.Exist.ps1 = 1 then
                        ret := asn1SccOBSW_DP_Data_ps1_Equal(val1.ps1, val2.ps1);
                    end if;

                    if ret then
                        ret := val1.Exist.ps2 = val2.Exist.ps2;
                        if ret and then val1.Exist.ps2 = 1 then
                            ret := asn1SccOBSW_DP_Data_ps2_Equal(val1.ps2, val2.ps2);
                        end if;

                        if ret then
                            ret := val1.Exist.heater1 = val2.Exist.heater1;
                            if ret and then val1.Exist.heater1 = 1 then
                                ret := asn1SccOBSW_DP_Data_heater1_Equal(val1.heater1, val2.heater1);
                            end if;

                            if ret then
                                ret := val1.Exist.heater2 = val2.Exist.heater2;
                                if ret and then val1.Exist.heater2 = 1 then
                                    ret := asn1SccOBSW_DP_Data_heater2_Equal(val1.heater2, val2.heater2);
                                end if;

                                if ret then
                                    ret := val1.Exist.anemometer = val2.Exist.anemometer;
                                    if ret and then val1.Exist.anemometer = 1 then
                                        ret := asn1SccOBSW_DP_Data_anemometer_Equal(val1.anemometer, val2.anemometer);
                                    end if;

                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccOBSW_DP_Data_Equal;

function asn1SccOBSW_DP_Data_gps_Init return asn1SccOBSW_DP_Data_gps
is
    val: asn1SccOBSW_DP_Data_gps;
begin

    --set data 
    val.data := asn1SccGPS_PVT_Init;
    --set gps_time 
    val.gps_time := asn1SccT_Double_Init;
    --set mission_time 
    val.mission_time := asn1SccT_Double_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_Data_gps_Init;
function asn1SccOBSW_DP_Data_imu_Init return asn1SccOBSW_DP_Data_imu
is
    val: asn1SccOBSW_DP_Data_imu;
begin

    --set data 
    val.data := asn1SccIMU_All_Data_Init;
    --set gps_time 
    val.gps_time := asn1SccT_Double_Init;
    --set mission_time 
    val.mission_time := asn1SccT_Double_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_Data_imu_Init;
function asn1SccOBSW_DP_Data_tc74s_Init return asn1SccOBSW_DP_Data_tc74s
is
    val: asn1SccOBSW_DP_Data_tc74s;
begin

    --set data 
    val.data := asn1SccTC74s_All_Data_Init;
    --set gps_time 
    val.gps_time := asn1SccT_Double_Init;
    --set mission_time 
    val.mission_time := asn1SccT_Double_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_Data_tc74s_Init;
function asn1SccOBSW_DP_Data_pt1000s_Init return asn1SccOBSW_DP_Data_pt1000s
is
    val: asn1SccOBSW_DP_Data_pt1000s;
begin

    --set data 
    val.data := asn1SccPT1000s_All_Data_Init;
    --set gps_time 
    val.gps_time := asn1SccT_Double_Init;
    --set mission_time 
    val.mission_time := asn1SccT_Double_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_Data_pt1000s_Init;
function asn1SccOBSW_DP_Data_ps1_Init return asn1SccOBSW_DP_Data_ps1
is
    val: asn1SccOBSW_DP_Data_ps1;
begin

    --set data 
    val.data := asn1SccPS_All_Data_Init;
    --set gps_time 
    val.gps_time := asn1SccT_Double_Init;
    --set mission_time 
    val.mission_time := asn1SccT_Double_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_Data_ps1_Init;
function asn1SccOBSW_DP_Data_ps2_Init return asn1SccOBSW_DP_Data_ps2
is
    val: asn1SccOBSW_DP_Data_ps2;
begin

    --set data 
    val.data := asn1SccPS_All_Data_Init;
    --set gps_time 
    val.gps_time := asn1SccT_Double_Init;
    --set mission_time 
    val.mission_time := asn1SccT_Double_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_Data_ps2_Init;
function asn1SccOBSW_DP_Data_heater1_Init return asn1SccOBSW_DP_Data_heater1
is
    val: asn1SccOBSW_DP_Data_heater1;
begin

    --set data 
    val.data := asn1SccHeater_Data_Init;
    --set gps_time 
    val.gps_time := asn1SccT_Double_Init;
    --set mission_time 
    val.mission_time := asn1SccT_Double_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_Data_heater1_Init;
function asn1SccOBSW_DP_Data_heater2_Init return asn1SccOBSW_DP_Data_heater2
is
    val: asn1SccOBSW_DP_Data_heater2;
begin

    --set data 
    val.data := asn1SccHeater_Data_Init;
    --set gps_time 
    val.gps_time := asn1SccT_Double_Init;
    --set mission_time 
    val.mission_time := asn1SccT_Double_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_Data_heater2_Init;
function asn1SccOBSW_DP_Data_anemometer_Init return asn1SccOBSW_DP_Data_anemometer
is
    val: asn1SccOBSW_DP_Data_anemometer;
begin

    --set data 
    val.data := asn1SccT_UInt64_Init;
    --set gps_time 
    val.gps_time := asn1SccT_Double_Init;
    --set mission_time 
    val.mission_time := asn1SccT_Double_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_Data_anemometer_Init;
function asn1SccOBSW_DP_Data_Init return asn1SccOBSW_DP_Data
is
    val: asn1SccOBSW_DP_Data;
begin

    --set gps 
    val.exist.gps := 1;
    val.gps := asn1SccOBSW_DP_Data_gps_Init;
    --set imu 
    val.exist.imu := 1;
    val.imu := asn1SccOBSW_DP_Data_imu_Init;
    --set tc74s 
    val.exist.tc74s := 1;
    val.tc74s := asn1SccOBSW_DP_Data_tc74s_Init;
    --set pt1000s 
    val.exist.pt1000s := 1;
    val.pt1000s := asn1SccOBSW_DP_Data_pt1000s_Init;
    --set ps1 
    val.exist.ps1 := 1;
    val.ps1 := asn1SccOBSW_DP_Data_ps1_Init;
    --set ps2 
    val.exist.ps2 := 1;
    val.ps2 := asn1SccOBSW_DP_Data_ps2_Init;
    --set heater1 
    val.exist.heater1 := 1;
    val.heater1 := asn1SccOBSW_DP_Data_heater1_Init;
    --set heater2 
    val.exist.heater2 := 1;
    val.heater2 := asn1SccOBSW_DP_Data_heater2_Init;
    --set anemometer 
    val.exist.anemometer := 1;
    val.anemometer := asn1SccOBSW_DP_Data_anemometer_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccOBSW_DP_Data_Init;

function asn1SccOBSW_DP_Data_IsConstraintValid(val : asn1SccOBSW_DP_Data) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    if val.Exist.gps = 1 then
        ret := asn1SccGPS_PVT_IsConstraintValid(val.gps.data);
        if ret.Success then
            ret := asn1SccT_Double_IsConstraintValid(val.gps.gps_time);
            if ret.Success then
                ret := asn1SccT_Double_IsConstraintValid(val.gps.mission_time);
            end if;
        end if;
    end if;
    if ret.Success then
        if val.Exist.imu = 1 then
            ret := asn1SccIMU_All_Data_IsConstraintValid(val.imu.data);
            if ret.Success then
                ret := asn1SccT_Double_IsConstraintValid(val.imu.gps_time);
                if ret.Success then
                    ret := asn1SccT_Double_IsConstraintValid(val.imu.mission_time);
                end if;
            end if;
        end if;
        if ret.Success then
            if val.Exist.tc74s = 1 then
                ret := asn1SccTC74s_All_Data_IsConstraintValid(val.tc74s.data);
                if ret.Success then
                    ret := asn1SccT_Double_IsConstraintValid(val.tc74s.gps_time);
                    if ret.Success then
                        ret := asn1SccT_Double_IsConstraintValid(val.tc74s.mission_time);
                    end if;
                end if;
            end if;
            if ret.Success then
                if val.Exist.pt1000s = 1 then
                    ret := asn1SccPT1000s_All_Data_IsConstraintValid(val.pt1000s.data);
                    if ret.Success then
                        ret := asn1SccT_Double_IsConstraintValid(val.pt1000s.gps_time);
                        if ret.Success then
                            ret := asn1SccT_Double_IsConstraintValid(val.pt1000s.mission_time);
                        end if;
                    end if;
                end if;
                if ret.Success then
                    if val.Exist.ps1 = 1 then
                        ret := asn1SccPS_All_Data_IsConstraintValid(val.ps1.data);
                        if ret.Success then
                            ret := asn1SccT_Double_IsConstraintValid(val.ps1.gps_time);
                            if ret.Success then
                                ret := asn1SccT_Double_IsConstraintValid(val.ps1.mission_time);
                            end if;
                        end if;
                    end if;
                    if ret.Success then
                        if val.Exist.ps2 = 1 then
                            ret := asn1SccPS_All_Data_IsConstraintValid(val.ps2.data);
                            if ret.Success then
                                ret := asn1SccT_Double_IsConstraintValid(val.ps2.gps_time);
                                if ret.Success then
                                    ret := asn1SccT_Double_IsConstraintValid(val.ps2.mission_time);
                                end if;
                            end if;
                        end if;
                        if ret.Success then
                            if val.Exist.heater1 = 1 then
                                ret := asn1SccHeater_Data_IsConstraintValid(val.heater1.data);
                                if ret.Success then
                                    ret := asn1SccT_Double_IsConstraintValid(val.heater1.gps_time);
                                    if ret.Success then
                                        ret := asn1SccT_Double_IsConstraintValid(val.heater1.mission_time);
                                    end if;
                                end if;
                            end if;
                            if ret.Success then
                                if val.Exist.heater2 = 1 then
                                    ret := asn1SccHeater_Data_IsConstraintValid(val.heater2.data);
                                    if ret.Success then
                                        ret := asn1SccT_Double_IsConstraintValid(val.heater2.gps_time);
                                        if ret.Success then
                                            ret := asn1SccT_Double_IsConstraintValid(val.heater2.mission_time);
                                        end if;
                                    end if;
                                end if;
                                if ret.Success then
                                    if val.Exist.anemometer = 1 then
                                        ret := asn1SccT_UInt64_IsConstraintValid(val.anemometer.data);
                                        if ret.Success then
                                            ret := asn1SccT_Double_IsConstraintValid(val.anemometer.gps_time);
                                            if ret.Success then
                                                ret := asn1SccT_Double_IsConstraintValid(val.anemometer.mission_time);
                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccOBSW_DP_Data_IsConstraintValid;



function asn1SccTM_imu_Equal (val1, val2 :  asn1SccTM_imu) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccMGT_MilliGauss_Data_Equal(val1.mgt_mgauss, val2.mgt_mgauss);

    if ret then
        ret := asn1SccACC_MilliG_Data_Equal(val1.accel_mg, val2.accel_mg);

        if ret then
            ret := asn1SccGYRO_MilliDPS_Data_Equal(val1.gyro_mdps, val2.gyro_mdps);

            if ret then
                ret := (adaasn1rtl.Asn1Real_Equal(val1.temp_celsius, val2.temp_celsius));

                if ret then
                    ret := (val1.mgt_valid = val2.mgt_valid);

                    if ret then
                        ret := (val1.acc_valid = val2.acc_valid);

                        if ret then
                            ret := (val1.gyro_valid = val2.gyro_valid);

                            if ret then
                                ret := (val1.temp_valid = val2.temp_valid);

                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccTM_imu_Equal;

function asn1SccTM_Equal (val1, val2 :  asn1SccTM) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccHeater_Data_Equal(val1.heater1, val2.heater1);

    if ret then
        ret := asn1SccHeater_Data_Equal(val1.heater2, val2.heater2);

        if ret then
            ret := asn1SccTC74s_All_Data_Equal(val1.tc74s, val2.tc74s);

            if ret then
                ret := asn1SccPT1000s_All_Data_Equal(val1.pt1000s, val2.pt1000s);

                if ret then
                    ret := asn1SccGPS_PVT_Equal(val1.gps, val2.gps);

                    if ret then
                        ret := asn1SccTM_imu_Equal(val1.imu, val2.imu);

                        if ret then
                            ret := asn1SccPS_Processed_Data_Equal(val1.ps1, val2.ps1);

                            if ret then
                                ret := asn1SccPS_Processed_Data_Equal(val1.ps2, val2.ps2);

                                if ret then
                                    ret := (val1.ps1_validity = val2.ps1_validity);

                                    if ret then
                                        ret := (val1.ps2_validity = val2.ps2_validity);

                                        if ret then
                                            ret := (val1.anemometer = val2.anemometer);

                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccTM_Equal;

function asn1SccTM_imu_Init return asn1SccTM_imu
is
    val: asn1SccTM_imu;
begin

    --set mgt_mgauss 
    val.mgt_mgauss := asn1SccMGT_MilliGauss_Data_Init;
    --set accel_mg 
    val.accel_mg := asn1SccACC_MilliG_Data_Init;
    --set gyro_mdps 
    val.gyro_mdps := asn1SccGYRO_MilliDPS_Data_Init;
    --set temp_celsius 
    val.temp_celsius := asn1SccT_Float_Init;
    --set mgt_valid 
    val.mgt_valid := asn1SccContent_Validity_Init;
    --set acc_valid 
    val.acc_valid := asn1SccContent_Validity_Init;
    --set gyro_valid 
    val.gyro_valid := asn1SccContent_Validity_Init;
    --set temp_valid 
    val.temp_valid := asn1SccContent_Validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTM_imu_Init;
function asn1SccTM_Init return asn1SccTM
is
    val: asn1SccTM;
begin

    --set heater1 
    val.heater1 := asn1SccHeater_Data_Init;
    --set heater2 
    val.heater2 := asn1SccHeater_Data_Init;
    --set tc74s 
    val.tc74s := asn1SccTC74s_All_Data_Init;
    --set pt1000s 
    val.pt1000s := asn1SccPT1000s_All_Data_Init;
    --set gps 
    val.gps := asn1SccGPS_PVT_Init;
    --set imu 
    val.imu := asn1SccTM_imu_Init;
    --set ps1 
    val.ps1 := asn1SccPS_Processed_Data_Init;
    --set ps2 
    val.ps2 := asn1SccPS_Processed_Data_Init;
    --set ps1_validity 
    val.ps1_validity := asn1SccContent_Validity_Init;
    --set ps2_validity 
    val.ps2_validity := asn1SccContent_Validity_Init;
    --set anemometer 
    val.anemometer := asn1SccT_UInt64_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTM_Init;

function asn1SccTM_IsConstraintValid(val : asn1SccTM) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccHeater_Data_IsConstraintValid(val.heater1);
    if ret.Success then
        ret := asn1SccHeater_Data_IsConstraintValid(val.heater2);
        if ret.Success then
            ret := asn1SccTC74s_All_Data_IsConstraintValid(val.tc74s);
            if ret.Success then
                ret := asn1SccPT1000s_All_Data_IsConstraintValid(val.pt1000s);
                if ret.Success then
                    ret := asn1SccGPS_PVT_IsConstraintValid(val.gps);
                    if ret.Success then
                        ret := asn1SccMGT_MilliGauss_Data_IsConstraintValid(val.imu.mgt_mgauss);
                        if ret.Success then
                            ret := asn1SccACC_MilliG_Data_IsConstraintValid(val.imu.accel_mg);
                            if ret.Success then
                                ret := asn1SccGYRO_MilliDPS_Data_IsConstraintValid(val.imu.gyro_mdps);
                                if ret.Success then
                                    ret := asn1SccT_Float_IsConstraintValid(val.imu.temp_celsius);
                                    if ret.Success then
                                        ret := asn1SccContent_Validity_IsConstraintValid(val.imu.mgt_valid);
                                        if ret.Success then
                                            ret := asn1SccContent_Validity_IsConstraintValid(val.imu.acc_valid);
                                            if ret.Success then
                                                ret := asn1SccContent_Validity_IsConstraintValid(val.imu.gyro_valid);
                                                if ret.Success then
                                                    ret := asn1SccContent_Validity_IsConstraintValid(val.imu.temp_valid);
                                                end if;
                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                        if ret.Success then
                            ret := asn1SccPS_Processed_Data_IsConstraintValid(val.ps1);
                            if ret.Success then
                                ret := asn1SccPS_Processed_Data_IsConstraintValid(val.ps2);
                                if ret.Success then
                                    ret := asn1SccContent_Validity_IsConstraintValid(val.ps1_validity);
                                    if ret.Success then
                                        ret := asn1SccContent_Validity_IsConstraintValid(val.ps2_validity);
                                        if ret.Success then
                                            ret := asn1SccT_UInt64_IsConstraintValid(val.anemometer);
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccTM_IsConstraintValid;



function asn1SccHTL_GUI_pt1000s_validity_Equal (val1, val2 :  asn1SccHTL_GUI_pt1000s_validity) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 7 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccHTL_GUI_pt1000s_validity_Equal;

function asn1SccHTL_GUI_pt1000s_Equal (val1, val2 :  asn1SccHTL_GUI_pt1000s) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.aire_abajo, val2.aire_abajo));

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.aire_arriba, val2.aire_arriba));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.placa_abajo, val2.placa_abajo));

            if ret then
                ret := (adaasn1rtl.Asn1Real_Equal(val1.placa_arriba, val2.placa_arriba));

                if ret then
                    ret := (adaasn1rtl.Asn1Real_Equal(val1.infinito, val2.infinito));

                    if ret then
                        ret := (adaasn1rtl.Asn1Real_Equal(val1.exterior, val2.exterior));

                        if ret then
                            ret := (adaasn1rtl.Asn1Real_Equal(val1.vcc_volts, val2.vcc_volts));

                            if ret then
                                ret := asn1SccHTL_GUI_pt1000s_validity_Equal(val1.validity, val2.validity);

                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccHTL_GUI_pt1000s_Equal;

function asn1SccHTL_GUI_tc74s_validity_Equal (val1, val2 :  asn1SccHTL_GUI_tc74s_validity) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 5 loop
        --  pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end asn1SccHTL_GUI_tc74s_validity_Equal;

function asn1SccHTL_GUI_tc74s_Equal (val1, val2 :  asn1SccHTL_GUI_tc74s) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.x_positive, val2.x_positive));

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.x_negative, val2.x_negative));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.y_positive, val2.y_positive));

            if ret then
                ret := (adaasn1rtl.Asn1Real_Equal(val1.y_negative, val2.y_negative));

                if ret then
                    ret := (adaasn1rtl.Asn1Real_Equal(val1.z_techo, val2.z_techo));

                    if ret then
                        ret := asn1SccHTL_GUI_tc74s_validity_Equal(val1.validity, val2.validity);

                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccHTL_GUI_tc74s_Equal;

function asn1SccHTL_GUI_Equal (val1, val2 :  asn1SccHTL_GUI) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccHeater_Data_Equal(val1.heater, val2.heater);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.delta_T, val2.delta_T));

        if ret then
            ret := asn1SccHTL_GUI_pt1000s_Equal(val1.pt1000s, val2.pt1000s);

            if ret then
                ret := asn1SccHTL_GUI_tc74s_Equal(val1.tc74s, val2.tc74s);

            end if;
        end if;
    end if;
	return ret;

end asn1SccHTL_GUI_Equal;

function asn1SccHTL_GUI_pt1000s_validity_Init return asn1SccHTL_GUI_pt1000s_validity
is
    val: asn1SccHTL_GUI_pt1000s_validity;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 7 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=7);
        val.Data(i1) := asn1SccContent_Validity_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHTL_GUI_pt1000s_validity_Init;
function asn1SccHTL_GUI_pt1000s_Init return asn1SccHTL_GUI_pt1000s
is
    val: asn1SccHTL_GUI_pt1000s;
begin

    --set aire_abajo 
    val.aire_abajo := asn1SccT_Float_Init;
    --set aire_arriba 
    val.aire_arriba := asn1SccT_Float_Init;
    --set placa_abajo 
    val.placa_abajo := asn1SccT_Float_Init;
    --set placa_arriba 
    val.placa_arriba := asn1SccT_Float_Init;
    --set infinito 
    val.infinito := asn1SccT_Float_Init;
    --set exterior 
    val.exterior := asn1SccT_Float_Init;
    --set vcc_volts 
    val.vcc_volts := asn1SccT_Float_Init;
    --set validity 
    val.validity := asn1SccHTL_GUI_pt1000s_validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHTL_GUI_pt1000s_Init;
function asn1SccHTL_GUI_tc74s_validity_Init return asn1SccHTL_GUI_tc74s_validity
is
    val: asn1SccHTL_GUI_tc74s_validity;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 5 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=5);
        val.Data(i1) := asn1SccContent_Validity_Init;
        i1 := i1 + 1;
    end loop;

	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHTL_GUI_tc74s_validity_Init;
function asn1SccHTL_GUI_tc74s_Init return asn1SccHTL_GUI_tc74s
is
    val: asn1SccHTL_GUI_tc74s;
begin

    --set x_positive 
    val.x_positive := asn1SccT_Float_Init;
    --set x_negative 
    val.x_negative := asn1SccT_Float_Init;
    --set y_positive 
    val.y_positive := asn1SccT_Float_Init;
    --set y_negative 
    val.y_negative := asn1SccT_Float_Init;
    --set z_techo 
    val.z_techo := asn1SccT_Float_Init;
    --set validity 
    val.validity := asn1SccHTL_GUI_tc74s_validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHTL_GUI_tc74s_Init;
function asn1SccHTL_GUI_Init return asn1SccHTL_GUI
is
    val: asn1SccHTL_GUI;
begin

    --set heater 
    val.heater := asn1SccHeater_Data_Init;
    --set delta_T 
    val.delta_T := asn1SccT_Float_Init;
    --set pt1000s 
    val.pt1000s := asn1SccHTL_GUI_pt1000s_Init;
    --set tc74s 
    val.tc74s := asn1SccHTL_GUI_tc74s_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHTL_GUI_Init;

function asn1SccHTL_GUI_IsConstraintValid(val : asn1SccHTL_GUI) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    ret := asn1SccHeater_Data_IsConstraintValid(val.heater);
    if ret.Success then
        ret := asn1SccT_Float_IsConstraintValid(val.delta_T);
        if ret.Success then
            ret := asn1SccT_Float_IsConstraintValid(val.pt1000s.aire_abajo);
            if ret.Success then
                ret := asn1SccT_Float_IsConstraintValid(val.pt1000s.aire_arriba);
                if ret.Success then
                    ret := asn1SccT_Float_IsConstraintValid(val.pt1000s.placa_abajo);
                    if ret.Success then
                        ret := asn1SccT_Float_IsConstraintValid(val.pt1000s.placa_arriba);
                        if ret.Success then
                            ret := asn1SccT_Float_IsConstraintValid(val.pt1000s.infinito);
                            if ret.Success then
                                ret := asn1SccT_Float_IsConstraintValid(val.pt1000s.exterior);
                                if ret.Success then
                                    ret := asn1SccT_Float_IsConstraintValid(val.pt1000s.vcc_volts);
                                    if ret.Success then
                                        i1 := val.pt1000s.validity.Data'First;
                                        while ret.Success and i1 <= 7 loop
                                            pragma Loop_Invariant (i1 >= val.pt1000s.validity.Data'First and i1 <= 7);
                                            ret := asn1SccContent_Validity_IsConstraintValid(val.pt1000s.validity.Data(i1));
                                            i1 := i1+1;
                                        end loop;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
            if ret.Success then
                ret := asn1SccT_Float_IsConstraintValid(val.tc74s.x_positive);
                if ret.Success then
                    ret := asn1SccT_Float_IsConstraintValid(val.tc74s.x_negative);
                    if ret.Success then
                        ret := asn1SccT_Float_IsConstraintValid(val.tc74s.y_positive);
                        if ret.Success then
                            ret := asn1SccT_Float_IsConstraintValid(val.tc74s.y_negative);
                            if ret.Success then
                                ret := asn1SccT_Float_IsConstraintValid(val.tc74s.z_techo);
                                if ret.Success then
                                    i1 := val.tc74s.validity.Data'First;
                                    while ret.Success and i1 <= 5 loop
                                        pragma Loop_Invariant (i1 >= val.tc74s.validity.Data'First and i1 <= 5);
                                        ret := asn1SccContent_Validity_IsConstraintValid(val.tc74s.validity.Data(i1));
                                        i1 := i1+1;
                                    end loop;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccHTL_GUI_IsConstraintValid;



function asn1SccATT_GUI_imu_Equal (val1, val2 :  asn1SccATT_GUI_imu) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccMGT_MilliGauss_Data_Equal(val1.mgt_mgauss, val2.mgt_mgauss);

    if ret then
        ret := asn1SccACC_MilliG_Data_Equal(val1.accel_mg, val2.accel_mg);

        if ret then
            ret := asn1SccGYRO_MilliDPS_Data_Equal(val1.gyro_mdps, val2.gyro_mdps);

            if ret then
                ret := (adaasn1rtl.Asn1Real_Equal(val1.temp_celsius, val2.temp_celsius));

                if ret then
                    ret := (val1.mgt_valid = val2.mgt_valid);

                    if ret then
                        ret := (val1.acc_valid = val2.acc_valid);

                        if ret then
                            ret := (val1.gyro_valid = val2.gyro_valid);

                            if ret then
                                ret := (val1.temp_valid = val2.temp_valid);

                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccATT_GUI_imu_Equal;

function asn1SccATT_GUI_Equal (val1, val2 :  asn1SccATT_GUI) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccGPS_PVT_Equal(val1.gps, val2.gps);

    if ret then
        ret := asn1SccDate_Time_Equal(val1.gps_date_time, val2.gps_date_time);

        if ret then
            ret := asn1SccATT_GUI_imu_Equal(val1.imu, val2.imu);

        end if;
    end if;
	return ret;

end asn1SccATT_GUI_Equal;

function asn1SccATT_GUI_imu_Init return asn1SccATT_GUI_imu
is
    val: asn1SccATT_GUI_imu;
begin

    --set mgt_mgauss 
    val.mgt_mgauss := asn1SccMGT_MilliGauss_Data_Init;
    --set accel_mg 
    val.accel_mg := asn1SccACC_MilliG_Data_Init;
    --set gyro_mdps 
    val.gyro_mdps := asn1SccGYRO_MilliDPS_Data_Init;
    --set temp_celsius 
    val.temp_celsius := asn1SccT_Float_Init;
    --set mgt_valid 
    val.mgt_valid := asn1SccContent_Validity_Init;
    --set acc_valid 
    val.acc_valid := asn1SccContent_Validity_Init;
    --set gyro_valid 
    val.gyro_valid := asn1SccContent_Validity_Init;
    --set temp_valid 
    val.temp_valid := asn1SccContent_Validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccATT_GUI_imu_Init;
function asn1SccATT_GUI_Init return asn1SccATT_GUI
is
    val: asn1SccATT_GUI;
begin

    --set gps 
    val.gps := asn1SccGPS_PVT_Init;
    --set gps_date_time 
    val.gps_date_time := asn1SccDate_Time_Init;
    --set imu 
    val.imu := asn1SccATT_GUI_imu_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccATT_GUI_Init;

function asn1SccATT_GUI_IsConstraintValid(val : asn1SccATT_GUI) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccGPS_PVT_IsConstraintValid(val.gps);
    if ret.Success then
        ret := asn1SccDate_Time_IsConstraintValid(val.gps_date_time);
        if ret.Success then
            ret := asn1SccMGT_MilliGauss_Data_IsConstraintValid(val.imu.mgt_mgauss);
            if ret.Success then
                ret := asn1SccACC_MilliG_Data_IsConstraintValid(val.imu.accel_mg);
                if ret.Success then
                    ret := asn1SccGYRO_MilliDPS_Data_IsConstraintValid(val.imu.gyro_mdps);
                    if ret.Success then
                        ret := asn1SccT_Float_IsConstraintValid(val.imu.temp_celsius);
                        if ret.Success then
                            ret := asn1SccContent_Validity_IsConstraintValid(val.imu.mgt_valid);
                            if ret.Success then
                                ret := asn1SccContent_Validity_IsConstraintValid(val.imu.acc_valid);
                                if ret.Success then
                                    ret := asn1SccContent_Validity_IsConstraintValid(val.imu.gyro_valid);
                                    if ret.Success then
                                        ret := asn1SccContent_Validity_IsConstraintValid(val.imu.temp_valid);
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccATT_GUI_IsConstraintValid;



function asn1SccPS_GUI_Equal (val1, val2 :  asn1SccPS_GUI) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.pressure_mbar, val2.pressure_mbar));

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.temperature_celsius, val2.temperature_celsius));

        if ret then
            ret := (val1.validity = val2.validity);

        end if;
    end if;
	return ret;

end asn1SccPS_GUI_Equal;

function asn1SccPS_GUI_Init return asn1SccPS_GUI
is
    val: asn1SccPS_GUI;
begin

    --set pressure_mbar 
    val.pressure_mbar := asn1SccT_Double_Init;
    --set temperature_celsius 
    val.temperature_celsius := asn1SccT_Double_Init;
    --set validity 
    val.validity := asn1SccContent_Validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPS_GUI_Init;

function asn1SccPS_GUI_IsConstraintValid(val : asn1SccPS_GUI) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccT_Double_IsConstraintValid(val.pressure_mbar);
    if ret.Success then
        ret := asn1SccT_Double_IsConstraintValid(val.temperature_celsius);
        if ret.Success then
            ret := asn1SccContent_Validity_IsConstraintValid(val.validity);
        end if;
    end if;
    return ret;
end asn1SccPS_GUI_IsConstraintValid;



function asn1SccENV_GUI_anemometer_Equal (val1, val2 :  asn1SccENV_GUI_anemometer) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.global_counter = val2.global_counter);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.temperature_celsius, val2.temperature_celsius));

        if ret then
            ret := (val1.temperature_validity = val2.temperature_validity);

        end if;
    end if;
	return ret;

end asn1SccENV_GUI_anemometer_Equal;

function asn1SccENV_GUI_Equal (val1, val2 :  asn1SccENV_GUI) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccPS_GUI_Equal(val1.pressure_sensor_1, val2.pressure_sensor_1);

    if ret then
        ret := asn1SccPS_GUI_Equal(val1.pressure_sensor_2, val2.pressure_sensor_2);

        if ret then
            ret := asn1SccENV_GUI_anemometer_Equal(val1.anemometer, val2.anemometer);

            if ret then
                ret := asn1SccHeater_Data_Equal(val1.heater, val2.heater);

            end if;
        end if;
    end if;
	return ret;

end asn1SccENV_GUI_Equal;

function asn1SccENV_GUI_anemometer_Init return asn1SccENV_GUI_anemometer
is
    val: asn1SccENV_GUI_anemometer;
begin

    --set global_counter 
    val.global_counter := asn1SccT_UInt64_Init;
    --set temperature_celsius 
    val.temperature_celsius := asn1SccT_Float_Init;
    --set temperature_validity 
    val.temperature_validity := asn1SccContent_Validity_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccENV_GUI_anemometer_Init;
function asn1SccENV_GUI_Init return asn1SccENV_GUI
is
    val: asn1SccENV_GUI;
begin

    --set pressure_sensor_1 
    val.pressure_sensor_1 := asn1SccPS_GUI_Init;
    --set pressure_sensor_2 
    val.pressure_sensor_2 := asn1SccPS_GUI_Init;
    --set anemometer 
    val.anemometer := asn1SccENV_GUI_anemometer_Init;
    --set heater 
    val.heater := asn1SccHeater_Data_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccENV_GUI_Init;

function asn1SccENV_GUI_IsConstraintValid(val : asn1SccENV_GUI) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccPS_GUI_IsConstraintValid(val.pressure_sensor_1);
    if ret.Success then
        ret := asn1SccPS_GUI_IsConstraintValid(val.pressure_sensor_2);
        if ret.Success then
            ret := asn1SccT_UInt64_IsConstraintValid(val.anemometer.global_counter);
            if ret.Success then
                ret := asn1SccT_Float_IsConstraintValid(val.anemometer.temperature_celsius);
                if ret.Success then
                    ret := asn1SccContent_Validity_IsConstraintValid(val.anemometer.temperature_validity);
                end if;
            end if;
            if ret.Success then
                ret := asn1SccHeater_Data_IsConstraintValid(val.heater);
            end if;
        end if;
    end if;
    return ret;
end asn1SccENV_GUI_IsConstraintValid;



function asn1SccHeater_On_Off_Equal (val1, val2 :  asn1SccHeater_On_Off) return Boolean
is

begin
	return val1 = val2;

end asn1SccHeater_On_Off_Equal;

function asn1SccHeater_On_Off_Init return asn1SccHeater_On_Off
is
    val: asn1SccHeater_On_Off;
begin
    val := asn1Sccon;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHeater_On_Off_Init;

function asn1SccHeater_On_Off_IsConstraintValid(val : asn1SccHeater_On_Off) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1Sccon)) OR ((val = asn1Sccoff)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_HEATER_ON_OFF);
    return ret;
end asn1SccHeater_On_Off_IsConstraintValid;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end TASEC_LAB_B2SPACE_DATAVIEW;